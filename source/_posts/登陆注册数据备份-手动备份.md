---
title: 登陆注册数据备份(手动备份)
date: 2025-09-14 14:40:47
categories:
- Android随笔
tags:
---



**本博客以firebase服务器为例**

### 结构图

```scss
users (Collection)
   └── uid1 (Document)
        └── messages (Collection)
            ├── message1 (Document)
            ├── message2 (Document)
   └── uid2 (Document)
        └── messages (Collection)
            ├── message1 (Document)
```



### 注册

- 获取auth和firestore对象
- 向云端上传用户信息
- 利用firestore建立个人档案

```kotlin
            auth.createUserWithEmailAndPassword(email,password)
                .addOnCompleteListener(this){task ->
                    if (task.isSuccessful){
                        Toast.makeText(this, "账户创建成功", Toast.LENGTH_SHORT).show()
                        val user= auth.currentUser
                        val uid=user?.uid
                        val userProfile=hashMapOf(
                            "uid" to uid,
                            "email" to email,
                            "registTime" to System.currentTimeMillis()
                        )
                        //建立个人档案，将数据写入数据库中
                        db.collection("users").document(uid!!)
                            .set(userProfile)
                            .addOnSuccessListener {
                                finish()
                            }
                            .addOnSuccessListener {
                                Toast.makeText(this,"用户信息储存失败请稍后重试",Toast.LENGTH_SHORT).show()
                            }
                    }else{
                        Toast.makeText(this,"账户创建失败",Toast.LENGTH_SHORT).show()
                    }

                }
```

### 登录

```kotlin
 private fun login(){
        val email=binding.email.text.toString()
        val password=binding.password.text.toString()
        if(email.isEmpty()||password.isEmpty()){
            Toast.makeText(this,"邮箱或密码不能为空",Toast.LENGTH_SHORT).show()
            return
        }
        auth.signInWithEmailAndPassword(email, password)
            .addOnCompleteListener { task ->
                if (task.isSuccessful) {
                    //这一步是为了实现用户数据隔离
                    lifecycleScope.launch {
                        // 先清空数据库
                        dao.clearAllMessages()
                        dao.clearAllCategories()
                        // 再切回主线程做 UI 操作
                            restoreFromFirestore(dao)
                            Toast.makeText(this@LoginActivity, "用户登陆成功", Toast.LENGTH_SHORT).show()
                            val i = Intent(this@LoginActivity, MainActivity::class.java)
                            startActivity(i)
                            finish()

                    }
                } else {
                    Toast.makeText(
                        this@LoginActivity,
                        "登录失败: ${task.exception?.message}",
                        Toast.LENGTH_LONG
                    ).show()
                    binding.email.setText("")
                    binding.password.setText("")
                }
            }
```

### 数据备份

- 实现备份
- 实现恢复
- 在UI层调用

```kotlin
suspend fun backupToFirestore(dao: MessageDao) {
    //获取当前已登录的用户
        val user = FirebaseAuth.getInstance().currentUser ?: return
    //获取用户uid值作为唯一标识
        val uid = user.uid
    //获取数据库实例
        val db = FirebaseFirestore.getInstance()
//加载所有信息

        val messages = dao.loadAllMessage()
//在uid文件下创建messages集合作为uid下子集和
        val userMessagesRef = db.collection("users").document(uid).collection("messages")
   //创建一个批量处理操作的对象
        val batch = db.batch()
    //便利本地数据库所有数据
        for (msg in messages) {
            //以信息的id作为文档id用来获取索引或创建
            val docRef = userMessagesRef.document(msg.id)
            //将数据转化成键值对形式
             val msgMap = mapOf(
                 "title" to msg.title,
                  "time" to msg.time,
               "aimdate" to msg.aimdate,
             "isTop" to msg.isTop,
             "categoryIcon" to msg.categoryIcon,
            "categoryName" to msg.categoryName,
             "categoryId" to msg.categoryId
            )
            //将数据添加到docRef文档下面
            batch.set(docRef, msgMap)
        }
       
        try {
 //batch.commit()：提交所有批量写入操作，返回一个 Task。
//await()：挂起当前协程，等待 Task 完成，直到异步操作结束。
//这样，你就可以确保 所有操作都提交成功，并能在操作完成后继续执行下一步逻辑。
            batch.commit().await()
            Log.d("Backup", "备份成功")
        } catch (e: Exception) {
            Log.e("Backup", "备份失败: ${e.message}", e)
        }

    }
```

```kotlin
suspend fun restoreFromFirestore(dao: MessageDao) {
        val user = FirebaseAuth.getInstance().currentUser ?: return
        val uid = user.uid
        val db = FirebaseFirestore.getInstance()
//获取集合中的所有文档，get()方法是异步的所以需要awit()方法
        val snapshot1 = db.collection("users").document(uid).collection("messages").get().await()
     
        // 清空本地再导入（防止重复）
        dao.clearAllMessages()

//遍历所有文档，并把数据添加到本地数据库
        for (doc in snapshot1.documents) {
            val id = doc.id
            val title: String? = doc.getString("title")?:""
            val time: Int= doc.getLong("time")?.toInt() ?: 0
            val aimdate: String?=doc.getString("aimdate")
            val isTop =doc.getBoolean("isTop")?:false
            val categoryIcon:Int?= doc.getLong("categoryIcon")?.toInt()
            val categoryName: String?=doc.getString("categoryName")
            val categoryId: String= doc.getString("categoryId").toString()
            val msg = Message(title,time,aimdate,isTop,id,categoryIcon,categoryName,categoryId)
            dao.insertMessage(msg)
        }
     //加载数据
        dao.loadAllMessage()

    }
```

