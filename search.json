[{"title":"Activity启动模式","url":"/posts/Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/","content":"什么是Activity所需要的任务栈？“Activity 所需要的任务栈”这个说法的背后，其实是在讨论一个核心概念：taskAffinity（任务相关性）。\n简单来说，“Activity 所需要的任务栈” 就是指 一个 Activity “期望”或“倾向于”在哪个任务栈（Task）中运行。\n这个“期望”就是由 taskAffinity 这个属性来定义的。一般情况下任务栈的名字为应用的包名，也可以单独为Activity指定taskAffinity属性值，这个属性不能和包名相同。\n指定Activity启动模式方法一\n通过AndroidMenifest为Activity指定启动模式\n&lt;activity            android:name=&quot;.SecondActivity&quot;            android:configChanges=&quot;screenLayout&quot;            android:launchMode=&quot;singleTask&quot;            android:label=&quot;@string/app_name&quot;            /&gt;\n\n方法二\n通过在Intent中设置标置位启动\nIntent intent=new Intent();intent.setClass(MainActivity.this,SecondActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent);\n\n两种方法的区别\n\n优先级：方法二&gt;方法一\n限定范围：方法一无法直接为Activity设定FLAG_ACTIVITY_CLEAR_TOP标识，而方法二无法为Activity指定singleInstance模式\n\nActivity的Flags\nFLAG_ACTIVITY_NEW_TASK\n为Activity指定singleTask启动模式\n\nFLAG_ACTIVITY_SINGLE_TOP\n为Activity指定singleTop启动模式\n\nFLAG_ACTIVITY_CLEAR_TOP\n具有此标记位的activity当他启动时同一个任务栈中位于他上面的Activity都要出栈，这个标记位一般和singleTask启动模式一起出现\n\nFLAG_ACTIVITY_EXCLUDE_FROM_RECENTS\n具有这个标记的Activity不会出现在历史的Activity列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用\n\n\nIntentFilter的匹配规则\naction的匹配规则\nIntent中的action必须能和过滤规则中的action匹配，这里说的匹配是指action字符串的值完全一样。一个过滤规则可以有多个action，只要Intent中的action能和其中任何一个action相同即可匹配成功。总之，Intent中的action必须存在且能匹配，并且action要区分大小写\n\ncategory匹配规则\n要么不设置，如果设置了就必须和过滤规则中的任何一个相同。不设置是因为系统用startActivity和startActivityForResult时会默认为Intent加上默认的category，同时为了接收隐式调用也需要在过滤规则中表明这个默认的category\n\ndata匹配规则\ndata匹配规则和action类似，如果过滤规则中定义了data，那么Intent中必须也要定义可匹配的data\n\n不指定URI时会有默认值一般是content或者file\n&lt;intent-filter&gt;          &lt;data android:mimeType=&quot;image/*&quot;/&gt;      &lt;/intent-filter&gt;\n\nintent.setDataAndType(Uri.parse(&quot;file://abc&quot;),&quot;image/png&quot;)//必须调用setDataAndType方法，调用setData或者setType会彼此清除对方的值\n\n\n\n指定完整的属性值\n&lt;intent-filter&gt;           &lt;data android:mimeType=&quot;video/mpeg&quot; android:scheme=&quot;https&quot; .../&gt;           &lt;data android:mimeType=&quot;audio/mpeg&quot; android:scheme=&quot;https&quot; .../&gt;           ...       &lt;/intent-filter&gt;\n\nintent.setDataAndType(Uri.parse(&quot;https://abc&quot;),&quot;video/mpeg&quot;)\n\n或者\nintent.setDataAndType(Uri.parse(&quot;https://abc&quot;),&quot;audio/mpeg&quot;)\n\n\n\n以下两种写法作用一样\n&lt;intent-filter&gt;           &lt;data android:scheme=&quot;file&quot; android:host=&quot;www.baidu.com&quot;/&gt;             ...       &lt;/intent-filter&gt;&lt;intent-filter&gt;           &lt;data android:scheme=&quot;file&quot;/&gt;           &lt;data android:host=&quot;www.baidu.com&quot;/&gt;           ...       &lt;/intent-filter&gt;\n\n\ndata的结构\n\n语法如下：\n&lt;data android:scheme=&quot;string&quot;    \tandroid:host=&quot;string&quot;        android:port=&quot;80&quot;        android:path=&quot;/string&quot;        android:pathPattern=&quot;string&quot;        android:pathPrefix=&quot;/string&quot;        android:mimeType=&quot;string&quot;/&gt;\n\ndata由两部分组成：miniType和URI，miniType指媒体类型，比如image&#x2F;jpeg、video&#x2F;*等URI结构：:&#x2F;&#x2F;:&#x2F;[||]URI例子：http://www.baidu.com:80/search/info\n\nScheme： URI的模式，比如http、file、content等，如果URI中没有指定scheme，那么整个URI的其他参数将无效，意味着URI也无效。\nHost： URI的主机名，比如www.baidu.com，如果host未指定，那么整个URI中的其他参数无效，意味着URI也是无效的。\nPort： URI的端口号，仅当URI中指定了scheme和host参数的时候，port才是有意义的。\nPath、     pathPattern    和        pathPrefix：这三个参数表述路径的信息，其中path表示完整的路径信息，pathPattern   也表示完整的路径信息，但是它里面可以包含通配符“”，“”表示0个或多个任意字符（由于正则表达式的规范，如果想表示真实的字符串，那么“”要写成“\\”，“\\”要写成”\\“，pathPattern    表示路径的前缀信息）\n\n\n\n\n\n","categories":["Android进阶"]},{"title":"Activity生命周期全面分析","url":"/posts/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%85%A8%E9%9D%A2%E5%88%86%E6%9E%90/","content":"典型情况下的生命周期分析onStart和onResum、onPause和onStop描述上差 不多，本质上有啥不同？\nonStart和onStop是从Activity是否可见这个角度来回调的，onResum和onPause是从Activity是否位于前台这个角度来回调的\n\n假设当前Activity为A，新打开一个Activity B，那么B的onResume和A的onPause哪个先执行？\n旧的Activity先onPause然后新的Activity再启动\n\n异常情况下生命周期分析情况1：资源相关的系统配置发生改变导致Activity被杀死并重新创建\n这种情况下会调用onSaveInstanceState和onRestoreInstanceState方法保存和恢复数据，系统自动为我们做了一些恢复工作\n系统只在Activity异常终止时候才会触发这个过程，其他情况都不触发\n\n情况2：资源内存不足导致低优先级的Activity被杀死\n优先级从高到低分下面三类：\n\n前台Activity—–正在和用户交互，优先级最高\n可见但非前台—–比如Activity中弹出一个对话框，导致Activity可见但位于后台无法直接交互\n后台Activity——已经被暂停的Activity，优先级最低\n\n\n系统会按照上述优先级杀死目标Activity所在的进程，并通过onSaveInstanceState和onRestoreInstanceState方法存储和恢复数据。如果一个进程中无四大组件执行，那么这个进程很快会被系统杀死，因此一些后台工作不适合脱离四大组件而独自运行在后台，这样很容易被杀死。比较好的方法是将后台工作放入Service中从而保证进程优先级，不会被轻易杀死。\n\n修改Activity的configChanges属性值可以使Activity不被重建，比如给configChanges添加orientation这个值，可以让Activity旋转后也不重新创建\n\nconfigChanges项目及其含义\n\n\n\n","categories":["Android进阶"]},{"title":"Android认识以及入门","url":"/posts/Android%E8%AE%A4%E8%AF%86%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8/","content":"系统架构1.Linux内核层:提供底层驱动2.系统运行库层:提供主要的特性支持(通过C&#x2F;C++库)，同样这一层也有Android运行时库，提供了一些核心库，能允许开发者使用Java来编写应用。3.应用框架层:提供了各种API4.应用层:安装到手机上的应用程序都属于这一层\n\nAndroid应用开发特色1.四大组件:活动，服务，广播接收器，内容提供器。2.丰富的系统控件3.SQLite数据库:让存储数据和读取数据变得更为方便4.强大的多媒体5.地理位置定位\n\n项目中各个文件的作用1.gradle:里面含有gradle wrapper配置文件，需要打开的话必须手动按照“导航栏FileSettingsBulid,Execution,DeploymentGradle”这个步骤进行2..gitignore:将指定的目录或文件排除在版本控制之外。3.gradle.properties:这个文件是全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本。4.gradlew和gradlew.bat:用来在命令行界面中执行gradle命令的，其中gradle是在Linux或Mac系统使用，gradlew.bat在Windows系统使用\n\napp目录详解1.libs:jar包存放的地方2.Androidtest:编写测试用例，对项目进行自动化测试3.Java:放置Java代码的地方4.res:①图片放在drawable中②布局放在layout中③字符串，样式，颜色等配置放在values中④mipmap中放置一些图标5.AndroidManifest.xml:整个Android项目配置文件，四大组件和活动等都需要在这里注册，经常会使用到这个文件。6.test:编写测试用例，是对项目自动化测试的另一种方式7.build.gradle:这个文件中会指定很多项目构建相关的配置8.proguard-rules.pro:指定项目代码的混淆规则\n\n主活动的设定即首先启动的活动\n&lt;intent-filter&gt;    &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;&lt;/intent-filter&gt;\n\n\n引用的方法1.R.string.hello_world2.@string&#x2F;hello_world如果在@和string之间添上一个+就变成了定义其中的string可以替换\n\n日志工具从小到大的顺序Log.v:打印意义最小的信息Log.d:打印调试信息Log.i:比较重要的数据Log.w:警告信息Log.e:错误信息传入两个参数:第一个参数是tag，一般传入类名就好主要用于对打印信息的过滤第二个参数是msg，即想要打印的内容一般与logcat结合使用\n\n","categories":["Android(Java版)"]},{"title":"Android多进程模式","url":"/posts/Android%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%BC%8F/","content":"开启多线程模式、开启的方法\n\n在Android中使用多进程只有一种方法，那就是给四大组件指定android:process属性\n还有一种非常规的方法是通过JNI在native层去fork一个新的进程，但一般不做考虑\n\n实例\n&lt;activity            android:name=&quot;.ThirdActivity&quot;            android:exported=&quot;false&quot;            android:process=&quot;:app&quot;/&gt;        &lt;activity            android:name=&quot;.SecondActivity&quot;            android:configChanges=&quot;screenLayout&quot;            android:exported=&quot;false&quot;            android:launchMode=&quot;singleTask&quot;            android:process=&quot;com.example.activitycycletest.app&quot;/&gt;        &lt;activity            android:name=&quot;.MainActivity&quot;            android:configChanges=&quot;orientation|screenSize&quot;            android:exported=&quot;true&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;\n\n\n查询进程的方法\n在终端输入命令\nadb shell ps | Select-String +包名\n进程分类\n\n进程名以“：”开头的属于当前应用的私有进程，其他应用的组件不可以和他跑在同一个进程中，而进程名不以“：”开头的属于全局进程，其他应用通过ShareUID方式可以和他跑在同一个进程中\n两个应用通过ShareUID跑在同一个进程中是有要求的，需要两个应用有相同的ShareUID并且签名相同才可以\n\n多进程模式的运行机制不同进程之间数据共享失败的原因\nAndroid为每一个进程都分配了虚拟机，不同的虚拟机在内存分布上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类的对象会产生多个副本\n多进程造成的问题\n\n静态成员和单例模式完全失效\n线程同步机制完全失效\nSharedPreferences的可靠性下降（SharedPreferences不支持两个进程同时去执行写操作，否则导致一定几率数据丢失 ）\nApplication会多次创建\n\n","categories":["Android进阶"]},{"title":"Binder连接池","url":"/posts/Binder%E8%BF%9E%E6%8E%A5%E6%B1%A0/","content":"\n先创建不同需求的AIDL接口\ninterface ICompute &#123;//计算加法的功能    int add(int a,int b);&#125;interface ISecurityCenter &#123;//加密   String encrypt(String content);   //解密   String decrypt(String password);&#125;\n\n\n\n对创建的接口进行实现\npublic class ComputeImpl  extends  ICompute.Stub&#123;    @Override    public int add(int a, int b) throws RemoteException &#123;        return a+b;    &#125;&#125;public class SecurityCenterImpl extends ISecurityCenter.Stub&#123;    private static final char SECRET_CODE=&#x27;^&#x27;;    @Override    public String encrypt(String content) throws RemoteException &#123;        char[] chars = content.toCharArray();        for (int i = 0; i &lt; chars.length; i++) &#123;            // 核心加密逻辑            chars[i] ^= SECRET_CODE;        &#125;        return new String(chars);    &#125;    @Override    public String decrypt(String password) throws RemoteException &#123;        return encrypt(password);    &#125;&#125;\n\n为Binder连接池创建AIDL接口\n// IBinderPool.aidlpackage com.example.contentprovider;// Declare any non-default types here with import statementsinterface IBinderPool &#123;    IBinder queryBinder(int binderCode);&#125;\n\nBinder连接池的具体实现(首先要去绑定远程服务，绑定成功后，客户端可以通过queryBinder方法去获取各自对应的Binder，拿到所需的Binder后，就可以进行各自的操作了)\nimport android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.IBinder;import android.os.RemoteException;import android.util.Log;import java.util.concurrent.CountDownLatch;/** * Binder连接池的客户端实现。 * 这是一个采用单例模式设计的核心类，负责管理与远程BinderPoolService的连接， * 并作为客户端获取各种具体业务Binder的统一入口。 * 它将异步的bindService过程封装成了同步的调用方式，简化了客户端的使用。 */public class BinderPool &#123;    // 日志标签    private static final String TAG = &quot;BinderPool&quot;;    // Binder代号：无效Binder    public static final int BINDER_NONE = -1;    // Binder代号：计算服务    public static final int BINDER_COMPUTE = 0;    // Binder代号：安全中心服务    public static final int BINDER_SECURITY_CENTER = 1;    // 应用上下文，使用getApplicationContext()防止内存泄漏    private Context mContext;    // 远程Binder池服务的代理对象，用于调用远程方法    private IBinderPool mBinderPool;    // BinderPool的唯一静态实例，volatile关键字确保多线程下的可见性    private static volatile BinderPool sInstance;    // 同步辅助工具，用于在连接建立完成前阻塞线程    private CountDownLatch mConnectBinderPoolCountDownLatch;    /**     * 私有构造函数，确保只能通过getInstance()方法获取实例（单例模式）。     * @param context 上下文对象     */    private BinderPool(Context context) &#123;        mContext = context.getApplicationContext();        // 构造时立即开始连接服务        connectBinderPoolService();    &#125;    /**     * 获取BinderPool的唯一实例（线程安全的双重检查锁定单例模式）。     * @param context 上下文对象     * @return BinderPool的单例     */    public static BinderPool getInstance(Context context) &#123;        if (sInstance == null) &#123;            // synchronized 锁就像一个单人房间，一次只允许一个线程进入，保证线程安全            synchronized (BinderPool.class) &#123;                // 第二次检查，防止多个线程同时通过第一次检查后重复创建实例                if (sInstance == null) &#123;                    sInstance = new BinderPool(context);                &#125;            &#125;        &#125;        return sInstance;    &#125;    /**     * 同步连接远程服务的方法。     * 该方法会阻塞调用线程，直到与服务的连接成功建立。     */    private synchronized void connectBinderPoolService() &#123;        // 初始化一个计数为1的CountDownLatch，作为阻塞的“门闩”        mConnectBinderPoolCountDownLatch = new CountDownLatch(1);        Intent service = new Intent(mContext, BinderPoolService.class);        // 异步绑定服务，绑定结果通过 mBinderPoolConnection 回调        mContext.bindService(service, mBinderPoolConnection, Context.BIND_AUTO_CREATE);        try &#123;            // 阻塞当前线程，等待门闩被打开（即等待onServiceConnected中的countDown()被调用）            mConnectBinderPoolCountDownLatch.await();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    /**     * 从Binder连接池中查询具体的业务Binder。     * 这是提供给外部调用的核心方法。     * @param binderCode 业务Binder的代号（如 BINDER_COMPUTE）     * @return 对应的业务Binder接口；如果连接未建立或发生异常则返回null     */    public IBinder queryBinder(int binderCode) &#123;        IBinder binder = null;        try &#123;            // 确保连接池代理不为空，然后发起跨进程调用            if (mBinderPool != null) &#123;                binder = mBinderPool.queryBinder(binderCode);            &#125;        &#125; catch (RemoteException e) &#123;            // 捕获远程调用异常            e.printStackTrace();        &#125;        return binder;    &#125;    /**     * ServiceConnection的实现，用于监听与服务的连接状态。     */    private ServiceConnection mBinderPoolConnection = new ServiceConnection() &#123;        /**         * 当与服务的连接成功建立时被回调（运行在主线程）。         */        @Override        public void onServiceConnected(ComponentName name, IBinder service) &#123;            // 将返回的原始IBinder对象转换为我们定义的IBinderPool接口            mBinderPool = IBinderPool.Stub.asInterface(service);            try &#123;                // 设置死亡代理，监听远程Binder的死亡事件，增强健壮性                mBinderPool.asBinder().linkToDeath(mBinderPoolDeathRecipient, 0);            &#125; catch (RemoteException e) &#123;                e.printStackTrace();            &#125;            // 连接成功，打开“门闩”，唤醒所有等待的线程            mConnectBinderPoolCountDownLatch.countDown();        &#125;        /**         * 当与服务的连接意外断开时被回调（例如服务进程崩溃）。         * 注意：正常解绑不会触发此方法。         */        @Override        public void onServiceDisconnected(ComponentName name) &#123;            // 此处可以添加重连逻辑        &#125;    &#125;;    /**     * 死亡代理的实现。当远程服务进程意外死亡时，binderDied()方法会被回调。     */    private IBinder.DeathRecipient mBinderPoolDeathRecipient = new IBinder.DeathRecipient() &#123;        @Override        public void binderDied() &#123;            Log.w(TAG, &quot;binder died&quot;);            // 1. 解除之前与已死亡Binder的死亡监听            mBinderPool.asBinder().unlinkToDeath(mBinderPoolDeathRecipient, 0);            // 2. 将持有的Binder代理置为空，防止误用            mBinderPool = null;            // 3. 立即尝试重新连接服务，实现自动恢复            connectBinderPoolService();        &#125;    &#125;;    /**     * 这是IBinderPool接口的服务端实现。     * 它作为Binder连接池的“工厂”，根据客户端请求的binderCode，返回对应的具体业务Binder。     * （通常这个类会放在服务端，这里放在一起是为了演示方便）     */    public static class BinderPoolImpl extends IBinderPool.Stub &#123;        public BinderPoolImpl() &#123;            super();        &#125;        @Override        public IBinder queryBinder(int binderCode) throws RemoteException &#123;            IBinder binder = null;            // 使用switch-case结构分发不同的Binder实现            switch (binderCode) &#123;                case BINDER_SECURITY_CENTER: &#123;                    // 如果客户端请求安全中心，就创建一个SecurityCenterImpl实例                    binder = new SecurityCenterImpl();                    break;                &#125;                case BINDER_COMPUTE: &#123;                    // 如果客户端请求计算服务，就创建一个ComputeImpl实例                    binder = new ComputeImpl();                    break;                &#125;                default:                    break;            &#125;            return binder;        &#125;    &#125;&#125;\n\n服务端实现\npublic class BinderPoolService extends Service &#123;    private static final String TAG=&quot;BinderPoolService&quot;;    //这一行代码的作用是创建并持有一个“Binder 管理员”的实例。    //这个实例就是客户端在绑定服务后，第一个也是唯一一个直接交互的对象。    private Binder mBinderPool=new BinderPool.BinderPoolImpl();    @Override    public void onCreate() &#123;        super.onCreate();    &#125;    public BinderPoolService() &#123;    &#125;    @Override    public IBinder onBind(Intent intent) &#123;        Log.d(TAG, &quot;onBind: &quot;);        return mBinderPool;    &#125;    @Override    public void onDestroy() &#123;        super.onDestroy();    &#125;&#125;\n\n\n使用实例\nprivate void doWork()&#123;       // 1. 获取 BinderPool 的单例实例。       BinderPool binderPool=BinderPool.getInstance(this);       // 2. 向远程服务查询用于安全加密的 Binder。       IBinder securityBinder=binderPool.queryBinder(BinderPool.BINDER_SECURITY_CENTER);       //3. 将底层的 IBinder 对象转换为我们定义的 AIDL 接口 ISecurityCenter。        ISecurityCenter mSecurityCenter=(ISecurityCenter) SecurityCenterImpl.asInterface(securityBinder);        //4.使用接口方法       String msg=&quot;Android&quot;;       System.out.println(&quot;content:&quot;+msg);       try &#123;           String password=mSecurityCenter.encrypt(msg);           System.out.println(&quot;encrypt:&quot;+password);           System.out.println(&quot;decrypt:&quot;+mSecurityCenter.decrypt(password));       &#125;catch (RemoteException e)&#123;           e.printStackTrace();       &#125;       Log.d(TAG, &quot;visit ICompute&quot;);       IBinder computeBinder=binderPool.queryBinder(BinderPool.BINDER_COMPUTE);       ICompute mCompute=ComputeImpl.asInterface(computeBinder);       try &#123;           System.out.println(&quot;3+5=&quot;+mCompute.add(3,5));       &#125;catch (RemoteException e)&#123;           e.printStackTrace();       &#125;   &#125;\n\n","categories":["Android进阶"]},{"title":"IPC的优缺点","url":"/posts/IPC%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/","content":"\n","categories":["Android进阶"]},{"title":"Android中的IPC方式","url":"/posts/Android%E4%B8%AD%E7%9A%84IPC%E6%96%B9%E5%BC%8F/","content":"Bundle典型应用场景\n当我们在一个进程中启动了另一进程的Activity，Service和Receiver，我们就可以在Bundle中附加我们需要传输给远程进程的信息并通过Intent发送出去。当然这个数据必须能够被序列化，比如基本数据类型，实现了Parcelable接口的对象，实现了Serializable接口的对象以及一些Android支持的特殊对象。\n特殊使用场景\n比如A进程正在进行一个计算，计算完成后它要启动B进程的一个组件并把计算结果传递给B进程，可是遗憾的是此结果不支持放入Bundle中。这个时候可以使用如下方法：\n通过Intent启动进程B的一个Service组件（比如IntentService），让Service在后台进行计算，计算完毕后再启动B进程中的目标组件，由于Service也在B进程中，所以目标组件可以直接获得计算结果。\n\n使用文件共享概括：两个进程通过读写同一个文件来交换数据\n过程：\n\n将数据序列化到文件中\nprivate void persistToFile()&#123;       new Thread(new Runnable() &#123;           @Override           public void run() &#123;               File baseDir=getBaseContext().getFilesDir();               User user=new User(false,1,&quot;hello world&quot;);               File dir=new File(baseDir,MyConstants.CHAPTER_2_PATH);               if(!dir.exists())&#123;                   dir.mkdirs();               &#125;               File cachedFile=new File(dir,MyConstants.CACHE_FILE_PATH);               ObjectOutputStream objectOutputStream=null;               try &#123;                   objectOutputStream=new ObjectOutputStream(new FileOutputStream(cachedFile));                   objectOutputStream.writeObject(user);                   Log.d(TAG, &quot;persist user:&quot;+user);               &#125;catch (IOException e)&#123;                   e.printStackTrace();               &#125;finally &#123;                   MyUtils.close(objectOutputStream);               &#125;           &#125;       &#125;).start();   &#125;\n\n\n\n反序列化读取\nprivate void recoverFromFile()&#123;        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                User user=null;                File baseDir=getBaseContext().getFilesDir();                File dir = new File(baseDir, MyConstants.CHAPTER_2_PATH);                File cacheFile=new File(dir,MyConstants.CACHE_FILE_PATH);                if(cacheFile.exists())&#123;                    ObjectInputStream objectInputStream=null;                    try &#123;                        objectInputStream =new ObjectInputStream(                                new FileInputStream(cacheFile)                        );                        user=(User) objectInputStream.readObject();                        Log.d(TAG, &quot;recover user:&quot;+user);                    &#125;catch ( IOException e)&#123;                        e.printStackTrace();                    &#125;catch (ClassNotFoundException e)&#123;                        e.printStackTrace();                    &#125;finally &#123;                        MyUtils.close(objectInputStream);                    &#125;                &#125;            &#125;        &#125;).start();    &#125;\n\n局限性：受并发读&#x2F;写的影响，故此方法适合对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写的问题\n\n\n\nMessenger\n服务端进程\n首先需要创建一个Service来处理连接请求，同时创建一个Handle并通过它来创建一个Messener对象，然后在Service的onBind中返回这个Messenger对象底层的Binder即可。\npublic class MessengerService extends Service &#123;    private static final String TAG = &quot;MessengerService&quot; ;    public MessengerService() &#123;    &#125;private static class MessengerHandler extends Handler&#123;    @Override    public void handleMessage(@NonNull Message msg) &#123;        switch (msg.what)&#123;            case MyConstants.MSG_FROM_CLIENT:                Log.i(TAG, &quot;receive msg from Client:&quot;+msg.getData().getString(&quot;msg&quot;));                //为了实现回复客户端的功能新增代码                Messenger client=msg.replyTo;                Message replyMessage=Message.obtain(null,MyConstants.MSG_FROM_SERVICE);                Bundle bundle=new Bundle();                bundle.putString(&quot;reply&quot;,&quot;嗯，我已经收到了&quot;);                replyMessage.setData(bundle);                try&#123;                    client.send(replyMessage);                &#125;catch (RemoteException e)&#123;                    e.printStackTrace();                &#125;                break;            default:                super.handleMessage(msg);        &#125;    &#125;&#125;private final Messenger mMessenger=new Messenger(new MessengerHandler());    @Override    public IBinder onBind(Intent intent) &#123;     return mMessenger.getBinder();    &#125;&#125;\n\n让service运行在单独的进程中\n\n客户端进程\n首先要绑定服务端的service，绑定成功后用服务端返回的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送消息了，发消息类型为Message对象。如果需要服务端可以回应客户端，就和服务端一样，我们需要创建一个Handle并通过它来创建一个Messener对象，并把这个Messenger对象通过Message的replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端\npublic class MessengerActivity extends AppCompatActivity &#123;    private static final String TAG=&quot;MessengerActivity&quot;;    private Messenger mService;    private ServiceConnection mConnection=new ServiceConnection() &#123;        @Override        public void onServiceConnected(ComponentName name, IBinder service) &#123;            mService=new Messenger(service);            Message msg= Message.obtain(null,MyConstants.MSG_FROM_CLIENT);             Bundle data=new Bundle();             data.putString(&quot;msg&quot;,&quot;hello , this is client&quot;);             msg.setData(data);            //注意下面这句话            msg.replyTo=mGetReplyMessenger;             try &#123;                 mService.send(msg);             &#125;catch (RemoteException e)&#123;                 e.printStackTrace();             &#125;        &#125;        @Override        public void onServiceDisconnected(ComponentName name) &#123;        &#125;    &#125;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_messenger);        Intent intent=new Intent(this,MessengerService.class);        bindService(intent,mConnection, Context.BIND_AUTO_CREATE);    &#125;    @Override    protected void onDestroy() &#123;        unbindService(mConnection);        super.onDestroy();    &#125;   //为了实现回复客户端的功能新增代码    private Messenger mGetReplyMessenger=new Messenger(new MessengerHandler());    private static class MessengerHandler extends Handler&#123;        @Override        public void handleMessage(@NonNull Message msg) &#123;            switch (msg.what)&#123;                case MyConstants.MSG_FROM_SERVICE:                    Log.i(TAG, &quot;receive msg from Service:&quot;+msg.getData().getString(&quot;reply&quot;));                    break;                default:                    super.handleMessage(msg);            &#125;        &#125;    &#125;&#125;\n\n\n工作原理示意图\n\n\n\n\n\n.\n\nAIDL\nAIDL文件支持的数据类型\n\n基本数据类型(int,long,char,boolean,double等)\nString和CharSequence\nList：只支持ArrayList，里面每个元素都能被AIDL支持\nMap：只支持HashMap，里面每个元素都能被AIDL支持，包括key和value\nParcelable:所有实现了Parcelable接口的对象\nAIDL：所有AIDL接口本身也可以在AIDL文件中使用\n\n\n注意事项\n\n自定义的Parcelable对象和AIDL对象必须要显式的import进来\n如果AIDL文件用到了自定义的Parcelable对象，那么必须新建一个与他同名的AIDL文件，并在其中声明他是Parcelable类型\nAIDL中除了基本数据类型，其他类型的参数都必须标上方向：in，out和inout，in表示输入型参数，out表示输出型参数，inout表示输入输出型参数\nAIDL接口中只支持方法，不支持声明静态常量，这一点区别于传统的接口,\n\n\n实现当有新书时把信息告知给用户的功能\n\n新建AIDL接口，让服务端能够主动通知客户端\n//导入自定义的数据类型。import com.example.ipctest.Book;interface IOnNewBookArrivedListener &#123;    //in是从调用方指向被调用法，out相反    void onNewBookArrived(in Book newBook);&#125;\n\n\n\n在原来的AIDL接口中添加两个新方法\n//导入自定义的数据类型。import com.example.ipctest.Book;import com.example.ipctest.IOnNewBookArrivedListener;interface IBookManager &#123;        List&lt;Book&gt; getBookList();        void addBook(in Book book);    //新增        void registerListener(IOnNewBookArrivedListener listener);        void unregisterListener(IOnNewBookArrivedListener listener);&#125;\n\n\n\n服务端\npublic class BookManagerService extends Service &#123;    private static final String TAG = &quot;BMS&quot;;    //作为一个线程安全的标志位（flag），用来记录 Service 是否已经被销毁。可以在多线程中启用    private AtomicBoolean mIsServiceDestoryed = new AtomicBoolean(false);    private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;Book&gt;();    private RemoteCallbackList&lt;IOnNewBookArrivedListener&gt; mListenerList = new RemoteCallbackList&lt;IOnNewBookArrivedListener&gt;();    private Binder mBinder = new IBookManager.Stub() &#123;        @Override        public List&lt;Book&gt; getBookList() throws RemoteException &#123;            return mBookList;        &#125;        @Override        public void addBook(Book book) throws RemoteException &#123;            mBookList.add(book);        &#125;        @Override        public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException &#123;            // 直接调用 register 方法即可。            // 它内部会自动处理重复注册的情况，所以你不需要手动检查 contains。            mListenerList.register(listener);            Log.d(TAG, &quot;registerListener complete.&quot;);            // beginBroadcast() 会返回当前有效的监听器数量            int N = mListenerList.beginBroadcast();            mListenerList.finishBroadcast();            Log.d(TAG, &quot;current listener size: &quot; + N);        &#125;        @Override        public void unregisterListener(IOnNewBookArrivedListener listener) throws RemoteException &#123;            // unregister() 方法会返回一个 boolean 值，表示是否成功移除了监听器。            // 这个方法是原子操作，并且能正确处理 Binder 对象。            boolean success = mListenerList.unregister(listener);            if (success) &#123;                Log.d(TAG, &quot;unregister listener succeed.&quot;);            &#125; else &#123;                Log.d(TAG, &quot;not found, can not unregister.&quot;);            &#125;            // 获取当前有效监听器数量的正确方式            final int N = mListenerList.beginBroadcast();            mListenerList.finishBroadcast();            Log.d(TAG, &quot;unregisterListener, current size: &quot; + N);        &#125;    &#125;;        @Override        public void onCreate() &#123;            super.onCreate();            mBookList.add(new Book(1, &quot;Android&quot;));            mBookList.add(new Book(2, &quot;Ios&quot;));            new Thread(new ServiceWorker()).start();        &#125;        @Override        public IBinder onBind(Intent intent) &#123;            return mBinder;        &#125;        @Override        public void onDestroy() &#123;           // 通知后台线程停止工作            mIsServiceDestoryed.set(true);            super.onDestroy();        &#125;    private void onNewBookArrived(Book book) &#123;        // 1. 先将书加入列表        mBookList.add(book);        Log.d(TAG, &quot;New book added: &quot; + book + &quot;. Notifying listeners...&quot;);        // 2. 开始广播，获取有效监听器数量        final int N = mListenerList.beginBroadcast();        try &#123;            // 3. 在 beginBroadcast 和 finishBroadcast 之间遍历并通知            for (int i = 0; i &lt; N; i++) &#123;                IOnNewBookArrivedListener listener = mListenerList.getBroadcastItem(i);                if (listener != null) &#123;                    try &#123;                        Log.d(TAG, &quot;Notifying listener: &quot; + listener);                        // 调用客户端的回调方法                        listener.onNewBookArrived(book);                    &#125; catch (RemoteException e) &#123;                        // 某个客户端可能在调用期间死亡或发生其他远程错误                        // RemoteCallbackList 会在下次 beginBroadcast 时自动清理它                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125; finally &#123;            // 4. 确保在任何情况下都结束广播（即使循环中发生异常）            mListenerList.finishBroadcast();        &#125;    &#125;        private class ServiceWorker implements Runnable &#123;            @Override            public void run() &#123;                while (!mIsServiceDestoryed.get()) &#123;                    try &#123;                        Thread.sleep(5000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    int bookId=mBookList.size()+1;                    Book newBook = new Book(bookId, &quot;new book#&quot; + bookId);                    onNewBookArrived(newBook);                &#125;            &#125;        &#125;    &#125;public class BookManagerService extends Service &#123;    private static final String TAG=&quot;BMS&quot;;    private AtomicBoolean mIsServiceDestoryed=new AtomicBoolean(false);    private CopyOnWriteArrayList&lt;Book&gt; mBookList=new CopyOnWriteArrayList&lt;Book&gt;();    private     CopyOnWriteArrayList&lt;IOnNewBookArrivedListener&gt; mListenerList=new CopyOnWriteArrayList&lt;IOnNewBookArrivedListener&gt;();    private Binder mBinder=new IBookManager.Stub() &#123;        @Override        public List&lt;Book&gt; getBookList() throws RemoteException &#123;            return mBookList;        &#125;        @Override        public void addBook(Book book) throws RemoteException &#123;    mBookList.add(book);        &#125;        @Override        public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException &#123;            if(!mListenerList.contains(listener))&#123;                mListenerList.add(listener);            &#125;else &#123;                Log.d(TAG, &quot;already exists&quot;);            &#125;            Log.d(TAG, &quot;registerListener,size:&quot;+mListenerList.size());        &#125;        @Override        public void unregisterListener(IOnNewBookArrivedListener listener) throws RemoteException &#123;                    if(mListenerList.contains(listener))&#123;                        mListenerList.remove(listener);                        Log.d(TAG, &quot;unregister listener succeed.&quot;);                    &#125;else &#123;                        Log.d(TAG, &quot;not found,can not unregister.&quot;);                    &#125;            Log.d(TAG, &quot;unregisterListener:,current size:&quot;+mListenerList.size());        &#125;    &#125;;    @Override    public void onCreate() &#123;        super.onCreate();        mBookList.add(new Book(1,&quot;Android&quot;));        mBookList.add(new Book(2,&quot;Ios&quot;));        new Thread(new ServiceWorker()).start();    &#125;    @Override    public IBinder onBind(Intent intent) &#123;        return mBinder;    &#125;    @Override    public void onDestroy() &#123;        mIsServiceDestoryed.set(true);        super.onDestroy();    &#125;    private void onNewBookArrived(Book book) throws RemoteException&#123;        mBookList.add(book);        Log.d(TAG, &quot;onNewBookArrived,notify listeners:&quot;+mListenerList.size());        for(int i=0;i&lt;mListenerList.size();i++)&#123;            IOnNewBookArrivedListener listener=mListenerList.get(i);            Log.d(TAG, &quot;onNewBookArrived,notify listeners:&quot;+listener);            listener.onNewBookArrived(book);        &#125;    &#125;    private class ServiceWorker implements Runnable&#123;        @Override        public void run() &#123;            while(!mIsServiceDestoryed.get())&#123;                try&#123;                    Thread.sleep(5000);                &#125;catch (InterruptedException e)&#123;                    e.printStackTrace();                &#125;                int bookId=mBookList.size()+1;                Book newBook=new Book(bookId,&quot;new book#&quot;+bookId);                try &#123;                    onNewBookArrived(newBook);                &#125;catch (RemoteException e)&#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;\n\n\n\n客户端\npublic class BookManagerActivity extends AppCompatActivity &#123;private static final String TAG=&quot;BookManagerActivity&quot;;private static final int MESSAGE_NEW_BOOK_ARRIVED=1;private IBookManager mRemoteBookManager;@SuppressLint(&quot;HandlerLeak&quot;)private Handler mHandler=new Handler()&#123;    @Override    public void handleMessage(@NonNull Message msg) &#123;        switch (msg.what)&#123;            case MESSAGE_NEW_BOOK_ARRIVED:                Log.d(TAG, &quot;received new book:&quot;+msg.obj);                break;            default:                super.handleMessage(msg);        &#125;    &#125;&#125;;private ServiceConnection mConnection=new ServiceConnection() &#123;    @Override    public void onServiceConnected(ComponentName name, IBinder service) &#123;        IBookManager bookManager=IBookManager.Stub.asInterface(service);        try &#123;            mRemoteBookManager=bookManager;            List&lt;Book&gt; list=bookManager.getBookList();            Log.i(TAG, &quot;query book list,list type:&quot;+list.getClass().getCanonicalName());            Log.i(TAG, &quot;query book list：&quot;+list.toString());            Book newBook=new Book(3,&quot;Android开发艺术探索&quot;);            bookManager.addBook(newBook);            Log.i(TAG, &quot;add book: &quot;+newBook);            List&lt;Book&gt;newList=bookManager.getBookList();            Log.i(TAG, &quot;query book list: &quot;+newList.toString());            bookManager.registerListener(mOnNewBookArrivedListener);        &#125;catch (RemoteException e)&#123;            e.printStackTrace();        &#125;    &#125;    @Override    public void onServiceDisconnected(ComponentName name) &#123;mRemoteBookManager=null;        Log.e(TAG, &quot;binder died&quot; );    &#125;&#125;;private IOnNewBookArrivedListener mOnNewBookArrivedListener=new IOnNewBookArrivedListener.Stub() &#123;    @Override    public void onNewBookArrived(Book newBook) throws RemoteException &#123;        mHandler.obtainMessage(MESSAGE_NEW_BOOK_ARRIVED,newBook).sendToTarget();    &#125;&#125;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Intent intent=new Intent(this,BookManagerService.class);        bindService(intent,mConnection, Context.BIND_AUTO_CREATE);    &#125;    @Override    protected void onDestroy() &#123;        if(mRemoteBookManager!=null&amp;&amp;mRemoteBookManager.asBinder().isBinderAlive())&#123;            try &#123;                Log.i(TAG, &quot;unregister listener:&quot;+mOnNewBookArrivedListener);                mRemoteBookManager.unregisterListener(mOnNewBookArrivedListener);            &#125;catch (RemoteException e)&#123;                e.printStackTrace();            &#125;        &#125;        unbindService(mConnection);        super.onDestroy();    &#125;&#125;\n\n\nRemoteCallbackList专为AIDL设计的方法\n//是系统专门提供的用于删除跨进程listener的接口 //自我清理：最核心功能。自动移除已死亡客户端的监听器，防止内存泄漏和异常。//专用性：只用于 AIDL 跨进程回调，不是一个通用的 List。//线程安全：所有操作（注册、注销、遍历）都是为多线程环境设计的。//广播式遍历：必须使用 beginBroadcast/finishBroadcast 的固定模式来安全地通知所有监听器。\n\n\n给服务加上权限验证的功能\n\n在onBind中进行验证\n\npermission方法验证\n&lt;permission android:name=&quot;com.example.ipctest.permission.ACCESS_BOOK_SERVICE&quot;        android:protectionLevel=&quot;normal&quot;/&gt;\n\n@Override        public IBinder onBind(Intent intent) &#123;                    int         check=checkCallingOrSelfPermission(&quot;com.example.ipctest.permission.ACCESS_BOOK_SERVICE&quot;);            if(check== PackageManager.PERMISSION_DENIED)&#123;                return null;            &#125;            return mBinder;        &#125;\n\n如果内部应用想绑定这个服务\n&lt;user-permission android:name=&quot;com.example.ipctest.permission.ACCESS_BOOK_SERVICE&quot;/&gt;\n\n\n在服务端的onTransact进行权限验证\n@Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;    int check=checkCallingOrSelfPermission(&quot;com.example.ipctest.permission.ACCESS_BOOK_SERVICE&quot;);    if(check==PackageManager.PERMISSION_DENIED)&#123;        return false;    &#125;    String packageName=null;    String[] packages=getPackageManager().getPackagesForUid(getCallingUid());    if(packages!=null&amp;&amp;packages.length&gt;0)&#123;        packageName=packages[0];    &#125;    if(!packageName.startsWith(&quot;com.example&quot;))&#123;        return false;    &#125;    return super.onTransact(code, data, reply, flags);&#125;\n\n\n\n\nContentProvider\n创建一个数据库\npublic class DbOpenHelper extends SQLiteOpenHelper &#123;    private static final String DB_NAME=&quot;book_provider.db&quot;;    public static final String BOOK_TABLE_NAME=&quot;book&quot;;    public static final String USER_TABLE_NAME=&quot;user&quot;;    private static final int DB_VERSION=1;    private static final String CREATE_BOOK_TABLE = &quot;create table book(&quot;            + &quot;id integer primary key, &quot;            + &quot;name text)&quot;;    private static final String CREATE_USER_TABLE=&quot;create table user(&quot;            +&quot;id integer primary key,&quot;            +&quot;name text,&quot;            +&quot;sex int)&quot;;    public DbOpenHelper(@Nullable Context context) &#123;        super(context,DB_NAME,null,DB_VERSION);    &#125;    @Override    public void onCreate(SQLiteDatabase db) &#123;db.execSQL(CREATE_BOOK_TABLE);db.execSQL(CREATE_USER_TABLE);    &#125;    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;    &#125;&#125;\n\n\n\n\n\n创建一个ContentProvider，并注册\npublic class BookProvider extends ContentProvider &#123;    private static final String TAG=&quot;BookProvider&quot;;    private static final String AUTHORITY=&quot;com.example.contentprovider.book.provider&quot;;    public static final Uri BOOK_CONTENT_URI=Uri.parse(&quot;content://&quot;+AUTHORITY+&quot;/book&quot;);    public static final Uri USER_CONTENT_URI=Uri.parse(&quot;content://&quot;+AUTHORITY+&quot;/user&quot;);    public static final int BOOK_URI_CODE=0;    public static final int USER_URI_CODE=1;    private static final UriMatcher sUriMatcher=new UriMatcher(UriMatcher.NO_MATCH);    static &#123;        sUriMatcher.addURI(AUTHORITY,&quot;book&quot;,BOOK_URI_CODE);        sUriMatcher.addURI(AUTHORITY,&quot;user&quot;,USER_URI_CODE);    &#125;    private SQLiteDatabase db;    private String getTableName(Uri uri)&#123;        String tableName=null;        switch (sUriMatcher.match(uri))&#123;            case  BOOK_URI_CODE:                tableName=DbOpenHelper.BOOK_TABLE_NAME;                break;            case USER_URI_CODE:                tableName=DbOpenHelper.USER_TABLE_NAME;                break;            default:break;        &#125;        return tableName;    &#125;    @Override    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) &#123;        Log.d(TAG, &quot;delete: &quot;);        String table=getTableName(uri);        if (table==null)&#123;            throw new IllegalArgumentException(&quot;Unsupported URI:&quot;+uri);        &#125;        int count=db.delete(table,selection,selectionArgs);        if(count&gt;0)&#123;            getContext().getContentResolver().notifyChange(uri,null);        &#125;        return count;    &#125;    @Nullable    @Override    public String getType(@NonNull Uri uri) &#123;        Log.d(TAG, &quot;getType:&quot;);        return null;    &#125;    @Nullable    @Override    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) &#123;        Log.d(TAG, &quot;insert: &quot;);        String table=getTableName(uri);        if (table==null)&#123;            throw new IllegalArgumentException(&quot;Unsupported URI:&quot;+uri);        &#125;        db.insert(table,null,values);        getContext().getContentResolver().notifyChange(uri,null);        return uri;    &#125;    @Override    public boolean onCreate() &#123;        DbOpenHelper dbOpenHelper=new DbOpenHelper(getContext());        db=dbOpenHelper.getWritableDatabase();        //初始化数据库，这里仅用作演示，实际操作中不推荐在主线程执行耗时操作        initProviderData();        Log.d(TAG, &quot;onCreate:,current thread:&quot;+Thread.currentThread().getName());        return true;    &#125;    private void initProviderData()&#123;        db.execSQL(&quot;delete from &quot;+DbOpenHelper.BOOK_TABLE_NAME);        db.execSQL(&quot;delete from &quot;+DbOpenHelper.USER_TABLE_NAME);        db.execSQL(&quot;insert into book values(3,&#x27;Android&#x27;);&quot;);        db.execSQL(&quot;insert into book values(4,&#x27;Ios&#x27;);&quot;);        db.execSQL(&quot;insert into book values(5,&#x27;Html5&#x27;);&quot;);        db.execSQL(&quot;insert into user values(1,&#x27;jake&#x27;,1);&quot;);        db.execSQL(&quot;insert into user values(2,&#x27;jasmine&#x27;,0);&quot;);    &#125;    @Nullable    @Override    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123;        Log.d(TAG, &quot;onCreate:,current thread:&quot;+Thread.currentThread().getName());        String table=getTableName(uri);        if(table==null)&#123;            throw new IllegalArgumentException(&quot;Unsupported URI:&quot;+uri);        &#125;        return db.query(table,projection,selection,selectionArgs,null,null,sortOrder,null);    &#125;    @Override    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) &#123;        Log.d(TAG, &quot;update: &quot;);        String table=getTableName(uri);        if(table==null)&#123;            throw new IllegalArgumentException(&quot;Unsupported URI:&quot;+uri);        &#125;        int row=db.update(table,values,selection,selectionArgs);        if(row&gt;0)&#123;            getContext().getContentResolver().notifyChange(uri,null);        &#125;        return row;    &#125;&#125;\n\n&lt;provider           android:name=&quot;.BookProvider&quot;           android:authorities=&quot;com.example.contentprovider.book.provider&quot;           android:permission=&quot;com.example.PROVIDER&quot;           android:process=&quot;:provider&quot;           &gt;       &lt;/provider&gt;\n\n应用到Activity中\npublic class MainActivity extends AppCompatActivity &#123;    private static final String TAG=&quot;MainActivity&quot;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Uri uri=Uri.parse(&quot;content://com.example.contentprovider.book.provider&quot;);        Uri bookUri=Uri.parse(&quot;content://com.example.contentprovider.book.provider/book&quot;);        ContentValues values=new ContentValues();        values.put(&quot;id&quot;,6);        values.put(&quot;name&quot;,&quot;程序设计的艺术&quot;);        getContentResolver().insert(bookUri,values);        Cursor bookCursor=getContentResolver().query(bookUri,new String[]&#123;&quot;id&quot;,&quot;name&quot;&#125;,null,null,null);        while(bookCursor.moveToNext())&#123;            Book book=new Book();            book.bookId=bookCursor.getInt(0);            book.bookName=bookCursor.getString(1);            Log.d(TAG, &quot;query book:&quot;+book.toString());        &#125;        bookCursor.close();        Uri userUri=Uri.parse(&quot;content://com.example.contentprovider.book.provider/user&quot;);        Cursor userCursor=getContentResolver().query(userUri,new String[]&#123;&quot;id&quot;,&quot;name&quot;,&quot;sex&quot;&#125;,null,null,null);        while(userCursor.moveToNext())&#123;            User user=new User();            user.userId=userCursor.getInt(0);            user.userName=userCursor.getString(1);            user.isMale=userCursor.getInt(2)==1;            Log.d(TAG, &quot;query user:&quot;+user.toString());        &#125;        userCursor.close();    &#125;&#125;\n\n\nSocket\n服务端\n/** * 一个在后台运行的TCP服务器Service。 * &lt;p&gt; * 这个服务启动后，会在8688端口上监听客户端的TCP连接请求。 * 它能够同时处理多个客户端的连接，并与每个客户端进行简单的随机消息交互。 */public class TCPServerService extends Service &#123;    /**     * 标志位，用于表示Service是否已经被销毁。     * 当Service被销毁时，此标志位会变为true，从而通知所有正在运行的线程优雅地停止。     */    private boolean mIsServiceDestoryed = false;    /**     * 预定义的消息数组，服务器会从中随机选择一条回复给客户端。     */    private String[] mDefinedMessagges = new String[]&#123;            &quot;你好啊，哈哈&quot;,            &quot;请问你叫什么名字呀？&quot;,            &quot;今天北京天气不错呀，shy&quot;,            &quot;你知道吗？我可是可以和多个人同时聊天的哦&quot;,            &quot;给你讲个笑话吧，据说爱笑的人运气不会太差，不知道真假.&quot;    &#125;;    public TCPServerService() &#123;    &#125;    /**     * Service创建时调用，是服务的生命周期入口。     * 在这里，我们启动一个新的线程来运行TCP服务器的核心逻辑。     */    @Override    public void onCreate() &#123;        // 创建一个新的线程来运行TCPServer任务。        // 网络操作属于耗时操作，必须在子线程中进行，否则会阻塞UI主线程，导致ANR（应用无响应）。        new Thread(new TCPServer()).start();        super.onCreate();    &#125;    /**     * 提供绑定服务的接口。     * @return 返回null表示这是一个非绑定的服务（Started Service），不与任何组件进行通信。     */    @Override    public IBinder onBind(Intent intent) &#123;        return null;    &#125;    /**     * Service销毁时调用，是服务的生命周期终点。     * 在这里，我们将mIsServiceDestoryed标志位置为true，通知所有线程停止工作。     */    @Override    public void onDestroy() &#123;        mIsServiceDestoryed = true;        super.onDestroy();    &#125;    /**     * 实现了Runnable接口的内部类，封装了TCP服务器的核心逻辑。     * 这个类的run方法将在一个独立的线程中执行。     */    private class TCPServer implements Runnable &#123;        @Override        public void run() &#123;            ServerSocket serverSocket = null;            try &#123;                // 在本地8688端口上创建并监听ServerSocket。                serverSocket = new ServerSocket(8688);            &#125; catch (IOException e) &#123;                System.err.println(&quot;establish tcp server failed ,port:8688&quot;);                e.printStackTrace();                // 如果端口被占用或创建失败，则直接返回，线程结束。                return;            &#125;            // 进入主循环，只要服务没有被销毁，就一直等待新的客户端连接。            while (!mIsServiceDestoryed) &#123;                try &#123;                    // accept() 是一个阻塞方法，它会一直等待，直到有客户端连接成功。                    // 连接成功后，它会返回一个代表该连接的Socket对象。                    final Socket client = serverSocket.accept();                    System.out.println(&quot;accept a new client&quot;);                    // 【核心】为每一个新的客户端连接都创建一个新的线程去处理。                    // 这样可以实现并发处理多个客户端，主线程可以立刻回去继续等待下一个连接。                    new Thread() &#123;                        @Override                        public void run() &#123;                            try &#123;                                responseClient(client);                            &#125; catch (IOException e) &#123;                                e.printStackTrace();                            &#125;                        &#125;                    &#125;.start();                &#125; catch (IOException e) &#123;                    // 在accept过程中也可能出现IO异常                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    /**     * 处理与单个客户端的所有通信。     * 这个方法会在一个专门为该客户端创建的线程中运行。     *     * @param client 代表与客户端连接的Socket通道。     * @throws IOException 在网络读写时可能会抛出IO异常。     */    private void responseClient(Socket client) throws IOException &#123;        // 用于从客户端读取数据。通过一系列包装，实现高效的按行读取。        BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));        // 用于向客户端发送数据。true参数表示开启自动行刷新，println后消息会立刻发送。        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(client.getOutputStream())), true);        // 首先向客户端发送一条欢迎消息。        out.println(&quot;欢迎来到聊天室！&quot;);        // 进入通信循环，只要服务未被销毁并且客户端未断开连接，就一直持续。        while (!mIsServiceDestoryed) &#123;            // readLine() 是一个阻塞方法，会等待客户端发送一行消息。            String str = in.readLine();            System.out.println(&quot;msg from client:&quot; + str);            // 如果readLine()返回null，表示客户端的Socket已关闭，即连接已断开。            if (str == null) &#123;                // 结束循环，准备关闭资源。                break;            &#125;            // 从预设消息中随机选择一条进行回复。            int i = new Random().nextInt(mDefinedMessagges.length);            String msg = mDefinedMessagges[i];            out.println(msg);            System.out.println(&quot;send to client:&quot; + msg);        &#125;        System.out.println(&quot;client quit.&quot;);        // 【重要】当循环结束时，必须关闭所有资源。        // 先关闭输出流，再关闭输入流，最后关闭Socket。        // 如果不关闭，会造成资源泄漏。        // MyUtils.close是一个自定义的工具方法，用于安全地关闭流。        // 如果没有，可以直接调用 out.close(); in.close();        MyUtils.close(out);        MyUtils.close(in);        client.close();    &#125;&#125;\n\n\n\n客户端\n/** * 这是一个TCP客户端界面 (Activity)。 * 它的功能是连接到后台的TCPServerService，并与之进行消息收发。 */public class TCPClientActivity extends AppCompatActivity implements View.OnClickListener &#123;    // 定义Handler能够识别的消息类型：1 表示收到新消息    private static final int MESSAGE_RECEIVE_NEW_MSG = 1;    // 定义Handler能够识别的消息类型：2 表示Socket连接成功    private static final int MESSAGE_SOCKET_CONNECTED = 2;    // UI控件    private Button mSendButton;    private TextView mMessageTextView;    private EditText mMessageEditText;    // 网络通信相关    private PrintWriter mPrintWriter;// 用于向服务器发送消息    private Socket mClientSocket;// 客户端的Socket    /**     * Handler是Android中用于线程间通信的关键组件。     * 这里的Handler运行在主线程（UI线程）中，它可以接收来自任何子线程的消息，     * 然后安全地在主线程中更新UI界面。子线程绝对不能直接操作UI！     */    @SuppressLint(&quot;HandlerLeak&quot;)    private Handler handler = new Handler() &#123;        @Override        public void handleMessage(@NonNull Message msg) &#123;            // 根据收到的消息类型(msg.what)来执行不同的操作            switch (msg.what) &#123;                case MESSAGE_RECEIVE_NEW_MSG: &#123;                    // 如果是“收到新消息”，就把消息内容(msg.obj)追加到TextView上                    mMessageTextView.append((String) msg.obj);                    break;                &#125;                case MESSAGE_SOCKET_CONNECTED: &#123;                    // 如果是“连接成功”，就把发送按钮变为可用状态                    mSendButton.setEnabled(true);                    break;                &#125;                default:                    break;            &#125;        &#125;    &#125;;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        // 加载布局文件        setContentView(R.layout.activity_main);        // 初始化UI控件        mMessageTextView = (TextView) findViewById(R.id.textView);        mSendButton = (Button) findViewById(R.id.send);        mSendButton.setOnClickListener(this); // 设置按钮的点击监听器        mMessageEditText = (EditText) findViewById(R.id.editText);        // 启动后台TCP服务器服务        Intent service = new Intent(this, TCPServerService.class);        startService(service);        // 开启一个新的子线程来执行网络连接操作        // 因为连接服务器是耗时操作，必须在子线程中进行，防止UI卡顿        new Thread() &#123;            @Override            public void run() &#123;                connectTCPServer();            &#125;        &#125;.start();    &#125;    /**     * Activity被销毁时调用。     * 在这里我们需要关闭Socket连接，释放资源。     */    @Override    protected void onDestroy() &#123;        if (mClientSocket != null) &#123;            try &#123;                // 关闭Socket的输入流和连接                mClientSocket.shutdownInput();                mClientSocket.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        super.onDestroy();    &#125;    /**     * 处理按钮点击事件。     */    @Override    public void onClick(View v) &#123;        if (v == mSendButton) &#123;            final String msg = mMessageEditText.getText().toString();            // 确保消息不为空，并且网络连接已准备好            if (!TextUtils.isEmpty(msg) &amp;&amp; mPrintWriter != null) &#123;                // 【关键】发送消息是网络操作，必须在子线程中进行，否则会闪退                new Thread(new Runnable() &#123;                    @Override                    public void run() &#123;                        mPrintWriter.println(msg);                    &#125;                &#125;).start();                // 【关键】更新UI的操作（清空输入框、显示自己发送的消息）必须在主线程进行                mMessageEditText.setText(&quot;&quot;);                String time = formateDataTime(System.currentTimeMillis());                final String showedMsg = &quot;self &quot; + time + &quot;:&quot; + msg + &quot;\\n&quot;;                mMessageTextView.append(showedMsg);            &#125;        &#125;    &#125;    /**     * 一个简单的时间格式化工具方法     */    @SuppressLint(&quot;SimpleDateFormat&quot;)    private String formateDataTime(long time) &#123;        return new SimpleDateFormat(&quot;(HH:mm:ss)&quot;).format(new Date(time));    &#125;    /**     * 连接到TCP服务器的核心方法。     * 这个方法会在一个子线程中被调用。     */    private void connectTCPServer() &#123;        Socket socket = null;        // 使用循环来尝试连接服务器，直到连接成功为止        // 这样可以防止客户端比服务器先启动而导致连接失败        while (socket == null) &#123;            try &#123;                // 尝试连接本地（模拟器/真机自身）的8688端口                socket = new Socket(&quot;localhost&quot;, 8688);                mClientSocket = socket;                // 创建PrintWriter，用于向服务器发送消息                mPrintWriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())), true);                // 连接成功后，通过Handler向主线程发送“连接成功”的消息                handler.sendEmptyMessage(MESSAGE_SOCKET_CONNECTED);                System.out.println(&quot;connect server success&quot;);            &#125; catch (IOException e) &#123;                // 如果连接失败，则等待1秒后重试                SystemClock.sleep(1000);                System.out.println(&quot;connect tcp server failed, retry...&quot;);            &#125;        &#125;        try &#123;            // 连接成功后，准备接收服务器端的消息            BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));            // 只要Activity没有被关闭，就一直循环读取服务器消息            while (!TCPClientActivity.this.isFinishing()) &#123;                // readLine()是一个阻塞方法，会一直等待直到读取到一行消息                String msg = br.readLine();                System.out.println(&quot;receive :&quot; + msg);                if (msg != null) &#123;                    // 收到消息后，格式化一下                    String time = formateDataTime(System.currentTimeMillis());                    final String showedMsg = &quot;server &quot; + time + &quot;:&quot; + msg + &quot;\\n&quot;;                    // 通过Handler把收到的消息发送给主线程，让主线程去更新UI                    handler.obtainMessage(MESSAGE_RECEIVE_NEW_MSG, showedMsg).sendToTarget();                &#125;            &#125;            // 退出循环后，说明Activity要关闭了，清理资源            System.out.println(&quot;quit...&quot;);            MyUtils.close(mPrintWriter);            MyUtils.close(br);            socket.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n","categories":["Android进阶"]},{"title":"IPC基础概念","url":"/posts/IPC%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","content":"Serializable接口Serializable接口的实现\npublic class User implements Serializable &#123;    private static final long serialVersionUID=519067123721295773L;//辅助序列化和反序列化过程    public int userId;    public String userName;    public boolean isMale; &#125;\n\n序列化和反序列化的实现\n//序列化过程User user=new User(0,&quot;jack&quot;,true);// 1. 创建一个User对象ObjectOutputStream out=new ObjectOutputStream(// 2. 创建一个对象输出流    new FileOutputStream(&quot;cache.txt&quot;)//它包裹了一个文件输入流，指向 &quot;cache.txt&quot;);out.writeObject(user);// 3. 将user对象写入文件out.close();// 4. 关闭流//反序列化ObjectInputStream in=new ObjectInputStream(  // 1. 创建一个对象输入流new FileOutputStream(&quot;cache.txt&quot;))；//它包裹了一个文件输出流，读取 &quot;cache.txt&quot;User user=(User) in.readObject();// 2. 从文件中读取对象，并强制类型转换为Userin.close();// 3. 关闭流\n\nserialVersionUID作用\n\n序列化时：当一个 User 对象被序列化时（比如写入文件），Java运行时环境会把这个 serialVersionUID 的值也一并写入到字节流中。\n反序列化时：当程序试图从文件中读取字节流并将其反序列化成一个 User 对象时，Java运行时环境会进行一个关键的检查：\n\n\n它会比较文件中的 serialVersionUID 和当前JVM中加载的 User.class 文件计算出的 serialVersionUID 是否一致。\n如果两者一致，就认为版本是兼容的，反序列化过程继续，对象被成功创建。\n如果两者不一致，JVM会认为“你拿旧版本的说明书来组装新版本的零件，可能会出问题”，于是直接抛出 InvalidClassException 异常，反序列化失败。\n\n显示设定这个值就相当于你给这个类贴上了一个永久性的、写死的“版本标签”，减少反序列化失败的可能\nParcelable接口用法实例\npublic class User implements Parcelable &#123;    //基本字段    public int userId;    public String userName;    public boolean isMale;    //另一个实现了Parcelable接口的对象    public Book book;    public User(boolean isMale, int userId, String userName) &#123;        this.isMale = isMale;        this.userId = userId;        this.userName = userName;    &#125;\t//这个方法在绝大多数情况下直接返回 0 即可，不需要关心它。它仅在对象中包含特殊类型的数据（如文件描述符）时才返回1。    @Override    public int describeContents() &#123;        return 0;    &#125;\t//序列化过程    @Override    public void writeToParcel(Parcel out, int flags)&#123;        out.writeInt(userId);        out.writeString(userName);        //没有写入布尔值的方法所以将true转化为1存入，false转为0        out.writeInt(isMale?1:0);        //写入另一个 Parcelable 对象        out.writeParcelable(book, 0);    &#125;    //反序列化    //反序列化入口    public static final Parcelable.Creator&lt;User&gt; CREATOR=new Parcelable.Creator&lt;User&gt;()&#123;        @Override        public User createFromParcel(Parcel in) &#123;            return new User(in);        &#125;        @Override        public User[] newArray(int size) &#123;            return new User[size];        &#125;    &#125;;    //反序列化执行的地方    //读取顺序: 这里最关键的一点是，读取数据的顺序必须和 writeToParcel 方法中写入的顺序完全一致！ 这是 Parcelable 最容易出错的地方。    private User(Parcel in)&#123;        userId=in.readInt();        userName=in.readString();        isMale=in.readInt()==1;        book=in.readParcelable(Thread.currentThread().getContextClassLoader());    &#125;&#125;\n\nParcelable方法说明\n\nSerializable和Parcelable的选取\nSerializable是Java中的序列化接口，其使用起来简单但开销很大，序列化和反序列化过程需要大量的I&#x2F;O操作。而Parcelable是Android中的序列化方式，因此更适合Android平台，他的缺点就是使用起来麻烦一些，但效率很高，这是Android推荐的序列化方式。Parcelable主要用在内存序列化上，将对象序列化到存储设备中或者将对象序列化后通过网络传输这两种情况推荐使用Serializable。\nBinder方法一\n使用AIDL文件，SDK自动生成Binder类\n\n首先一定要在build.gradle.kts中声明\nbuildFeatures &#123;       aidl=true   &#125;\n\n接下来正常操作\n\n\n\n方法二\n自己创建Binder类\n\n声明一个aidl性质的接口，继承IInterface接口\npublic interface IBookManager extends IInterface &#123;    static final String DESCRIPTOR=&quot;com.example.ipctest.IBookManager&quot;;    static final int TRANSACTION_getBookList= IBinder.FIRST_CALL_TRANSACTION+0;    static final int TRANSACTION_addBook= IBinder.FIRST_CALL_TRANSACTION+1;    public List&lt;Book&gt; getBookList() throws RemoteException;    public void addBook(Book book) throws RemoteException;&#125;\n\n实现Stub类和Stub类中的Proxy代理类\npublic class BookManagerImpl extends Binder implements IBookManager &#123;    public BookManagerImpl()&#123;        this.attachInterface(this,DESCRIPTOR);    &#125;    public static IBookManager asInterface(IBinder obj)&#123;        if((obj==null))&#123;            return null;        &#125;        IInterface iin=obj.queryLocalInterface(DESCRIPTOR);        if(((iin!=null)&amp;&amp;(iin instanceof  IBookManager)))&#123;            return ((IBookManager) iin);        &#125;        return new BookManagerImpl.Proxy(obj);    &#125;    @Override    public IBinder asBinder() &#123;        return this;    &#125;    @Override    protected boolean onTransact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException &#123;        switch (code)&#123;            case INTERFACE_TRANSACTION:&#123;                reply.writeString(DESCRIPTOR);                return true;            &#125;            case TRANSACTION_getBookList:&#123;                data.enforceInterface(DESCRIPTOR);                List&lt;Book&gt; result=this.getBookList();                reply.writeNoException();                reply.writeTypedList(result);                return true;            &#125;            case TRANSACTION_addBook:&#123;                data.enforceInterface(DESCRIPTOR);                Book arg0;                if((0!=data.readInt()))&#123;                    arg0=Book.CREATOR.createFromParcel(data);                &#125;else &#123;                    arg0=null;                &#125;                this.addBook(arg0);                reply.writeNoException();                return true;            &#125;        &#125;        return super.onTransact(code, data, reply, flags);    &#125;    @Override    public List&lt;Book&gt; getBookList() throws RemoteException &#123;        //TODO待实现        return null;    &#125;    @Override    public void addBook(Book book) throws RemoteException &#123;        //TODO待实现    &#125;    private static class Proxy implements IBookManager&#123;        private IBinder mRemote;        Proxy (IBinder remote)&#123;            mRemote=remote;        &#125;        @Override        public IBinder asBinder() &#123;            return mRemote;        &#125;        public java.lang.String getInterfaceDescriptor()&#123;            return DESCRIPTOR;        &#125;        @Override        public List&lt;Book&gt; getBookList() throws RemoteException &#123;            Parcel data =Parcel.obtain();            Parcel reply = Parcel.obtain();            List&lt;Book&gt; result;            try&#123;                data.writeInterfaceToken(DESCRIPTOR);                mRemote.transact(TRANSACTION_getBookList,data,reply,0);                reply.readException();                result=reply.createTypedArrayList(Book.CREATOR);            &#125;finally &#123;                reply.recycle();                data.recycle();            &#125;            return result;        &#125;        @Override        public void addBook(Book book) throws RemoteException &#123;            Parcel data =Parcel.obtain();            Parcel reply = Parcel.obtain();           try&#123;               data.writeInterfaceToken(DESCRIPTOR);               if((book!=null))&#123;                   data.writeInt(1);                   book.writeToParcel(data,0);               &#125;else &#123;                   data.writeInt(0);               &#125;               mRemote.transact(TRANSACTION_addBook,data,reply,0);               reply.readException();           &#125;finally &#123;               reply.recycle();               data.recycle();           &#125;           &#125;    &#125;&#125;\n\n名词解释\n\nDESCRIPTOR\nBinder的唯一标识，一般用Binder的类名表示\n\nasInterface(android.os,IBinder  obj)\n用于将服务端的Binder对象转换成客户端所需要的AIDL接口类型对象，这种转换过程区分进程，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否返回的就是系统封装后的Stub.proxy对象\n\nasBinder\n此方法用于返回当前的Binder对象\n\nonTransact\n\n这个方法运行在服务端的Binder线池中\n\nProxy#getBookList\n这个方法运行在客户端，内部实现：首先创建该方法所需要的输入型Parcel对象_data,输出型Parcel对象 _reply和返回值对象List，然后把该方法的参数写入 _data中，接着调用transact方法来发起RPC（远程过程调用）请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从reply中取出RPC过程的返回结果；最后返回 _reply中的数据\n\nProxy#addBook\n过程和上面的一样，没有返回值不需要从 _reply中取出返回值\n\n\n\n\nlinkToDeath和unlinkToDeath\n为了解决Binder死亡对功能的影响提供了这俩方法（为了监听远程进程的死亡事件）\n给Binder设置死亡代理：\n\n首先声明一个DeathRecipient对象,移除之前的binder代理并重新绑定远程服务\nprivate IBinder.DeathRecipient mDeathRecipient=new  IBinder.DeathRecipient()&#123;     /**     * 当远程服务的 Binder 死亡时（即其所在进程终止），这个方法会被回调。     */        @Override        public void binderDied() &#123;             // 1. 安全检查，虽然理论上此时 mBookManager 不会为 null，但加上更健壮            if(mBookManager==null) return;             // 2. 解除死亡监听        // 既然已经收到了死亡通知，就不再需要监听了，所以要解除注册，防止内存泄漏。            mBookManager.asBinder.unlinkToDeath(mDeathRecipient,0);            // 3. 清理无效的代理对象        // 远程服务已经死亡，这个 mBookManager 代理对象也失效了，立即设为 null，        // 防止应用的其他地方误用这个“已死亡”的对象，导致 DeadObjectException。            mBookManager=null;             // 4. 实现重连机制（关键步骤）        \t// 这是最重要的一步，你可以在这里编写逻辑来重新绑定远程服务。        \t// 比如可以启动一个新的 bindService 请求，这样当远程服务恢复后，你的客户端就能自动重新连接上。            //TODO:这里重新绑定远程Service        &#125;    &#125;;\n\n\n\n设置死亡代理\n//将底层的 IBinder 对象转换为客户端可直接调用的 AIDL 接口代理对象 (mService)。mService=IMessageBoxManager.Stub.asInterface(binder);//给这个 binder 连接注册一个“死亡讣告”接收者 (mDeathRecipient)。binder.linkToDeath(mDeathRecipient,0);\n\n**注：**通过Binder的方法isBinderAlive也可以判断Binder是否死亡\n","categories":["Android进阶"]},{"title":"Java基础概念","url":"/posts/Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","content":"注释注释的定义\n注释是在程序指定位置添加的说明性信息\n对代码的解释，不参与编译\n\n分类\n单行注释  格式//注释信息\n多行注释  格式/* 注释信息 */\n文档注释 格式/**注释信息*/\n\n\n关键字特点及定义\n被java赋予特定含义的英文单词\n关键字字母全部小写\n\nclass\n用于创建或定义一个类\n类是java最基本的组成单元\n\n\n字面量分类\n‘\\t’制表符在打印的时候，把前面字符串的长度补齐到8，或者8的整数倍。最少补1个空格，最多补8个。\n\n数据类型分类基本数据类型和引用数据类型\n基本数据类型\n\nlong和float数据类型后面需要分别加上L和F标识\n\n取值范围大小关系double&gt;float&gt;long&gt;int&gt;short&gt;byte\n\n标识符命名规则—–硬性规则\n由数字，字母，下划线，美元符组成\n不能以数字开头\n不能是关键字\n区分大小写\n\n命名规则—–软性建议\n小驼峰命名法(适用于方法，变量)\n标识符是一个单词时，全部小写\n标识符是多个单词时，第一个单词首字母小写其他单词首字母大写\n\n\n大驼峰命名法(适用于类名)\n标识符是一个单词时，首字母大写\n标识符是多个单词时，每个单词的首字母大写\n\n\n\n\n","categories":["Java"]},{"title":"CMD","url":"/posts/CMD/","content":"常见CMD命令\n盘符名称+冒号切换盘符\ndir查看当前路径下内容(隐藏的也会展示出来)\ncd+目录进入单级目录\n**cd 目录1\\目录2\\ **进入多级目录\n**cd ..**回退上一级目录\n**cd \\ **回退到盘符目录\ncls 清屏\nexit 退出命令窗口\n\n","categories":["Java"]},{"title":"Git","url":"/posts/Git/","content":"创建代码仓库首先配置身份，利用：\ngit config --global user.name  &quot;  &quot;\ngit config --global user.email  &quot;  &quot;\n可以利用git config --list对配置信息进行查看\n然后进入到想要创建仓库的相应项目文件中利用 cd \n然后在该目录中输入git init\n项目创建完成后会在目录中生成一个隐藏的**.git文件夹，这个文件夹用来记录本地所有的Git操作，可以通过ls -al**命令来查看\n如果想删除该仓库，只需删除这个文件夹即可\n\n提交本地代码可以使用add和commit提交\nadd是先将想要提交的代码添加进来，commit则是真正的去执行提交操作\n添加单个文件：git add+文件名\n添加目录：git add+目录名\n添加所有文件：git add .\n提交：git commit -m &quot;First commit.&quot;一定要有-m加上提交的描述信息。\n\n忽略文件如果不想把app文件下的内容添加到版本控制中，那么可以修改app&#x2F;.gitignore文件中的内容：\n&#x2F;build\n&#x2F;src&#x2F;test\n&#x2F;src&#x2F;androidTest\n现在就可以提交代码：\ngit add .\ngit commit -m &quot;First commit.&quot;\n\n查看修改内容1.在项目根目录下输入以下指令：\ngit status\n2.修改数据后再次使用该指令可以发现文件已更改\n3.利用git diff app&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;providertest&#x2F;MainActivity.java查看更改的内容\n\n撤销未提交的修改1.利用git checkout app&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;providertest&#x2F;MainActivity.java指令可以使一切修改撤销\n2.输入git status进行检查\n3.不过这种撤销方式只适合于那些没有执行过add添加的文件\n如果是已经添加过的文件需要先使用git reset app/src/main/java/com/example/providertest/MainActivity.java指令取消添加\n\n查看提交记录1.用git log查看历史提交信息\n2.若只想查其中一条记录，可以在命令中指定该条记录的id并加上**-1**参数表示只想看到这一行\n3.如果想看这条记录具体修改了什么可以加个 -p，其中减号代表删除，加号代表添加的部分。\n\n分支的用法\ngit branch查看分支\n\ngit branch+名字用于创建分支\n\ngit checkout +名字 切换分支\n\ngit checkout+分支1\ngit merge+分支2  可以把分支2上修改并提交的内容合并到分支1上\n\ngit branch -D +分支名用于删除分支\n\n\n\n与远程版本库协作\ngit clone 地址表示将代码下载到本地\ngit push origin master  表示将本地修改的内容同步到远程版本库（origin指定的是远程版本库的Git地址）\ngit fetch origin master  表示将远程版本库内容同步到本地，会存放到origin&#x2F;master 分支上\ngit diff origin&#x2F;master 查看远程版本库上到底修改了什么\ngit merge origin&#x2F;master将origin&#x2F;master分支上的修改合并到主分支上\ngit pull origin master相当于将fetch和merge两个命令放一块执行，它可以从远程版本库上获取最新代码并合并到本地\n\n\n","categories":["Git"]},{"title":"Java跨平台的原理","url":"/posts/Java%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8E%9F%E7%90%86/","content":"\n通过虚拟机实现的\nJava语言不是直接运行在操作系统里面的，而是运行在虚拟机中\n针对于不同的操作系统，安装不同的虚拟机即可\n\n","categories":["Java"]},{"title":"Kotlin使用DSL构建专有语法结构","url":"/posts/Kotlin%E4%BD%BF%E7%94%A8DSL%E6%9E%84%E5%BB%BA%E4%B8%93%E6%9C%89%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84/","content":"DSL构建专有的语法结构DSL 是专为特定领域（如数据库查询、配置文件、UI布局等）设计的编程语言或语言的一个子集。Kotlin 提供了丰富的支持，帮助开发者用 Kotlin 代码构建出自己的 DSL 语言结构，以使得代码更加易读和易写。\n\n扩展函数：你可以通过扩展函数给现有类添加自定义功能，从而实现新的语法结构。\n高阶函数：Kotlin 允许将函数作为参数传递给其他函数，这使得定义和构建 DSL 成为可能。\nLambda 表达式：你可以通过 lambda 表达式使代码更加简洁，形成类似声明式的语法。\n智能类型推断：这使得你无需显式声明类型，语法更清晰，推导更自然。\n\nLambda with Receiver（接收者 lambda）接收者 lambda 允许在 lambda 中访问外部对象的成员，而不需要显式的引用对象。通过这种方式，你可以通过一个语法块来访问和操作对象，类似于嵌套调用的结构。\nclass DSL &#123;    fun sayHello() = println(&quot;Hello, World!&quot;)&#125;fun dslExample(init: DSL.() -&gt; Unit) &#123;    val dsl = DSL()    dsl.init()&#125;fun main() &#123;    dslExample &#123;        sayHello()  // 直接调用 DSL 中的方法，类似于在 &quot;this&quot; 上调用方法    &#125;&#125;\n\n在这个例子中，init 是一个扩展函数 DSL.() -&gt; Unit，其中 DSL 是接收者类型，而 init 是一个 lambda 表达式，它可以直接访问 DSL 类的成员。\n构建层次结构你可以使用 lambda 表达式来构建一个嵌套的结构，这在构建树形结构或配置文件时特别有用。例如，构建 UI 或 HTML 模板时，嵌套的 DSL 会让代码看起来更简洁。\nclass Td&#123;    var content=&quot;&quot;    fun html()=&quot;\\n\\t\\t&lt;td&gt;$content&lt;/td&gt;&quot;&#125;class Tr&#123;    private val children=ArrayList&lt;Td&gt;()    fun td(block:Td.()-&gt;String)&#123;        val td=Td()        td.content=td.block()        children.add(td)    &#125;    fun html():String&#123;        val builder=StringBuilder()        builder.append(&quot;\\n\\t&lt;tr&gt;&quot;)        for (childTag in children)&#123;            builder.append(childTag.html())        &#125;        builder.append(&quot;\\n\\t&lt;tr&gt;&quot;)        return builder.toString()    &#125;&#125;class Table&#123;    private val children=ArrayList&lt;Tr&gt;()    fun tr(block: Tr.() -&gt; Unit)&#123;        val tr=Tr()        tr.block()        children.add(tr)    &#125;    fun html():String&#123;        val builder=StringBuilder()        builder.append(&quot;&lt;table&gt;&quot;)        for (childTag in children)&#123;            builder.append(childTag.html())        &#125;        builder.append(&quot;\\n&lt;/table&gt;&quot;)        return builder.toString()    &#125;&#125;fun table(block:Table.()-&gt;Unit):String&#123;    val table=Table()    table.block()    return table.html()&#125;fun main()&#123;    /*val table=Table()    table.tr &#123;        td&#123;&quot;Apple&quot;&#125;        td&#123;&quot;Grape&quot;&#125;        td&#123;&quot;Orange&quot;&#125;    &#125;    table.tr &#123;        td&#123;&quot;Pear&quot;&#125;        td&#123;&quot;Banana&quot;&#125;        td&#123;&quot;Watermelon&quot;&#125;    &#125;*/    val html= table &#123;        tr &#123;            td&#123;&quot;Apple&quot;&#125;            td&#123;&quot;Grape&quot;&#125;            td&#123;&quot;Orange&quot;&#125;        &#125;        tr &#123;            td&#123;&quot;Pear&quot;&#125;            td&#123;&quot;Banana&quot;&#125;            td&#123;&quot;Watermelon&quot;&#125;        &#125;    &#125;    println(html)&#125;\n\n这里，我们创建了一个简单的 HTML 构建器 DSL。你可以在外部 html 块中定义结构，从而形成一个层次化的结构。\n\n","categories":["Kotlin"]},{"title":"Jetpack(Kotlin)","url":"/posts/Jetpack/","content":"JetpackJetpack全家福\n\nViewModel作用帮助Activity分担一部分工作，专门用于存放与界面相关的数据的，他可以保证在手机屏幕发生旋转时不会被重新创建，数据不会丢失\n生命周期\n用法\n添加依赖\n\n创建一个ViewModel类继承自ViewModel()\n\n把界面相关的数据都放入其中\n\n在Activity或fragment中创建其实例\n\n构建相关逻辑\nimplementation (&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.2&quot;) // Kotlin 版本implementation (&quot;androidx.lifecycle:lifecycle-viewmodel:2.6.2&quot;)     // Java 版本\n\nclass MainViewModel(countReserved: Int) : ViewModel() &#123;\tvar counter=0&#125;\n\nclass MainActivity : AppCompatActivity() &#123;    private lateinit var binding: ActivityMainBinding    lateinit var viewModel: MainViewModel    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        binding=ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        //获取实例        viewModel=ViewModelProvider(this).get(MainViewModel::class.java)        binding.plus.setOnClickListener &#123;            viewModel.counter++            refreshCounter()        &#125;        refreshCounter()&#125;    private fun refreshCounter()&#123;        binding.infoText.text=viewModel.counter.toString()    &#125;o&#125;\n\n像ViewModel传递参数\n添加参数\n\n新建ViewModelFactory类，实现ViewModelProvider.Factory接口\n\n利用SharedPreferences保存数据\n\n读取数据，将数据传入到ViewModelFactory的构造函数中\nclass MainViewModel(countReserved: Int) : ViewModel() &#123;   var counter=countReserved&#125;\n\nclass MainViewModelFactory(private val countReserved:Int):ViewModelProvider.Factory &#123;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;        return MainViewModel(countReserved) as T    &#125;&#125;\n\nclass MainActivity : AppCompatActivity() &#123;    private lateinit var binding: ActivityMainBinding    lateinit var viewModel: MainViewModel    lateinit var sp:SharedPreferences    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        binding=ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        sp=getPreferences(Context.MODE_PRIVATE)        val contReserved=sp.getInt(&quot;count_reserved&quot;,0)        viewModel=ViewModelProvider(this,MainViewModelFactory(contReserved)).get(MainViewModel::class.java)        binding.plus.setOnClickListener &#123;            viewModel.counter++            refreshCounter()        &#125;        binding.clear.setOnClickListener &#123;            viewModel.counter=0            refreshCounter()        &#125;        refreshCounter()     &#125;    private fun refreshCounter()&#123;        binding.infoText.text=viewModel.counter.toString()    &#125;    override fun onPause() &#123;        super.onPause()        sp.edit &#123;            putInt(&quot;count_reserved&quot;,viewModel.counter.value?:0)        &#125;    &#125;&#125;\n\n\nLifecycles作用他可以让任何一个类轻松地感知到Activity生命周期\n用法\n新建一个类\n\n借助注解能力编写逻辑代码\n\n获取LifecycleOwer实例，Activity或者Fragment本身就是一个LifecycleOwer实例\n\n在活动中进行调用(也可以在任何地方调用lifecycle.currentState来主动获取当前生命周期状态)\nclass MyObserver(val lifecycle: Lifecycle):LifecycleObserver &#123;    @OnLifecycleEvent(Lifecycle.Event.ON_START)    fun activityStart()&#123;        Log.d(&quot;MyObserver&quot;, &quot;activityStart: &quot;)    &#125;    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)    fun activityStop()&#123;        Log.d(&quot;MyObserve&quot;, &quot;activityStop: &quot;)    &#125;&#125;\n\nlifecycle.addObserver(MyObserver())\n\n\nLiveData基本用法\n添加依赖\nimplementation &quot;androidx.lifecycle:lifecycle-livedata-ktx:2.5.1&quot;\n\n创建LiveData\nclass MyViewModel (countReserved:Int): ViewModel() &#123;    // 创建 LiveData    private val _counter = MutableLiveData&lt;Int&gt;()    val counter: LiveData&lt;Int&gt; get() = _counter    init &#123;        _counter.value = countReserved    &#125;    // 更新 LiveData 数据    fun incrementCounter() &#123;        _counter.value = (_counter.value ?: 0) + 1    &#125;&#125;\n\n\nMutableLiveData: 可变的 LiveData 类型，允许数据更新。\nLiveData: 不可变的 LiveData 类型，只能观察数据，不能直接修改数据。\n\n\n在 Activity 或 Fragment 中观察 LiveData在 Activity 或 Fragment 中，你可以通过 observe() 方法观察 LiveData。当数据发生变化时，LiveData 才会发送更新。\nclass MainActivity : AppCompatActivity() &#123;    // 获取 ViewModel 实例    private val myViewModel: MyViewModel by viewModels()    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        // 观察 LiveData 数据        myViewModel.counter.observe(this)&#123; count -&gt;            // 更新 UI            counterText.text = count.toString()        &#125;        // 设置按钮点击事件        incrementButton.setOnClickListener &#123;            myViewModel.incrementCounter()        &#125;    &#125;&#125;\n\nmap和switchMap\nmap\n\n作用：将实际包含数据的LiveData和仅用于观察数据的LiveData进行转换\n\n用法：\nclass MyViewModel : ViewModel() &#123;    private val _userName = MutableLiveData&lt;String&gt;()    val userName: LiveData&lt;String&gt; get() = _userName    // 使用 map 将原始数据转换为需要的格式    val userGreeting: LiveData&lt;String&gt; = userName.map &#123; name -&gt;        &quot;Hello, $name&quot;    &#125;    fun updateUserName(name: String) &#123;        _userName.value = name    &#125;&#125;\n\n\nswitchMap\n\n使用场景：当ViewModel中某个liveData对象是调用另外的方法获取的时候用switchMap\n\n用法：\nclass MyViewModel : ViewModel() &#123;    private val _searchQuery = MutableLiveData&lt;String&gt;()    val searchQuery: LiveData&lt;String&gt; get() = _searchQuery    // 使用 switchMap 来根据 searchQuery 触发新的搜索请求    val searchResults: LiveData&lt;List&lt;String&gt;&gt; = searchQuery.switchMap &#123; query -&gt;        // 假设搜索是一个异步操作，这里模拟为一个简单的列表        MutableLiveData&lt;List&lt;String&gt;&gt;().apply &#123;            value = listOf(&quot;Result for $query&quot;)        &#125;    &#125;    fun updateSearchQuery(query: String) &#123;        _searchQuery.value = query    &#125;&#125;\n\n\nsearchQuery 是一个包含搜索关键字的 LiveData。\nswitchMap 将每次更新的 searchQuery 映射到一个新的 LiveData（这里模拟为搜索结果）。\n当 searchQuery 更新时，switchMap 会取消之前的查询并触发新的查询。\n\n\n\n\n\n\nRoom基本特征Room 是 Jetpack 提供的一个数据库库，简化了 SQLite 的操作。它提供了一个抽象层，允许开发者更方便、更安全地访问本地数据库。Room 提供了注解（annotation）支持，结合 Kotlin 的数据类和架构组件，能够更高效地管理数据持久化操作。\nRoom 提供了一个 DAO（数据访问对象） 层来进行数据库操作，DAO 使用 SQL 查询语句来与数据库交互。Room 会在编译时生成实际的实现代码，减少了手动编写 SQL 语句的繁琐。\n\n简单易用：相比直接使用 SQLite，Room 提供了更简单、类型安全的 API。\nSQLite 完全支持：它是基于 SQLite 的，可以执行 SQL 查询、插入、更新和删除操作。\n注解支持：使用注解定义数据库实体、DAO 和数据库版本。\n与 LiveData 兼容：Room 支持与 LiveData 结合使用，当数据改变时，Room 可以自动通知观察者。\n\n添加依赖和插件kotlin(&quot;kapt&quot;)\n\nimplementation(&quot;androidx.room:room-runtime:2.6.1&quot;)  // Room 的运行时库kapt(&quot;androidx.room:room-compiler:2.6.1&quot;)  // Room 的编译器，使用 KAPT 注解处理implementation(&quot;androidx.room:room-ktx:2.6.1&quot;)  // Room 的扩展库，提供了一些扩展函数和属性.\n\n定义实体类(Entity)@Entitydata class User (var firstName:String,var lastName:String,var age:Int)&#123;    @PrimaryKey(autoGenerate = true)    var id:Long=0&#125;\n\n\n@Entity 注解标识这个类是一个数据库表。\n@PrimaryKey 注解指定主键，并可以设置 autoGenerate = true 让 Room 自动生成主键。\n\n定义Dao\nRoom关键部分，所有数据库操作均封装在这里\n\n@Daointerface UserDao &#123;    @Insert    fun insertUser(user:User):Long    @Update    fun updateUser(newUser: User)    @Query(&quot;select * from User&quot;)    fun loadAllUsers():List&lt;User&gt;    @Query(&quot;select * from User where age&gt; :age&quot;)    fun loadUsersOlderThan(age:Int):List&lt;User&gt;    @Delete    fun deleteUser(user: User)    @Query(&quot;delete from User where lastName=:lastName&quot;)    fun deleteUserByLastName(lastName:String):Int&#125;\n\n\n@Dao 注解标识这个接口是 DAO。\n@Insert 注解用于插入数据。\n@Query 注解定义 SQL 查询语句。\n@Update注解用于更新数据\n@Delete注解用于删除数据\n利用非实体类参数来增删改数据时都要用**@Query**注解\n\n定义数据库(Database)@Database(version = 1, entities = [User::class])abstract class AppDatabase:RoomDatabase()&#123;    abstract fun userDao():UserDao    companion object&#123;        private var instance:AppDatabase?=null        @Synchronized        fun getDatabase(context: Context):AppDatabase&#123;            instance?.let &#123;                return  it            &#125;            return Room.databaseBuilder(context.applicationContext,AppDatabase::class.java,&quot;app_database&quot;                          .build().apply &#123;                    instance=this                &#125;        &#125;    &#125;&#125; \n\n\n@Database 注解用于定义数据库，并指定包含的实体类和数据库版本，实体类之间用逗号隔开。\nabstract fun userDao() 方法提供对 DAO 的访问。\n通过 Room.databaseBuilder() 方法获取数据库实例\n由于数据库操作均为耗时操作故需要在子线程中进行\n\n数据库升级\n更新版本和包含的实体类\n实现 Migration的匿名类\n构建实例时加入addMigrations方法\n\n@Database(version = 3, entities = [User::class, Book::class])abstract class AppDatabase : RoomDatabase() &#123;    /**     * UserDao 是用于操作 User 实体的 DAO（Data Access Object）。     */    abstract fun userDao(): UserDao    /**     * BookDao 是用于操作 Book 实体的 DAO（Data Access Object）。     */    abstract fun bookDao(): BookDao    /**     * Companion 对象用于存储数据库的迁移信息和实例。     */    companion object &#123;        /**         * MIGRATION_1_2 是从数据库版本 1 到 2 的迁移。         */        val MIGRATION_1_2 = object : Migration(1, 2) &#123;            /**             * migrate 方法用于执行从版本 1 到 2 的迁移。             * 在这个例子中，我们创建了一个名为 Book 的新表。             */            override fun migrate(database: SupportSQLiteDatabase) &#123;                database.execSQL(&quot;&quot;&quot;                    CREATE TABLE Book (                        id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,                        name TEXT NOT NULL,                        pages INTEGER NOT NULL,                        author TEXT NOT NULL                    )                &quot;&quot;&quot;.trimIndent())            &#125;        &#125;        /**         * MIGRATION_2_3 是从数据库版本 2 到 3 的迁移。         */        val MIGRATION_2_3 = object : Migration(2, 3) &#123;            /**             * migrate 方法用于执行从版本 2 到 3 的迁移。             * 在这个例子中，我们添加了一个名为 author 的新列到 User 表中。             */            override fun migrate(database: SupportSQLiteDatabase) &#123;                database.execSQL(&quot;&quot;&quot;                    ALTER TABLE User ADD COLUMN                     author TEXT NOT NULL DEFAULT &#x27;unknown&#x27;                    &quot;&quot;&quot;)            &#125;        &#125;        /**         * instance 是 AppDatabase 的实例。         */        private var instance: AppDatabase? = null        /**         * getDatabase 方法用于获取 AppDatabase 的实例。         * 如果实例已经存在，则直接返回实例。         * 否则，则创建一个新的实例并返回。         */        @Synchronized        fun getDatabase(context: Context): AppDatabase &#123;            instance?.let &#123; return it &#125;            return Room.databaseBuilder(                context.applicationContext,                AppDatabase::class.java,                &quot;app_database&quot;            )                .addMigrations(MIGRATION_1_2, MIGRATION_2_3)                .build().apply &#123; instance = this &#125;        &#125;    &#125;&#125;\n\n\nWorkManager作用处理一些要求定时执行的任务，可以根据操作系统的版本自动选择是使用AlarmManager还是JobScheduler实现。另外还能支持周期性任务，链式任务处理等功能。它很适合执行一些定期和服务器交互的任务，比如周期性的同步数据\n基本用法\n添加依赖\n\n   implementation (&quot;androidx.work:work-runtime:2.8.1&quot;) // Java    implementation (&quot;androidx.work:work-runtime-ktx:2.8.1&quot;) // Kotlin + Coroutines\n\n\n定义后台任务并实现具体的任务逻辑\nclass SimpleWorker(context: Context,params:WorkerParameters):Worker(context,params) &#123;    override fun doWork(): Result &#123;        //编写具体的后台任务逻辑        Log.d(&quot;SimpleWorker&quot;, &quot;do work in simpleworker&quot;)        return  Result.success()    &#125;&#125;\n\n\n返回Result.success()表示成功\n返回Result.failure()表示失败\n返回Result.retry()也表示失败，只是可以结合WorkRequest.Builder的setBackoffCriteria()方法来重新执行任务\n\n\n配置该后台任务的运行条件和约束信息，并构建后台任务请求\nval workRequest = OneTimeWorkRequest.Builder(SimpleWorker::class.java)    .build()\n\nval periodicWorkRequest = PeriodicWorkRequest.Builder(MyWorker::class.java, 1, TimeUnit.HOURS)    .build()\n\n\nOneTimeWorkRequest 来执行一次性任务\nPeriodicWorkRequest 来执行定期任务。\n\n\n将该后台任务请求传入WorkManager的enqueue()的方法中，系统会在合适的时间运行\nWorkManager.getInstance(applicationContext).enqueue(workRequest)\n\n处理复杂任务\n设置约束信息\nval workRequest = OneTimeWorkRequest.Builder(MyWorker::class.java)\t.setInitialDelay(5,TimeUnit.MINUTES)    .addTag(&quot;simple&quot;)    .build()\n\n取消后台任务请求\nWorkManager.getInstance(applicationContext).cancelWorkByTag(&quot;simple&quot;)\n\nWorkManager.getInstance(applicationContext).cancelWorkById(workRequest.id)\n\nWorkManager.getInstance(applicationContext).cancelAllwork()//一次性取消所有后台任务\n\n使用id只能取消单个任务，使用标签可以取消同一标签名的所有任务\n\n任务重试\n当doWork方法中返回Result.retry()时可以结合setBackoffCriteria方法重新执行任务\n//第一个参数指的是如果任务再次执行失败，下次重试的时间应以什么形式延迟val workRequest = OneTimeWorkRequest.Builder(MyWorker::class.java)    .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 10, TimeUnit.SECONDS)    .build()WorkManager.getInstance(applicationContext).enqueue(workRequest)\n\n观察任务状态WorkManager.getInstance(applicationContext)    .getWorkInfoByIdLiveData(workRequest.id)    .observe(this, Observer &#123; workInfo -&gt;        if (workInfo != null) &#123;            when (workInfo.state) &#123;                WorkInfo.State.SUCCEEDED -&gt; &#123;                    // 任务成功                &#125;                WorkInfo.State.FAILED -&gt; &#123;                    // 任务失败                &#125;                WorkInfo.State.RUNNING -&gt; &#123;                    // 任务正在运行                &#125;                else -&gt; &#123;                    // 任务还未开始或已经完成                &#125;            &#125;        &#125;    &#125;)\n\n链式任务\n\n\n  val firstRequest = OneTimeWorkRequest.Builder(MyWorker::class.java).build()val secondRequest = OneTimeWorkRequest.Builder(SecondWorker::class.java).build()WorkManager.getInstance(applicationContext)    .beginWith(firstRequest)    .then(secondRequest)    .enqueue()\n\n  **注：**千万别依赖其去实现一些核心功能，它在国产手机上是不稳定的\n\n","categories":["Android(Kotlin版)"]},{"title":"Kotlin使用协程编写高效的并发程序","url":"/posts/Kotlin%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88%E7%9A%84%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F/","content":"协程的基本用法\n优点\n协程允许我们在单线程模式下模拟多线程编程的效果\n\n依赖库\n// Gradle 依赖implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0&quot;)//Android扩展implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.8.0&quot;)\n\nGlobal.launch函数创建协程作用域\n\nGlobal.launch创建的是一个顶层协程，这种协程当应用程序结束时也会跟着结束\n使用Thread.sleep可以让主线程堵塞一定时长\ndelay()可以让当前协程延长指定时间后再运行，是一个非阻塞式的挂起函数，只会挂起当前协程，对其他线程或协程无影响\n最大的问题就是可能代码还没运行结束应用程序就结束了，代码运行强制中断\n\nGlobalScope.launch &#123;       println(&quot;codes run in coroutine scope&quot;)       delay(1500)       println(&quot;codes run in coroutine scope finished&quot;)   &#125;   Thread.sleep(1000)\n\nrunBlocking函数\n\n可以保证作用域内所有代码和子线程未执行完之前一直阻塞当前线程\n需要注意runBlocking 一般只在测试环境使用，正式环境容易出现性能问题\n可以在作用域中使用launch函数创建多个协程\n子线程的特点如果外层作用域协程结束子线程也会结束\n\nrunBlocking &#123;            launch &#123;                println(&quot;launch1&quot;)                delay(1000)                println(&quot;launch1 finished&quot;)            &#125;            launch &#123;                println(&quot;launch2&quot;)                delay(1000)                println(&quot;launch2 finished&quot;)            &#125;\n\nsuspend关键字\n\n可以将任何函数声明成挂起函数\n无法提供协程作用域\n\nsuspend fun printDot()&#123;    println(&quot;.&quot;)    delay(1000)&#125;\n\ncoroutineScope函数\n会继承外部的协程的作用域并创建一个子协程\nsuspend fun printDot()=coroutineScope&#123;    launch&#123;    println(&quot;.&quot;)    delay(1000)    &#125;&#125;\n\ncoroutineScope函数和runBlocking函数的区别\n\ncoroutineScope将外部协程挂起，当作用域内代码执行完毕coroutineScope函数之后的代码才可以执行\ncoroutineScope函数只会阻塞当前线程既不影响其他协程又不影响其他线程，因此不会造成任何性能上的问题\nrunBlocking会造成性能上的问题，不推荐在项目中使用\n\n\n\n\n更多的作用域构建器\n实际项目中常用写法\nval job=Job()val scope=CoroutineScope(job)scope.launch&#123;    //处理具体逻辑&#125;job.cancel()\n\n这样创建所有调用CoroutineScope的launch函数所创建的协程，都会被关联在Job对象作用域下，这样只需调用一次cancel就可以将同一作用域内的所有协程全部取消\n\nasync获取执行结果\n\nasync必须在协程作用域中调用\n创建一个新的协程并返回一个Deferred对象，并调用await()方法获取结果\n在最后一起调用await方法可以大大提高效率，会使两个async函数变为并行关系\n\nfun main()&#123;    /*runBlocking &#123;        val result=async &#123;            5+5        &#125;.await()        println(result)    &#125;*/    runBlocking &#123;        val result1=async &#123;            5+5        &#125;        val result2=async &#123;            4+6        &#125;        println(&quot;result is $&#123;result1.await()+result2.await()&#125;&quot;)    &#125;&#125;\n\nwithContext()函数(async函数的简化版)\n\n当代码全部执行完会将最后一行结果作为返回值返回\n强制要求指定一个线程参数\n线程参数有三个可选值：Dispatchers.Default,Dispatchers.IO和Dispatchers.Main.Dispatchers.Default表示默认低并发策略，当执行代码属于计算密集型任务时，开启过高的并发反而影响效率。Dispatchers.IO表示较高并发的线程策略，执行代码大多数时间在阻塞和等待中。Dispatchers.Main表示不会开启子线程，但这个值只能在Android项目中使用，纯Kotlin程序中使用会出错。\n\nfun main()&#123;    runBlocking &#123;        val result= withContext(Dispatchers.Default)&#123;            5+5        &#125;        println(result)    &#125;&#125;\n\n\n使用协程简化回调方法\n发送网络请求的回调\n\nsuspendCoroutine函数必须在协程作用域或挂起函数中才能调用，主要作用是把当前协程立刻挂起，然后在普通线程中执行lambda表达式代码\nLambda表达式会传入continuation参数，调用他的resume方法或resumeWithException方法可以使协程恢复\n\n suspend  fun request(adress:String):String&#123;        return suspendCoroutine &#123;            continuation -&gt;           HttpUtil.sendRequestWithHttpURLConnection(adress,object:HttpCallbackListener&#123;               override fun onFinish(response: String) &#123;                   continuation.resume(response)               &#125;               override fun onError(e: Exception) &#123;                   continuation.resumeWithException(e)               &#125;           &#125;)        &#125;    &#125;//调用    suspend  fun getBaiduResponse()&#123;        try&#123;            val response=request(&quot;http://www.baidu.com/&quot;)            //对服务器响应数据进行处理        &#125;catch(e:Exception)&#123;            //对异常情况处理        &#125;    &#125;\n\nRetrofit发送请求的回调\nsuspend fun&lt;T&gt; Call&lt;T&gt;.await():T&#123;    return suspendCoroutine&#123;continuation -&gt;                            enqueue(object:Callback&lt;T&gt;&#123;                                 override fun onResponse(                    call: Call&lt;T&gt;,                    response: Response&lt;T&gt;                ) &#123;                  val body=response.body()                  if(body!=null)&#123;                      continuation.resume(body)                  &#125;                  else   continuation.resumeWithException(                     RuntimeException(&quot;response body is null&quot;)                 )                                 &#125;                override fun onFailure(call: Call&lt;T&gt;, t:Throwable) &#123;                  continuation.resumeWithException(t)                &#125;                            &#125;)            &#125;&#125;//调用suspend fun getAppData()&#123;    try&#123;        val appList=ServiceCreator.create&lt;AppService&gt;().getAppData().await()        //对服务器响应的数据进行处理    &#125;catch(e:Exception)&#123;        //对异常进行处理    &#125;&#125;\n\n\n","categories":["Kotlin"]},{"title":"Kotlin定义静态方法","url":"/posts/Kotlin%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/","content":"类静态方法kotlin特有，有与静态方法同样的语法特点但并非静态方法\n静态方法特点是可以直接使用(类.方法)的形式调用\n单例类object Util&#123;    fun doAction()&#123;        println(&quot;do action&quot;)    &#125;&#125;\n\n单例类中所以方法皆可以视为静态方法\n如果只想某一方法变为静态方法可以使用companion object{}\nclass Util&#123;    fun doAction1()&#123;        println(&quot;do action1&quot;)    &#125;    companion object&#123;     fun doAction2()&#123;        println(&quot;do action2&quot;)    &#125;    &#125;&#125;\n\n\n静态方法注解法（不常用）使用@JvmStatic注解(只能加在单例类或companion object{}中的方法上)\nclass Util&#123;    fun doAction1()&#123;        println(&quot;do action1&quot;)    &#125;    companion object&#123;        @JvmStatic     fun doAction2()&#123;        println(&quot;do action2&quot;)    &#125;    &#125;&#125;\n\n顶层方法1.定义：Kotlin编译器会将所有顶层方法编译成静态方法\n2.建立一个kotlin文件：\n任意包名-&gt;New-&gt;Kotlin File&#x2F;Class在弹窗中选择File类型，该文件中的方法全都是顶层方法\n\n","categories":["Kotlin"]},{"title":"Kotlin延迟初始化和密封类","url":"/posts/Kotlin%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%AF%86%E5%B0%81%E7%B1%BB/","content":"变量延迟初始化关键字lateinit\n作用如果一个变量是全局变量且初始化在后面的过程中进行时该变量不得不赋值为null，但如果这样进行后面调用其任何方法都需要进行判空处理相对麻烦，所以这里可以使用延迟初始化，就不需要将其赋值为null了\n注意使用延迟初始化时一定要保证后续某处对其完成了初始化\n还可以通过代码进行判断是否完成了初始化\n//::adapter.isInitialized表示已经初始化if(!::adapter.isInitialized)&#123;    adapter=MsgAdapter(msgList)&#125;\n\n\n密封类关键字sealed class\n作用解决因语法原因导致的多余分支问题\n实例sealed class Resultclass Success(val msg:String):Result()class Failure(val error:Exception):Result()\n\nfun getResultMsg(result:Result)=when(result)&#123;    is Success -&gt; result.msg    is Failure -&gt; &quot;Error is $&#123;result.error.message&#125;&quot;&#125;\n\n注意密封类及其子类只能定义在同一文件的顶层位置，不能嵌套在其他类中\n\n","categories":["Kotlin"]},{"title":"Kotlin内置函数","url":"/posts/Kotlin%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/","content":"内置函数\nuse\n可以保证Lambda表达式中的所有代码执行完毕后自动将外层的流关闭，这样就不用再编写finally语句手动关闭了\n\nforEachLine\n它会将读取的每行内容回调到Lambda表达式，在lambda中完成拼接逻辑\n\narrayOf\n用于便捷创建数组\n\nby lazy\n懒加载技术，可以先不执行，第一次调用时再执行其中的逻辑\n\n\n","categories":["Kotlin"]},{"title":"Kotlin标准函数","url":"/posts/Kotlin%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0/","content":"with作用：可以在连续调用同一个对象的多个方法时让代码变得更简便\n标准形式：\nval result = with (obj)&#123;    //这里是obj的上下文    &quot;value&quot;//with函数返回值&#125;\n\n实例：\nval list= listOf(&quot;Apple&quot;,&quot;Banana&quot;,&quot;Pear&quot;)    val result=with(StringBuilder())&#123;        append(&quot;Start eating fruits.\\n&quot;)        for(fruit in list)&#123;            append(fruit).append(&quot;\\n&quot;)        &#125;        append(&quot;Ate all Fruits&quot;)        toString()    &#125;    println(result)\n\n\nrun作用：同with相同只是通常不会直接调用而是在对象的基础上调用\n标准形式：\nval result =obj.run&#123;    //这里是obj的上下文    &quot;value&quot;//run函数返回值&#125;\n\n实例：\nval list= listOf(&quot;Apple&quot;,&quot;Banana&quot;,&quot;Pear&quot;)    val result=StringBuilder().run&#123;        append(&quot;Start eating fruits.\\n&quot;)        for(fruit in list)&#123;            append(fruit).append(&quot;\\n&quot;)        &#125;        append(&quot;Ate all Fruits&quot;)        toString()    &#125;    println(result)\n\n\n\n\napply作用：作用和run类似只是无法指定返回值\n标准形式：\nval result =obj.apply&#123;    //这里是obj的上下文&#125;result==obj\n\n实例：\nval list= listOf(&quot;Apple&quot;,&quot;Banana&quot;,&quot;Pear&quot;)val result=StringBuilder().apply&#123;    append(&quot;Start eating fruits.\\n&quot;)    for(fruit in list)&#123;        append(fruit).append(&quot;\\n&quot;)    &#125;    append(&quot;Ate all Fruits&quot;)&#125;println(result.toString())\n\n利用Intent传递数据时也可以使用apply函数\nval intent=Intent(context,SecondActivity::class.java).apply&#123;    putExtra(&quot;param1&quot;,&quot;data1&quot;)    putExtra(&quot;param2&quot;,&quot;data2&quot;)&#125;context.startActivity(intent)\n\n\n\n\nrepeat传入一个值n然后lambda表达式中的内容执行n遍\n\n","categories":["Kotlin"]},{"title":"Kotlin扩展函数和运算符重载","url":"/posts/Kotlin%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","content":"扩展函数语法结构fun ClassName.methodName(param1:Int,param2:Int):Int&#123;return 0&#125;\n\n实例//构建扩展函数fun String.lettersCount():Int&#123;    var count=0    for(char in this)&#123;        if(char.isLetter())&#123;            count++        &#125;    &#125;    return count&#125;\n\n//调用fun main()&#123;    val cnt=&quot;ABC123xyz!@#&quot;.lettersCount()    println(cnt)&#125;\n\n\n运算符重载语法结构(可以实现同一个运算符多重重载)//重载class obj&#123;    operator fun plus(obj:Obj):Obj&#123;        //处理相加的逻辑    &#125;&#125;//调用val obj1=Obj()val obj2=Obj()val obj3=obj1+obj2\n\n实例1.Money实例\nclass Money(val value: Int) &#123;    //对象和对象相加    operator fun plus(money:Money):Money&#123;        val sum=value+money.value        return Money(sum)    &#125;    //对象和数字相加    operator fun plus(newValue: Int):Money&#123;        val sum=value+newValue        return Money(sum)    &#125;&#125;fun main()&#123;    val m1=Money(5)    val m2=Money(10)    val m3=m1+m2    val m4=m3+20println(m4.value)&#125;\n\n2.a in b实例\n//判断hello中有没有heif(&quot;he&quot; in &quot;hello&quot;)&#123;    &#125;\n\n3.扩展函数和运算符重载综合使用实例\n//重载operator fun String.times(n:Int):String&#123;    val builder=StringBuilder()  repeat(n)&#123;      builder.append(this)  &#125;    return builder.toString()&#125;//重载简化operator fun String.times(n:Int)= repeat(n)//调用fun main()&#123;    val str=&quot;abc&quot;*3    println(str)&#125;\n\n\n","categories":["Kotlin"]},{"title":"Kotlin的infix函数","url":"/posts/Kotlin%E7%9A%84infix%E5%87%BD%E6%95%B0/","content":"特点infix 关键字可以让 单参数的函数 以 更自然的语法 书写，使代码更易读。你可以把它理解为 一种特殊的调用方式，不需要 . 和 ()，让代码像 自然语言 一样流畅。例如mapOf中的键值对(A to B实际等价于A.to(B))省略了  .  和  （）。\n条件要使用 infix，需要满足 三个条件：\n\n必须是成员函数或扩展函数（它必须属于某个类或某种类型）。\n必须只有且只能有一个参数（如果有多个参数，就不能用 infix）。\n⭐⭐⭐⭐⭐⭐调用时可以省略 . 和 ()（但仍然可以用 . 调用）。\n\n实例infix fun &lt;T&gt; Collection&lt;T&gt;.has(element:T)=contains(element)val list =listOf(&quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;Pear&quot;,&quot;Grape&quot;)if(list has &quot;Banana&quot;)&#123;    //处理具体逻辑&#125;\n\n\n","categories":["Kotlin"]},{"title":"Kotlin泛型的高级特性","url":"/posts/Kotlin%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/","content":"泛型的实化条件\n\n内联函数\nreified关键字修饰\n\n举例\ninline fun &lt;reified T&gt; getGenericType()&#123;    &#125;\n\n应用\n启动活动\n\n新建一个reified.kt文件\n\ninline fun &lt;reified T&gt; startActivity(context:Context,block:Intent.()-&gt;Unit)&#123;    val intent= Intent(context,T::class.java)    //高阶函数用于传递数据    intent.block()    context.startActivity(intent)&#125;\n\n\n启动活动\n\nstartActivity&lt;Test&gt;(this)&#123;                putExtra(&quot;param1&quot;,&quot;data&quot;)                putExtra(&quot;param2&quot;,123)            &#125;\n\n泛型的协变定义\n假如定义一个MyClass的泛型类，其中A是B的子类型，同时MyClass是MyClass的子类型，就称MyClass在T这个泛型上是协变的\n条件\n一个泛型类在其泛型类型的数据上是只读的情况，简而言之，T只能出现在out位置上，而不能出现在in位置\n实例\n//在T前使用out关键字声明表示T只能出现在out位置上class SimpleData&lt;out T&gt;(val data:T?)&#123;    fun get():T?&#123;        return data    &#125;&#125;\n\nfun main()&#123;    val student=Student(&quot;Tom&quot;,19)    val data=SimpleData&lt;Student&gt;(student)    handleMyData(data)    val studentData=data.get()&#125;fun handleMyData(data:SimpleData&lt;Person&gt;)&#123;    val personData=data.get()&#125;\n\n泛型的逆变定义\n假如定义一个MyClass的泛型类，其中A是B的子类型，同时MyClass是MyClass的子类型，就称MyClass在T这个泛型上是逆变的\n条件\n泛型T前加上in关键字声明，简而言之，T只能出现在in位置上，而不能出现在out位置\n实例\n//在T前使用out关键字声明表示T只能出现在out位置上interface Transformer&lt;in T&gt;&#123;    fun transform(t:T):String&#125;\n\nfun main()&#123;    val trans=object:Transformer&lt;Person&gt;&#123;        override fun transform(t:Person):String&#123;            return &quot;$&#123;t.name&#125; $&#123;t.age&#125;&quot;        &#125;    &#125;    handleTransformer(trans)&#125;handleTransformer(trans:Transformer&lt;Student&gt;)&#123;        val student=Student(&quot;Tom&quot;,19)    \tval result=trans.transform(student)    &#125;\n\n\n","categories":["Kotlin"]},{"title":"Kotlin高阶函数","url":"/posts/Kotlin%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","content":"高阶函数函数类型(String,Int)-&gt;Unit\n左边是函数接收参数类型，右边是返回值类型\n定义含有函数类型的就叫高阶函数\n实例1fun num1Andnum2(num1:Int,num2:Int,operation: (Int,Int)-&gt;Int):Int&#123;    val result=operation(num1,num2)    return result&#125;fun plus(num1:Int,num2:Int):Int&#123;    return num1 + num2&#125;fun minus(num1:Int,num2:Int):Int&#123;    return num1-num2&#125;fun main()&#123;    val num1=100    val num2=50    val result1=num1Andnum2(num1,num2,::plus)    val result2= num1Andnum2(num1,num2,::minus)    println(result1)    println(result2)&#125;\n\nLambda表达式改进\nfun num1Andnum2(num1:Int,num2:Int,operation: (Int,Int)-&gt;Int):Int&#123;    val result=operation(num1,num2)    return result&#125;fun main()&#123;    val num1=100    val num2=50    val result1=num1Andnum2(num1,num2)&#123;        num1,num2-&gt;num1+num2    &#125;    val result2= num1Andnum2(num1,num2)&#123;            num1,num2-&gt;num1-num2    &#125;    println(result1)    println(result2)&#125;\n\n实例2fun StringBuilder.build( block:StringBuilder.()-&gt;Unit):StringBuilder&#123;    block()    return this&#125;fun main()&#123;    val list= listOf(&quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;Pear&quot;,&quot;Grape&quot;)    val result=StringBuilder().build &#123;        append(&quot;Start eating fruits\\n&quot;)        for(fruit in list)&#123;            append(fruit).append(&quot;\\n&quot;)        &#125;        append(&quot;Ate all fruits&quot;)    &#125;    println(result.toString())&#125;\n\n\n内联函数用法使用inline关键字，在高阶函数前加上inline即可\n作用可以将使用Lambda表达式带来的运行时开销完全消除\n实例inline fun num1Andnum2(num1:Int,num2:Int,operation: (Int,Int)-&gt;Int):Int&#123;    val result=operation(num1,num2)    return result&#125;\n\n原理\n\n\nnoinline和crossinlinenoinline如果含有多个函数类型参数，但只想内联其中一个，这时可以在函数类型前加noinline表示不内联\n内联和非内联区别内联函数中的lambda表达式可以使用return关键字返回，非内联只能局部返回\n局部返回实例 fun printString(str: String, block: (String) -&gt; Unit) &#123;    println(&quot;printString begin&quot;)    block(str)    println(&quot;printString end&quot;)&#125;fun main()&#123;     println(&quot;main start&quot;)    val str = &quot;&quot;    printString(str) &#123; s -&gt;        println(&quot;lambda start&quot;)        if (s.isEmpty()) return@printString        println(s)        println(&quot;lambda end&quot;)    &#125;    println(&quot;main end&quot;)&#125;\n\n输出结果\nmain startprintString beginlambda startprintString endmain end\n\n内联函数返回实例inline fun printString(str: String, block: (String) -&gt; Unit) &#123;    println(&quot;printString begin&quot;)    block(str)    println(&quot;printString end&quot;)&#125;fun main()&#123;     println(&quot;main start&quot;)    val str = &quot;&quot;    printString(str) &#123; s -&gt;        println(&quot;lambda start&quot;)        if (s.isEmpty()) return        println(s)        println(&quot;lambda end&quot;)    &#125;    println(&quot;main end&quot;)&#125;\n\n输出结果\nmain startprintString beginlambda start\n\n注意在高阶函数中创建另外的Lambda或匿名类实现，并且在这些实现中调用函数类型参数，此时再将其声明为内联函数会报错\n原因：内联函数允许使用return和高阶函数的匿名类不允许使用return矛盾导致报错\ncrossinline借用crossinline可以解决上述问题，crossinline相当于一份契约，用于保证在内联函数的lambda中一定不会使用return关键字\n虽然不能使用return返回但仍可以使用局部返回\ncrossinline实例inline fun runRunnable(crossinline block: () -&gt; Unit) &#123;    val runnable = Runnable &#123;        block()    &#125;    runnable.run()&#125;\n\n\n\n\n","categories":["Kotlin"]},{"title":"Kotlin语法","url":"/posts/Kotlin%E8%AF%AD%E6%B3%95/","content":"变量和函数变量1.由val和var声明变量，其中val声明不可变变量，var声明可变变量(建议所有变量开始由val修饰，后根据需要选择用var修饰)\n2.也可以显示的声明变量类型，如val a : Int = 10\n3.数据类型：\n\n函数1.标准形式：\nfun methodName(param1: Int, param2: Int):Int&#123;return 0&#125;\n\n2.语法糖：\n当一个函数只有一行代码时，可以直接将那行代码直接写在函数定义的尾部用等号连接\nfun largeNumber(num1: Int, num2: Int) = max(num1,num2)\n\n程序的逻辑控制if条件句1.写法和Java的一样\n2.和java不一样的点在于它可以有返回值，如：\nfun largeNumber(num1: Int, num2: Int) : Int&#123;    return if(num1 &gt; num2)&#123;        num1    &#125;else&#123;        num2    &#125;&#125;\n\n可以用语法糖简化为：\nfun largeNumber(num1: Int, num2: Int) = if(num1 &gt; num2) num1 else num2\n\n\n\nwhen条件句1.由这个例子说明：\nfun getScore(name:String)=if(name==&quot;Tom&quot;)&#123;    86&#125;else if (name==&quot;Jim&quot;)&#123;    77&#125;else if (name==&quot;Jack&quot;)&#123;    95&#125;else if (name==&quot;Lily&quot;)&#123;    100&#125;else&#123;    0&#125;\n\n这段显得冗杂可以用when简化\nfun getScore(name:String)=when(name)&#123;    &quot;Tom&quot;-&gt;86    &quot;Jim&quot;-&gt;77    &quot;Jack&quot;-&gt;95    &quot;Lily&quot;-&gt;100    else-&gt;0&#125;\n\n2.标准格式：\n匹配值 -&gt; { 执行逻辑 }（执行逻辑只有一行时括号可省）\n3.类型匹配：\nfun checkNumber(num:Number)=when(num)&#123;    is Int-&gt;println(&quot;number is Int&quot;)    is Double-&gt;println(&quot;number is Double&quot;)    else-&gt;println(&quot;number not support&quot;)&#125;\n\n4.不在when中传入参数：（用得少）\nfun getScore(name:String)=when&#123;   name == &quot;Tom&quot;-&gt;86   name == &quot;Jim&quot;-&gt;77   name ==  &quot;Jack&quot;-&gt;95   name ==  &quot;Lily&quot;-&gt;100    else-&gt;0&#125;\n\n5.有些情况必须用4中方法：\n假设所有名字以“Tom”开头的人分数只有86：\nfun getScore(name:String)=when&#123;   name.startsWith(&quot;Tom&quot;)-&gt;86   name == &quot;Jim&quot;-&gt;77   name ==  &quot;Jack&quot;-&gt;95   name ==  &quot;Lily&quot;-&gt;100    else-&gt;0&#125;\n\n\n\n循环语句1.while循环和之前学的一样不再赘述\n2.Kotlin中区间表示：\nval range = 0..10两端都是闭区间\nval range = 0 until 10左闭右开区间\nval range = 10 downTo 1降序区间两端都是闭区间\n3.step关键字相当于i++\n2.for-in循环：\nfor(i in 0..10)&#123;    println(i)&#125;for(i in 0 until 10 step 2)&#123;    println(i)&#125;for(i in 10 downTo 1)&#123;    println(i)&#125;\n\n\n\n\n面向对象编程类和对象创建方法和之前的一样，实例化有区别,去掉了new关键字：\nval p=Person()\n继承与构造函数1.开放继承权限(kotlin中非抽象类默认不可继承)，在类前加上open关键字即可\nopen class person&#123;...&#125;\n\n2.继承，关键字由之前的extends变为了冒号，例如：\nclass Student : Person()&#123;    var sno= &quot;&quot;    var grade=0&#125;\n\nPerson后有一个括号是因为子类构造函数必须调用父类的构造函数\n3.构造函数分为主构造函数和次构造函数：\n主构造函数(没有函数体，逻辑写在init中)：\nclass Student(val sno String,val grade :Int):Person()&#123;    init&#123;        println(sno)        println(grade)    &#125;&#125;\n\n继承来的数据不需要用val或var修饰\nclass Student(val sno :String,val grade :Int, name:String,age:Int):Person(name,age)&#123;&#125;\n\n次构造函数(几乎不会用到)\n当一个类既有主构造又有次构造函数，所有次构造函数都必须直接或间接调用主构造函数：\nclass Student(val sno :String,val grade :Int, name:String,age:Int):Person(name,age)&#123;    constructor(name:String,age:Int):this(&quot;&quot;,0,name,age)&#123;&#125;//直接调用主构造函数    constructor():this(&quot;&quot;,0)&#123;&#125;//间接调用主构造函数&#125;\n\n只有次构造而没有主构造时：\nclass Student:Person&#123;    constructor(name:String,age:Int):super(name,age)&#123;&#125;&#125;\n\n此时没有显式的定义主构造函数，又有次构造可以认为其没有主构造，既然没有主构造，那么Person类后也不需要加括号了\n接口1.接口和java也基本一样，接口中函数不要求有函数体\ninterface Study &#123;    fun readBooks()    fun doHomework()&#125;\n\n2.接口关键字也使用冒号\nclass Student(name:String,age:Int):Person(name,age),Study &#123;    override fun readBooks() &#123;        println(name+&quot; is reading!&quot;)    &#125;    override fun doHomework() &#123;        println(name+&quot; is doing homework&quot;)    &#125;&#125;\n\n调用如下：\nfun main()&#123;   val s=Student(&quot;Jack&quot; ,18)    doStudy(s)&#125;fun doStudy(study:Study)&#123;    study.readBooks()    study.doHomework()&#125;\n\n3.kotlin中特有的功能：允许对接口中定义的函数进行默认实现\ninterface Study &#123;    fun readBooks()    fun doHomework()&#123;        println(&quot;do homework default implementation.&quot;)    &#125;&#125;\n\n修饰符1.public:\n默认项，和java的一致\n2.private：\n只对当前类内部可见\n3.protected:\n只对当前类和子类可见\n4.internal:\n只对同一模块中的类可见\n\n数据类与单例类1.数据类:\n在class前加上data关键字\n2.单例类:\n作用：避免创建重复的对象\n用法：将class换成object即可\n调用：\nobject Singleton&#123;    fun singletonTest()&#123;        println(&quot;singletonTest is called&quot;)    &#125;&#125;fun main()&#123;       Singleton.singletonTest()&#125;\n\n\n集合的创建和遍历listOf(不可变集合)创建和遍历：\nval list= listOf(&quot;Apple&quot;,&quot;Banana&quot;,&quot;Pear&quot;)   for (fruit in list)&#123;       println(fruit)   &#125;\n\nmutableListOf(可变集合)创建和遍历：\nval list= *mutableListOf*(&quot;Apple&quot;,&quot;Banana&quot;,&quot;Pear&quot;)list.add(&quot;Watermeleon&quot;)for (fruit in list)&#123;    *println*(fruit)&#125;\n\nsetOf和mutableSetOf用法和listOf和mutableListOf一模一样，只是setOf和mutableSetOf中不能放重复元素\nMap集合(键值对形式)1.添加和读取数据用下标法\nval map=HashMap&lt;String,Int&gt;()map[&quot;Apple&quot;]=1//添加val number=map[&quot;Apple&quot;]//读取\n\n2.简化(使用mapOf和mutableMapOf):\nval map= mapOf(&quot;Apple&quot; to 1,&quot;Banana&quot; to 2,&quot;Oramge&quot; to 3)    for((fruit,number) in map)&#123;        println(&quot;fruit is &quot;+fruit+&quot;,number is ,&quot; +number)    &#125;\n\n\nLambda1.语法结构：\n{参数名1：参数类型，参数名2：参数类型  -&gt; 函数体}（函数体可以编写任一行代码，最后一行代码会自动作为返回值）\n2.一些简化点：（函数API实例说明）\nval maxLengthFruit = list.maxBy(&#123;fruit:String-&gt;fruit.length&#125;)\n\n(1)当Lambda参数是函数最后一个参数时可以将lambda表达式移到函数括号的外面\nval maxLengthFruit = list.maxBy()&#123;fruit:String-&gt;fruit.length&#125;\n\n(2)当Lambda参数是函数唯一一个参数时可以将函数的括号删掉\nval maxLengthFruit = list.maxBy&#123;fruit:String-&gt;fruit.length&#125;\n\n(3)因为Kotlin具有类型推到机制大多情况不需声明类型\nval maxLengthFruit = list.maxBy&#123;fruit-&gt;fruit.length&#125;\n\n(4)当表达式参数列表只有一个参数时，也可以不声明参数名，用it来代替\nval maxLengthFruit = list.maxBy&#123;it.length&#125;\n\n3.map函数(对集合元素映射转化)\nval list= listOf(&quot;Apple&quot;,&quot;Banana&quot;,&quot;Pear&quot;)val newList =list.map&#123;it.toUpperCase()&#125;for(fruit in newlist)&#123;    println(fruit)&#125;\n\n4.filter函数(过滤集合中的数据)\nval list= listOf(&quot;Apple&quot;,&quot;Banana&quot;,&quot;Pear&quot;)val newList =list.filter&#123;it.length&lt;=5&#125;//保留五个字母以内的水果                 .map&#123;it.toUpperCase()&#125;for(fruit in newlist)&#123;    println(fruit)&#125;\n\n这里先调用filter再调用map效率更高\n5.any和all函数\nany函数用来判断集合中是否至少存在一个元素满足指定条件\nall函数用来判断集合中是否所有元素都满足指定条件\nval list= listOf(&quot;Apple&quot;,&quot;Banana&quot;,&quot;Pear&quot;)val anyResult =list.any&#123;it.length&lt;=5&#125;val allResult =list.all&#123;it.length&lt;=5&#125;    println(&quot;anyResult is &quot;+anyResult+&quot;,allResult is &quot;+allResult)\n\n\nJava函数式API的使用1.使用前提：\nkotlin中调用一个java方法，并且该方法接收一个java单抽象方法接口参数，就可以使用函数式API(Java单抽象方法接口指的是接口中只有一个待实现的方法)\n2.实例说明：\n（1）Runnable实例kotlin形式\nThread(object:Runnable&#123;    override fun run()&#123;        println(&quot;Thread is running&quot;)    &#125;&#125;).start()\n\n(2)只有一个方法可以将方法名省去\nThread(Runnable&#123;        println(&quot;Thread is running&quot;)&#125;).start()\n\n(3)如果一个java方法参数列表中有且仅有一个java单抽象方法接口参数，可以将接口名省去\nThread(&#123;        println(&quot;Thread is running&quot;)&#125;).start()\n\n(4)根据lambda表达式可以更精简为\nThread&#123;      println(&quot;Thread is running&quot;)&#125;.start()\n\n\n空指针检查kotlin将空指针判定提前到了编译环节\n可空类型系统在类名的后面加一个问号表示可为空的类型\n如Int表示不可为空的整型，Int？表示可为空的整型\n判空辅助工具1.”?.”操作符:\n当对象不为空时正常调用，为空时啥也不干\n2.“？:”操作符：\n操作符左右两边均接收一个表达式，如果左边表达式不为空就返回左边否则返回右边\n以上两种方法结合使用：\nfun getTextLength(text:String?)=text?.length?:0\n\n3.空指针检查机制可能出问题：\n可以使用非空断言工具，在对象后面加**“！！”**，使其强行通过编译(写法有风险，谨慎使用)\nval upperCase=content!!.toUpperCase()\n\n4.辅助工具—-let：(函数)(let可以处理全局判空问题而if无法做到)\n（1）形式：\nobj.let&#123; obj2-&gt;//编写具体的逻辑&#125;\n\n其中obj2和obj是一个对象，防止变量重名故改为obj2\n(2)优化：\n？.和let结合使用\nfun doStudy(study:Study?)&#123;      study?.let&#123;          stu-&gt;          stu.readBooks()          stu.doHomeWork()      &#125;&#125;\n\n可以简化为\nfun doStudy(study:Study?)&#123;      study?.let&#123;          it.readBooks()          it.doHomeWork()      &#125;&#125;\n\n\n\n\nKotlin一些小技巧字符串内嵌表达式可以用**${}**语法结构来代替加号连接符\nprintln(&quot;hello,$&#123;obj.name&#125;.nice to meet you!&quot;)\n\n如果表达式仅有一个变量时还可以将大括号省去\n函数的参数默认值不需要一一对应，可以使用键值对传参\nfun printParams(num:Int=100,str:String)&#123;//num:Int=100即设定了默认值    println(&quot;num is $num，str is $str&quot;)&#125;fun main()&#123;    printParams(str=&quot;world&quot;)&#125;\n\n下划线写法在一些方法中如果只有部分参数使用到，未使用的参数可以用下划线代替\n\naskotlin中类型强制转换时使用的关键字\n\n内部类用inner class关键字来定义内部类\n\n","categories":["Kotlin"]},{"title":"Kotlin高阶函数的应用","url":"/posts/Kotlin%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/","content":"简化SharedPreferences的用法\n通过扩展函数方式像其中添加open函数\n\n接收函数类型\nfun SharedPreferences.open(block:SharedPreferences.Editor.()-&gt;Unit)&#123;    val editor=edit()    editor.block()    editor.apply()&#125;\n\n//调用getSharedPreferences(&quot;data&quot;,Context.MODE_PRIVATE).open&#123;    putString(&quot;name&quot;,&quot;Tom&quot;)    putInt(&quot;age&quot;,19)    putBoolean(&quot;married&quot;,false)&#125;\n\nAndroid Studio自带扩展可以直接使用：\ngetSharedPreferences(&quot;data&quot;,Context.MODE_PRIVATE).edit&#123;    putString(&quot;name&quot;,&quot;Tom&quot;)    putInt(&quot;age&quot;,19)    putBoolean(&quot;married&quot;,false)&#125;\n\n\n简化ContentValues的用法\n定义cvOf方法\n\n获取ContentValues对象\n\n遍历pairs列表\n\n利用when语句意义判断数值类型\n**varage关键字：**对应java的可变参数列表\nPair：键值对数据结构，由于数值类型多所以指定为Any?相当于java中的Object\nfun cvOf(vararg pairs:Pair&lt;String,Any?&gt;):ContentValues&#123;    val cv=ContentValues()    for(pair in pairs)&#123;        val key=pair.first        val value=pair.second        when(value)&#123;            is Int-&gt;cv.put(key, value)            is Long-&gt;cv.put(key, value)            is Short-&gt;cv.put(key, value)            is Float-&gt;cv.put(key, value)            is Double-&gt;cv.put(key, value)            is Boolean-&gt;cv.put(key, value)            is String-&gt;cv.put(key, value)            is Byte-&gt;cv.put(key, value)            is ByteArray-&gt;cv.put(key, value)            null-&gt;cv.putNull(key)        &#125;    &#125;    return cv&#125;\n\n//调用val values=cvOf(&quot;name&quot; to &quot;Game of Thrones&quot;,&quot;author&quot; to &quot;George Martin&quot;,&quot;pages&quot; to 720,&quot;price&quot; to 20.85)db.insert(&quot;Book&quot;,null,values)\n\n利用apply简化\nfun cvOf(vararg pairs:Pair&lt;String,Any?&gt;)=ContentValues().apply&#123;    for(pair in pairs)&#123;        val key=pair.first        val value=pair.second        when(value)&#123;            is Int-&gt;put(key, value)            is Long-&gt;put(key, value)            is Short-&gt;put(key, value)            is Float-&gt;put(key, value)            is Double-&gt;put(key, value)            is Boolean-&gt;put(key, value)            is String-&gt;put(key, value)            is Byte-&gt;put(key, value)            is ByteArray-&gt;put(key, value)            null-&gt;putNull(key)        &#125;    &#125;&#125;\n\nKTX库提供同样功能的contentValuesOf方法\nval values=contentValuesOf(&quot;name&quot; to &quot;Game of Thrones&quot;,&quot;author&quot; to &quot;George Martin&quot;,&quot;pages&quot; to 720,&quot;price&quot; to 20.85)db.insert(&quot;Book&quot;,null,values)\n\n\n","categories":["Kotlin"]},{"title":"SQL函数篇","url":"/posts/SQL%E5%87%BD%E6%95%B0%E7%AF%87/","content":"字符串函数\n数值函数\n日期函数\n流程函数\n\n","categories":["数据库(SQL)"]},{"title":"SQL多表查询","url":"/posts/SQL%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/","content":"多表关系\n一对多\n\n\n多对多\n\n\n一对一\n\n\n\n\n多表查询概述\n笛卡尔积\n在数学中，两个集合A,B的所有组合情况(多表查询中，需要消除无效的笛卡尔积)\n\n多表查询分类\n\n\n\n\n内连接\n\n外连接\n\n自连接\n\n联合查询\n\n子查询概述\n\n标量子查询\n\n列子查询\n\n行子查询\n\n表子查询\n\n","categories":["数据库(SQL)"]},{"title":"SQL基础篇","url":"/posts/SQL%E5%9F%BA%E7%A1%80%E7%AF%87/","content":"SQL通用语法及其分类通用语法\n分类\n\nDDL数据库操作\n查询\nshow databases;#查询所有数据库select database();#查询当前数据库\n\n创建\ncreate database [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排列规则];\n\n删除\nDROP DATABASE [IF EXISTS] 数据库名;\n\n使用\nUSE 数据库名;\n\n表操作\n查询\nSHOW TABLES;#查询当前数据库所有表格DESC 表名;#查询表结构SHOW CREATE TABLE 表名;#查询指定表的建表语句\n\n创建\nCREATE TABLE 表名(\t字段1 字段1类型[COMMENT 字段1注释]    字段2 字段2类型[COMMENT 字段2注释]    字段3 字段3类型[COMMENT 字段3注释]    . . . . . . .    字段n 字段n类型[COMMENT 字段n注释])[COMMENT 表注释]\n\n修改\nALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];#添加字段ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);#修改数据类型ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];#修改字段名和字段类型ALTER TABLE 表名 RENAME TO 新表名;#修改表名\n\n删除\nalter table 表名 drop 字段名;#删除字段drop table [if exists] 表名;#删除表truncate table 表名;#删除指定表，并重新创建该表\n\n数据类型\n字符串类型\n\n\n数值类型\n\n\n日期类型\n\n\n\n\nDML添加数据\n修改数据\n删除数据\n\nDQL通用语法\n基本查询\n条件查询\n聚合函数\n分组查询\n排序查询\n分页查询\n执行顺序\n\nDCL用户管理\n权限控制\n\n\n","categories":["数据库(SQL)"]},{"title":"SQL字段约束","url":"/posts/SQL%E5%AD%97%E6%AE%B5%E7%BA%A6%E6%9D%9F/","content":"概述\n外键约束\n外键删除更新行为\n\n","categories":["数据库(SQL)"]},{"title":"Material Design(Java)","url":"/posts/Material-Design/","content":"Toolbar1.设置主题为Theme.AppCompat.Light.NoActionBar(淡色主题)\n2.在layout中使用Toolbar\n3..在Mainactivity获取toolbar实例\n4.设置menu并在Mainactivity中使用\n\n&lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;    &lt;!-- Base application theme. --&gt;    &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;        &lt;!-- Customize your light theme here. --&gt;        &lt;item name=&quot;colorPrimary&quot;&gt;@color/black&lt;/item&gt;        &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/black&lt;/item&gt;        &lt;item name=&quot;colorAccent&quot;&gt;@color/white&lt;/item&gt;        &lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/black&lt;/item&gt;        &lt;item name=&quot;android:windowBackground&quot;&gt;@color/white&lt;/item&gt;        &lt;item name=&quot;android:navigationBarColor&quot;&gt;@color/black&lt;/item&gt;    &lt;/style&gt;&lt;/resources&gt;\n\n&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;androidx.appcompat.widget.Toolbar        android:id=&quot;@+id/toolbar&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;?attr/actionBarSize&quot;        android:background=&quot;?attr/colorPrimary&quot;        android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;       app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt;&lt;/FrameLayout&gt;\n\n&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;    &lt;item        android:id=&quot;@+id/backup&quot;        android:icon=&quot;@drawable/ic_launcher_background&quot;        android:title=&quot;Backup&quot;        app:showAsAction=&quot;always&quot;/&gt;    &lt;item        android:id=&quot;@+id/delete&quot;        android:icon=&quot;@drawable/ic_launcher_background&quot;        android:title=&quot;Delete&quot;        app:showAsAction=&quot;ifRoom&quot;/&gt;    &lt;item        android:id=&quot;@+id/settings&quot;        android:icon=&quot;@drawable/ic_launcher_background&quot;        android:title=&quot;Settings&quot;        app:showAsAction=&quot;never&quot;/&gt;&lt;/menu&gt;\n\npublic class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);        setSupportActionBar(toolbar);    &#125;    public boolean onCreateOptionsMenu(Menu menu)&#123;        getMenuInflater().inflate(R.menu.toolbar,menu);        return true;    &#125;    @Override    public boolean onOptionsItemSelected(@NonNull MenuItem item) &#123;        if(item.getItemId()==R.id.backup)&#123;            Toast.makeText(this, &quot;You clicked Backup&quot;, Toast.LENGTH_SHORT).show();        &#125; else if (item.getItemId()==R.id.delete) &#123;            Toast.makeText(this, &quot;You clicked Delete&quot;, Toast.LENGTH_SHORT).show();        &#125;else&#123;            Toast.makeText(this, &quot;You clicked Settings&quot;, Toast.LENGTH_SHORT).show();        &#125;        return  true;    &#125;&#125;\n\n\n\n\n滑动菜单DrawerLayout1.修改布局中代码，使用DrawerLayout布局\n2.获取DrawerLayout和ActionBar的实例\n3.利用ActionBar的方法让导航按钮显示\n4.对按钮的点击事件进行处理\n&lt;androidx.drawerlayout.widget.DrawerLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:id=&quot;@+id/drawer_layout&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;FrameLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;androidx.appcompat.widget.Toolbar            android:id=&quot;@+id/toolbar&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;?attr/actionBarSize&quot;            android:background=&quot;?attr/colorPrimary&quot;            android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;            app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt;    &lt;/FrameLayout&gt;    &lt;TextView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:layout_gravity=&quot;start&quot;        android:text=&quot;This is menu&quot;        android:textSize=&quot;30sp&quot;        android:background=&quot;#FFF&quot;/&gt;&lt;/androidx.drawerlayout.widget.DrawerLayout&gt;\n\nprivate DrawerLayout mDrawerLayout; mDrawerLayout=(DrawerLayout) findViewById(R.id.drawer_layout);        ActionBar actionBar=getSupportActionBar();        if(actionBar!=null)&#123;            actionBar.setDisplayHomeAsUpEnabled(true);            actionBar.setHomeAsUpIndicator(R.drawable.ic_launcher_foreground);        &#125;\n\nif(item.getItemId()==android.R.id.home)&#123;            mDrawerLayout.openDrawer(GravityCompat.START);        &#125;\n\nNavigationView1.添加依赖库\n2.准备menu和headerLayout\n3.在activity_main.xml布局中使用NavigationView控件\n4.创建点击事件\nimplementation (&quot;com.google.android.material:material:1.9.0&quot;)//design support库    implementation (&quot;de.hdodenhof:circleimageview:3.1.0&quot;)\n\n&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    //group表示一个组，single表示只能单选    &lt;group android:checkableBehavior=&quot;single&quot;&gt;        &lt;item            android:id=&quot;@+id/nav_call&quot;            android:icon=&quot;@drawable/ic_launcher_background&quot;            android:title=&quot;Call&quot;/&gt;        &lt;item            android:id=&quot;@+id/nav_friends&quot;            android:icon=&quot;@drawable/ic_launcher_background&quot;            android:title=&quot;Friends&quot;/&gt;        &lt;item            android:id=&quot;@+id/nav_location&quot;            android:icon=&quot;@drawable/ic_launcher_background&quot;            android:title=&quot;Location&quot;/&gt;        &lt;item            android:id=&quot;@+id/nav_mail&quot;            android:icon=&quot;@drawable/ic_launcher_background&quot;            android:title=&quot;Mail&quot;/&gt;        &lt;item            android:id=&quot;@+id/nav_task&quot;            android:icon=&quot;@drawable/ic_launcher_background&quot;            android:title=&quot;Tasks&quot;/&gt;    &lt;/group&gt;&lt;/menu&gt;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;180dp&quot;    android:padding=&quot;10dp&quot;    android:background=&quot;?attr/colorPrimary&quot;&gt;        //将图形圆形化    &lt;de.hdodenhof.circleimageview.CircleImageView        android:id=&quot;@+id/icon_image&quot;        android:layout_width=&quot;70dp&quot;        android:layout_height=&quot;70dp&quot;        android:src=&quot;@drawable/ic_launcher_background&quot;        android:layout_centerInParent=&quot;true&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/username&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_alignParentBottom=&quot;true&quot;        android:text=&quot;1234567890@qq.com&quot;        android:textColor=&quot;#FFF&quot;        android:textSize=&quot;14sp&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/mail&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_above=&quot;@+id/username&quot;        android:text=&quot;Klet&quot;        android:textColor=&quot;#FFF&quot;        android:textSize=&quot;14sp&quot;/&gt;&lt;/RelativeLayout&gt;\n\n&lt;com.google.android.material.navigation.NavigationView        android:id=&quot;@+id/nav_view&quot;         android:layout_height=&quot;match_parent&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_gravity=&quot;start&quot;        app:menu=&quot;@menu/nav_menu&quot;        app:headerLayout=&quot;@layout/nav_header&quot;/&gt;\n\n//获取实例        NavigationView navView=(NavigationView)findViewById(R.id.nav_view); //设置默认选中        navView.setCheckedItem(R.id.nav_call);        //设置点击事件        navView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123;            @Override            public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123;                mDrawerLayout.closeDrawers();                return true;            &#125;        &#125;);\n\n\n\n\n悬浮按钮和可交互显示FloatingActionButton1.在布局中添加控件\n2.设置点击事件\n&lt;com.google.android.material.floatingactionbutton.FloatingActionButton            android:id=&quot;@+id/fab&quot;             android:layout_height=&quot;wrap_content&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_gravity=&quot;bottom|end&quot;            android:layout_margin=&quot;16dp&quot;            android:src=&quot;@drawable/ic_done&quot;            app:elevation=&quot;8dp&quot;//设置悬浮高度            /&gt;\n\nFloatingActionButton fab=(FloatingActionButton) findViewById(R.id.fab);        fab.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                Toast.makeText(MainActivity.this, &quot;FAB clicked&quot;, Toast.LENGTH_SHORT).show();            &#125;        &#125;);\n\n\n\nSnackbar(可交互的Toast)1.用make获取对象\n2.setAction设置动作\n3.用show将其显示\nSnackbar.make(view,&quot;Data Delete&quot;,Snackbar.LENGTH_SHORT)                        .setAction(&quot;UOdo&quot;, new View.OnClickListener() &#123;                            @Override                            public void onClick(View view) &#123;                                Toast.makeText(MainActivity.this, &quot;Data Restored&quot;, Toast.LENGTH_SHORT).show();                            &#125;                        &#125;).show();\n\n\n\nCoordinatorLayout(加强版FrameLayout)可以监听到所有子控件的各种事件，然后自动帮助我们做出最为合理的响应，就是加强版的FrameLayout\n&lt;androidx.coordinatorlayout.widget.CoordinatorLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;androidx.appcompat.widget.Toolbar            android:id=&quot;@+id/toolbar&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;?attr/actionBarSize&quot;            android:background=&quot;?attr/colorPrimary&quot;            android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;            app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt;        &lt;com.google.android.material.floatingactionbutton.FloatingActionButton            android:id=&quot;@+id/fab&quot;             android:layout_height=&quot;wrap_content&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_gravity=&quot;bottom|end&quot;            android:layout_margin=&quot;16dp&quot;            android:src=&quot;@drawable/ic_done&quot;            app:elevation=&quot;8dp&quot;            /&gt;    &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt;\n\n\n\n\n卡片式布局CardView（是一个FrameLayout)RecyclerView和CardView混合使用\n1.添加依赖\n2.在布局中添加RecyclerView并建立Fruit类，子项布局和适配器\n3.应用recyclerView\nimplementation (&quot;androidx.cardview:cardview:1.0.0&quot;)//cardView依赖    implementation (&quot;androidx.recyclerview:recyclerview:1.3.2&quot;)//recyclerView依赖    implementation (&quot;com.github.bumptech.glide:glide:4.16.0&quot;)//Glide依赖，强大的图片加载库\n\n&lt;androidx.cardview.widget.CardView    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_margin=&quot;5dp&quot;    app:cardCornerRadius=&quot;4dp&quot;&gt;    &lt;LinearLayout        android:orientation=&quot;vertical&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;ImageView            android:id=&quot;@+id/fruit_image&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;100dp&quot;                //指定图片的缩放模式            android:scaleType=&quot;centerCrop&quot;/&gt;        &lt;TextView            android:id=&quot;@+id/fruit_text&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_gravity=&quot;center_horizontal&quot;            android:layout_margin=&quot;5dp&quot;            android:textSize=&quot;16sp&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/androidx.cardview.widget.CardView&gt;\n\npublic class Fruit &#123;    private String name;    private  int imageId;    public Fruit(String name, int imageId) &#123;        this.name = name;        this.imageId = imageId;    &#125;    public String getName() &#123;        return name;    &#125;    public int getImageId() &#123;        return imageId;    &#125;&#125;\n\npublic class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123;    private Context mContext;    private List&lt;Fruit&gt;mFruitList;    static class ViewHolder extends RecyclerView.ViewHolder&#123;        CardView cardView;        ImageView fruitImage;        TextView fruitName;        public ViewHolder(View view)&#123;            super(view);            cardView=(CardView) view;            fruitImage=(ImageView) view.findViewById(R.id.fruit_image);            fruitName=(TextView) view.findViewById(R.id.fruit_text);        &#125;    &#125;public FruitAdapter(List&lt;Fruit&gt;fruitList)&#123;        mFruitList=fruitList;&#125;    @NonNull    @Override    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        if(mContext==null)&#123;            mContext=parent.getContext();        &#125;        View view= LayoutInflater.from(mContext).inflate(R.layout.fruit_item,parent,false);        return new ViewHolder(view);    &#125;    @Override    public void onBindViewHolder(@NonNull ViewHolder holder, int position) &#123;            Fruit fruit=mFruitList.get(position);            holder.fruitName.setText(fruit.getName());        Glide.with(mContext).load(fruit.getImageId()).into(holder.fruitImage);    &#125;    @Override    public int getItemCount() &#123;        return mFruitList.size();    &#125;&#125;\n\nprivate Fruit[] fruits=&#123;new Fruit(&quot;Apple&quot;,R.drawable.apple),new Fruit(&quot;Banana&quot;,R.drawable.banana)   ,new Fruit(&quot;Orange&quot;,R.drawable.orange),new Fruit(&quot;Watermelon&quot;,R.drawable.watermelon)&#125;;   private List&lt;Fruit&gt;fruitList=new ArrayList&lt;&gt;();   private FruitAdapter adapter;@Override   protected void onCreate(Bundle savedInstanceState) &#123;       super.onCreate(savedInstanceState);       setContentView(R.layout.activity_main);        inits();       RecyclerView recyclerView=(RecyclerView) findViewById(R.id.recycler_view);       //接收两个参数，第一个是Context第二个是列数       GridLayoutManager layoutManager=new GridLayoutManager(this,2);       recyclerView.setLayoutManager(layoutManager);       adapter=new FruitAdapter(fruitList);       recyclerView.setAdapter(adapter);   &#125; private void inits()&#123;       fruitList.clear();       for(int i=0;i&lt;50;i++)&#123;           Random random=new Random();           int index=random.nextInt(fruits.length);           fruitList.add(fruits[index]);       &#125;   &#125;\n\nAppBarLayout用来解决RecyclerView遮挡ToolBar问题\n1.将ToolBar嵌入到AppBarLayout中\n2.给RecyclerView添加一个布局行为\n3.在ToolBar中添加app：layout_scrollFlags属性\n&lt;androidx.drawerlayout.widget.DrawerLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:id=&quot;@+id/drawer_layout&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;androidx.coordinatorlayout.widget.CoordinatorLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;           //使用AppBarLayout        &lt;com.google.android.material.appbar.AppBarLayout            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;androidx.appcompat.widget.Toolbar                android:id=&quot;@+id/toolbar&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;?attr/actionBarSize&quot;                android:background=&quot;?attr/colorPrimary&quot;                android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;                app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;                    //scroll表示向上滚动ToolBar隐藏，enterAlways表示向下滚动ToolBar重新显示snap表示还没完全显示或隐藏时                         根据滚动的距离自动选择隐藏还是显示                app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot;/&gt;        &lt;/com.google.android.material.appbar.AppBarLayout&gt;        &lt;androidx.recyclerview.widget.RecyclerView            android:id=&quot;@+id/recycler_view&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;                //RecyclerView添加一个布局行为            app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;/&gt;        &lt;com.google.android.material.floatingactionbutton.FloatingActionButton            android:id=&quot;@+id/fab&quot;             android:layout_height=&quot;wrap_content&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_gravity=&quot;bottom|end&quot;            android:layout_margin=&quot;16dp&quot;            android:src=&quot;@drawable/ic_done&quot;            app:elevation=&quot;8dp&quot;            /&gt;    &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt;    &lt;com.google.android.material.navigation.NavigationView        android:id=&quot;@+id/nav_view&quot;         android:layout_height=&quot;match_parent&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_gravity=&quot;start&quot;        app:menu=&quot;@menu/nav_menu&quot;        app:headerLayout=&quot;@layout/nav_header&quot;/&gt;&lt;/androidx.drawerlayout.widget.DrawerLayout&gt;\n\n\n\n\n下拉刷新利用SwipeRefreshLayout\n1.将RecyclerView嵌入到SwipeRefreshLayout中，并将RecyclerView中的布局行为移到SwipeRefreshLayout中\n2.在主活动中处理具体的刷新逻辑\n&lt;androidx.swiperefreshlayout.widget.SwipeRefreshLayout            android:id=&quot;@+id/swipe_refresh&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;            &gt;            &lt;androidx.recyclerview.widget.RecyclerView                android:id=&quot;@+id/recycler_view&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;match_parent&quot; /&gt;        &lt;/androidx.swiperefreshlayout.widget.SwipeRefreshLayout&gt;\n\n private SwipeRefreshLayout swipeRefreshLayout;@Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);    \t  //获取实例        swipeRefreshLayout=(SwipeRefreshLayout) findViewById(R.id.swipe_refresh);        //设置刷新进度条的颜色        swipeRefreshLayout.setColorSchemeResources(R.color.black);        //设置下拉刷新的监听器        swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123;            @Override            public void onRefresh() &#123;                refreshFruits();            &#125;        &#125;);    &#125; private void refreshFruits() &#123;        //开启一个线程        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                try&#123;                    //将线程沉睡两秒钟(因为本地刷新速度很快，如果不沉睡刷新立刻就结束了)                    Thread.sleep(2000);                &#125;catch(InterruptedException e)&#123;                    e.printStackTrace();                &#125;                //将线程切换回主线程                runOnUiThread(new Runnable() &#123;                    @Override                    public void run() &#123;                        //初始化                        inits();                        //更新                        adapter.notifyDataSetChanged();                        //用于表示刷新事件结束，并隐藏进度条                        swipeRefreshLayout.setRefreshing(false);                    &#125;                &#125;);            &#125;        &#125;).start();    &#125;\n\n\n\n\n可折叠式标题栏CollapsingToolbarLayoutCollapsingToolbarLayout不能独立存在，他只能作为AppBarLayout的直接子布局使用，AppBarLayout又必须是CoordinatorLayout的子布局\n1.使用CoordinatorLayout作为最外层布局，里面嵌套一个AppBarLayout，再嵌套一个CollapsingToolbarLayout\n2.在CollapsingToolbarLayout中添加一个ImageView和Toolbar(这个高级标题栏由图片和普通标题栏构成)\n3.在最外层布局中使用NestedScrollView(和AppBarLayout同级)\n4.NestedScrollView内部只允许一个直接子布局，故先嵌套一个LinearLayout\n5.在其中嵌入卡片式布局\n6.可以再添加一个FloatingActionButton\n7.接着在FruitActivity中编写功能逻辑\n8.为RecyclerView设置点击事件\n&lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.FruitActivity&quot;&gt;    &lt;com.google.android.material.appbar.AppBarLayout        android:id=&quot;@+id/appBar&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;250dp&quot;&gt;       &lt;com.google.android.material.appbar.CollapsingToolbarLayout           android:id=&quot;@+id/collapsing_toolbar&quot;           android:layout_width=&quot;match_parent&quot;           android:layout_height=&quot;match_parent&quot;           android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;           app:contentScrim=&quot;?attr/colorPrimary&quot;           app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;           &lt;ImageView               android:id=&quot;@+id/fruit_image_view&quot;               android:layout_width=&quot;match_parent&quot;               android:layout_height=&quot;match_parent&quot;               android:scaleType=&quot;centerCrop&quot;               app:layout_collapseMode=&quot;parallax&quot;/&gt;           &lt;androidx.appcompat.widget.Toolbar               android:id=&quot;@+id/toolbar&quot;               android:layout_width=&quot;match_parent&quot;               android:layout_height=&quot;?attr/actionBarSize&quot;               app:layout_collapseMode=&quot;pin&quot;/&gt;       &lt;/com.google.android.material.appbar.CollapsingToolbarLayout&gt;    &lt;/com.google.android.material.appbar.AppBarLayout&gt;    &lt;androidx.core.widget.NestedScrollView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;vertical&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;androidx.cardview.widget.CardView                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;                android:layout_marginBottom=&quot;15dp&quot;                android:layout_marginLeft=&quot;15dp&quot;                android:layout_marginRight=&quot;15dp&quot;                android:layout_marginTop=&quot;35dp&quot;                app:cardCornerRadius=&quot;4dp&quot;&gt;                &lt;TextView                    android:id=&quot;@+id/fruit_content_text&quot;                    android:layout_width=&quot;wrap_content&quot;                    android:layout_height=&quot;wrap_content&quot;                    android:layout_margin=&quot;10dp&quot;/&gt;            &lt;/androidx.cardview.widget.CardView&gt;        &lt;/LinearLayout&gt;    &lt;/androidx.core.widget.NestedScrollView&gt;    &lt;com.google.android.material.floatingactionbutton.FloatingActionButton        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;16sp&quot;        android:src=&quot;@drawable/ic_done&quot;        app:layout_anchor=&quot;@id/appBar&quot;        app:layout_anchorGravity=&quot;bottom|end&quot;/&gt;&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt;\n\npublic class FruitActivity extends AppCompatActivity &#123;public  static final String FRUIT_NAME=&quot;fruit_name&quot;;    public  static final String FRUIT_IMAGE_ID=&quot;fruit_image_id&quot;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_fruit);        //通过Intent获取水果名字和图片        Intent intent=getIntent();        String fruitName=intent.getStringExtra(FRUIT_NAME);        int fruitImageId=intent.getIntExtra(FRUIT_IMAGE_ID,0);        //获取Toolbar实例        Toolbar toolbar=(Toolbar) findViewById(R.id.toolbar);        //获取CollapsingToolbarLayout实例        CollapsingToolbarLayout collapsingToolbarLayout=(CollapsingToolbarLayout) findViewById(R.id.collapsing_toolbar);        //获取ImageView和TextView实例        ImageView fruitImageView=(ImageView) findViewById(R.id.fruit_image_view);        TextView fruitContentText=(TextView) findViewById(R.id.fruit_content_text);        //将toolbar实例传入        setSupportActionBar(toolbar);        //启用HomeAsUp按钮        ActionBar actionBar=getSupportActionBar();        if(actionBar!=null)&#123;            actionBar.setDisplayHomeAsUpEnabled(true);        &#125;        //设置标题        collapsingToolbarLayout.setTitle(fruitName);        //设置图形        Glide.with(this).load(fruitImageId).into(fruitImageView);        String fruitContent=generateFruitContent(fruitName);        fruitContentText.setText(fruitContent);    &#125;    private String generateFruitContent(String fruitName) &#123;        StringBuilder fruitContent=new StringBuilder();        for(int i=0;i&lt;500;i++)&#123;            fruitContent.append(fruitName);        &#125;        return fruitContent.toString();    &#125;    @Override    public boolean onOptionsItemSelected(@NonNull MenuItem item) &#123;        if(item.getItemId()==android.R.id.home)&#123;            finish();            return true;        &#125;        return super.onOptionsItemSelected(item);    &#125;&#125;\n\n@NonNull   @Override   public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;       if(mContext==null)&#123;           mContext=parent.getContext();       &#125;       View view= LayoutInflater.from(mContext).inflate(R.layout.fruit_item,parent,false);       final ViewHolder holder=new ViewHolder(view);       holder.cardView.setOnClickListener(new View.OnClickListener() &#123;           @Override           public void onClick(View view) &#123;               int position=holder.getAdapterPosition();               Fruit fruit=mFruitList.get(position);               Intent intent=new Intent(mContext, FruitActivity.class);               intent.putExtra(FruitActivity.FRUIT_NAME,fruit.getName());               intent.putExtra(FruitActivity.FRUIT_IMAGE_ID,fruit.getImageId());               mContext.startActivity(intent);           &#125;       &#125;);       return holder;   &#125;\n\n充分利用系统状态栏空间让背景图和系统状态栏融合\n1.将ImageView及其所有父布局使用android:fitsSystemWindows&#x3D;”true”\n2.使用android:statusBarColor属性将主题状态栏颜色设为透明(该属性是API21之后才有的，故需要新建一个values-v21目录并对其进行编写)\n3.对values中的theme文件进行修改\n4.在Manifest.xml中对活动主题进行修改\n&lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.FruitActivity&quot;    android:fitsSystemWindows=&quot;true&quot;&gt;    &lt;com.google.android.material.appbar.AppBarLayout        android:id=&quot;@+id/appBar&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;250dp&quot;        android:fitsSystemWindows=&quot;true&quot;&gt;       &lt;com.google.android.material.appbar.CollapsingToolbarLayout           android:id=&quot;@+id/collapsing_toolbar&quot;           android:layout_width=&quot;match_parent&quot;           android:layout_height=&quot;match_parent&quot;           android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;           app:contentScrim=&quot;?attr/colorPrimary&quot;           app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;           android:fitsSystemWindows=&quot;true&quot;&gt;           &lt;ImageView               android:id=&quot;@+id/fruit_image_view&quot;               android:layout_width=&quot;match_parent&quot;               android:layout_height=&quot;match_parent&quot;               android:scaleType=&quot;centerCrop&quot;               app:layout_collapseMode=&quot;parallax&quot;               android:fitsSystemWindows=&quot;true&quot;/&gt;\n\n&lt;resources&gt;    &lt;style name=&quot;FruitActivityTheme&quot; parent=&quot;AppTheme&quot;&gt;        &lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/transparent&lt;/item&gt;    &lt;/style&gt;&lt;/resources&gt;\n\n&lt;style name=&quot;FruitActivityTheme&quot; parent=&quot;AppTheme&quot;&gt;   &lt;/style&gt;\n\n&lt;activity            android:name=&quot;.FruitActivity&quot;            android:theme=&quot;@style/FruitActivityTheme&quot;            android:exported=&quot;false&quot; /&gt;\n\n\n","categories":["Android(Java版)"]},{"title":"Service(Kotlin)","url":"/posts/Service-Kotlin/","content":"多线程编程线程的四种形式\nclass MyThread:Thread()&#123;    override fun run()&#123;        //编写具体逻辑    &#125;&#125;//启动MyThread.start()\n\nclass MyThread:Runnable&#123;    override fun run()&#123;        //编写具体逻辑    &#125;&#125;//启动val myThread=MyThread()Thread(myThread).start()\n\nThread&#123;    //编写具体逻辑&#125;.start()\n\nthread&#123;    //编写具体逻辑&#125;\n\n最后一种是Kotlin内置的顶层函数，更加简单方便\n\n\n在子线程中更新UI\n定义一个整型变量表示更新UI的动作\n新增一个Handler对象，重写父类handleMessage()方法，在这里对UI进行具体操作\n开启子线程\n创建Message对象\n指定what字段值\n调用sendMessage()方法发送Message\n\n解析异步消息处理机制\n\n使用AsyncTask1.创建一个子类去继承它，需要传入三个参数如下\nParams：在后台任务中使用\nProgress：可以作为进度单位\nResult：返回值类型\n2.重写父类方法如下：\nonPreExecute():界面上的初始化操作\ndoInBackground(Params…):所有代码都在子线程中运行，在这里处理耗时任务\nonProgressUpdate(Progress…):对UI进行操作\nonPostExecute(Result):后台任务执行完毕并通过return语句返回时，这个方法被调用\n3.启动任务\nDownloadTask().execute()\n\nService基本用法\n定义service，直接用AndroidStudio系统新建\n利用Intent启动和停止Service\n\nclass MyService : Service() &#123;    override fun onBind(intent: Intent): IBinder &#123;    &#125;    override fun onCreate() &#123;        super.onCreate()        Log.d(&quot;MyService&quot;, &quot;onCreate: &quot;)        &#125;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int &#123;        Log.d(&quot;MyService&quot;, &quot;onStartCommand: &quot;)        return super.onStartCommand(intent, flags, startId)    &#125;    override fun onDestroy() &#123;        Log.d(&quot;MyService&quot;, &quot;onDestroy: &quot;)        super.onDestroy()    &#125;&#125;\n\nbinding.start.setOnClickListener &#123;         val intent=Intent(this,MyService::class.java)         //启动服务         startService(intent)     &#125;     binding.stop.setOnClickListener &#123;         val intent=Intent(this,MyService::class.java)         //停止服务         stopService(intent)     &#125;\n\nActivity和Service进行通信拿下载功能举例\nService中提供一个下载功能，Activity中可以决定何时开始下载以及随时查看下载进度\nprivate val mBinder=DownloadBinder()   class DownloadBinder:Binder()&#123;       fun startDownload()&#123;           Log.d(&quot;MyService&quot;, &quot;startDownload: &quot;)       &#125;       fun getProgress():Int&#123;           Log.d(&quot;MyService&quot;, &quot;getProgress: &quot;)           return 0       &#125;   &#125;   override fun onBind(intent: Intent): IBinder &#123;       return mBinder   &#125;\n\n创建ServiceConnection的匿名类实现\n\n重写父类的两个方法\n\n利用intent和bindService进行绑定\n\n利用unbindService()方法解绑\nlateinit var downloadBinder:MyService.DownloadBinder    private val connection=object :ServiceConnection&#123;        //成功绑定时使用        override fun onServiceConnected(name: ComponentName?, service: IBinder?) &#123;            downloadBinder=service as MyService.DownloadBinder            downloadBinder.startDownload()            downloadBinder.getProgress()        &#125;        //Service创建进程崩溃或被杀掉时调用        override fun onServiceDisconnected(name: ComponentName?) &#123;            TODO(&quot;Not yet implemented&quot;)        &#125;    &#125;override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        enableEdgeToEdge()        binding=ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) &#123; v, insets -&gt;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)            insets        &#125;        binding.bind.setOnClickListener &#123;            val intent=Intent(this,MyService::class.java)            //绑定Service            bindService(intent,connection, Context.BIND_AUTO_CREATE)        &#125;        binding.unbind.setOnClickListener &#123;            //解绑Service            unbindService(connection)        &#125;    &#125;\n\n\nService更多技巧使用前台Service\n调用startForeground方法会让一个service变成前台服务\n\n声明权限\noverride fun onCreate() &#123;        Log.d(&quot;MyService&quot;, &quot;onCreate: &quot;)        val manager=getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager        if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.O)&#123;            val channel=NotificationChannel(&quot;my_service&quot;,&quot;前台Service通知&quot;,NotificationManager.IMPORTANCE_DEFAULT)            manager.createNotificationChannel(channel)        &#125;        val intent=Intent(this,MainActivity::class.java)        val pi=PendingIntent.getActivity(this,0,intent, PendingIntent.FLAG_IMMUTABLE)        val notification=NotificationCompat.Builder(this,&quot;my_service&quot;)            .setContentTitle(&quot;This is title&quot;)            .setContentText(&quot;This is Context&quot;)            .setSmallIcon(R.drawable.ic_launcher_foreground)            .setLargeIcon(BitmapFactory.decodeResource(resources,R.drawable.ic_launcher_background))            .setContentIntent(pi)            .build()        startForeground(1,notification)    &#125;\n\n&lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;\n\nIntentService\n新建一个类继承IntentService\n实现onHandleIntent()抽象方法，这个方法用于处理耗时的逻辑(在子线程中运行li)\n利用Intent启动IntentService\n注册IntentService\n\nclass MyIntentService : IntentService(&quot;MyIntentService&quot;) &#123;    override fun onHandleIntent(intent: Intent?) &#123;        //打印当前线程id        Log.d(&quot;MyIntentService&quot;, &quot;Thread id is $&#123;Thread.currentThread().name&#125;&quot;)    &#125;    override fun onDestroy() &#123;        super.onDestroy()        Log.d(&quot;MyIntentService&quot;, &quot;onDestroy: &quot;)    &#125;&#125;\n\nbinding.startintent.setOnClickListener &#123;           //打印主线程id           Log.d(&quot;MainActivity&quot;, &quot;Thread id is $&#123;Thread.currentThread().name&#125;&quot;)           val intent=Intent(this,MyIntentService::class.java)           startService(intent)       &#125;\n\n&lt;service            android:name=&quot;.MyIntentService&quot;            android:exported=&quot;false&quot;&gt;&lt;/service&gt;\n\n\n","categories":["Android(Kotlin版)"]},{"title":"View的基础知识","url":"/posts/View%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"View的定义View是Android中所有控件的基类，View是一种界面层的控件的一种抽象，它代表了一个控件。除了View还有ViewGroup，可以理解成控件组，ViewGroup也继承自View，所以View可以是单个控件也可以是多个控件组成的控件组，通过这种关系就形成了View树的结构\n\nView的位置参数\nView的位置主要由四个顶点决定：top(左上角纵坐标),bottom（右下角纵坐标）,right（右下角横坐标）,left（左上角横坐标）\n\n\n获取四个参数的方法：\nmLeft=getLeft();mRight=getRight();mTop=getTop();mBottom=getBottom();\n\nAndroid3.0之后新引入的参数：x和y（View左上角的坐标），translationX和translationY（View左上角相对于父容器的偏移量，默认值为0），这几个参数也都是相对于父容器的坐标，这几个参数的换算关系如下：\nx=left+translationXy=top+translationY\n\nView发生平移时top，left表示原始左上角的坐标信息不改变，发生改变的是x,y,translationX,translationY这四个参数\n\n\nMotionEvent和TouchSlop\nMotionEvent\n\n典型事件类型：\nACTION_DOWN//手指刚刚接触屏幕ACTION_MOVE//手指在屏幕上移动ACTION_UP//手指从屏幕上松开的一瞬间\n\n正常情况下，一次手指触摸屏幕的行为会触发一系列点击事件，考虑如下几种情况：\n点击屏幕后离开松开，事件序列为DOWN -&gt; UP；\n点击屏幕滑动一会再松开，事件序列为DOWN -&gt; MOVE-&gt; …&gt; MOVE-&gt; UP\n\n通过MotionEvent对象也可以获得点击事件发生的x和y坐标，提供了两组方法：getX&#x2F;getY(相对于当前View左上角的x，y坐标)和getRawX&#x2F;getRawY（相对于手机屏幕左上角的x，y坐标）\n\n\n\nTouchSlop\n\nTouchSlop是系统所能识别出的被认为滑动的最小距离，这是一个常量和设备有关，当手指滑动距离小于这个常量，那么系统不认为它是滑动，可以通过ViewConfiguration.get(getContext()).getScaledTouchSlop()方法获取这个常量\n这个常量的意义：当我们在处理滑动时可以利用这个常量做一些过滤\n\n\n\nVelocityTracker,GestureDetector和Scroller\nVelocityTracker\n\n速度追踪，用于追踪手指滑动过程中的速度，包括水平和竖直方向上的速度，使用过程简单，首先在View的onTouchEvent方法中追踪当前点击事件的速度：\nVelocityTracker velocityTracker=VelocityTracker.obtain();//获取（或复用）一个速度追踪器实例。velocityTracker.addMovement(event);//将当前的手势事件（坐标、时间）存入追踪器。\n\nvelocityTracker.computercurrentVelocity(1000);//计算当前的速度，参数单位是ms\nint xVelocity=(int) velocityTracker.getXVelocity();//获取水平方向（X轴）的速度值。\nint yVelocity=(int) velocityTracker.getYVelocity();//获取垂直方向（Y轴）的速度值。\n   注意：（1）一定要先计算速度   （2）这里的速度指一段时间内手指所滑过的像素数，速度可以为负值，公式为：速度=（终点位置-起点位置）/ 时间段- 最后不使用时需要回收  ```java  velocityTracker.clear();  velocityTracker.recycle();\n\n\n\n\nGestureDetector\n\nScroller\n\n\n","categories":["Android进阶"]},{"title":"UI开发(Java)","url":"/posts/UI%E5%BC%80%E5%8F%91/","content":"常用控件TextView1.android:id定义唯一标识符2.android:layout_width指定宽度有match_parent和wrap_content两个选项，第一个表示当前控件大小和父布局大小一样，第二个表示当前控件大小刚好能包住里面的内容3.android:layout_height指定高度，选项和上相同4.android:text指定文本显示的内容5.android:gravity指定文字对齐方式可选值有top,bottom,left,right,center等，可以用“|”来指定多个值6.android:textSize指定文字大小，用sp做单位7.android:textColor指定文字颜色\n&lt;TextView       android:id=&quot;@+id/text_view&quot;       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;wrap_content&quot;       android:gravity=&quot;center&quot;       android:text=&quot;@string/this_is_textview&quot;       android:textColor=&quot;#00ff00&quot;       android:textSize=&quot;24sp&quot;      /&gt;\n\nButton1.android:id确定唯一标识符2.android:layout_width指定宽度3.android:layout_height指定高度4.android:text指定文本内容5.android:textAllCaps是否对字母进行大写转换含有的板块与TextView中的差不多，其余的不再过多赘述重点:设定完按钮后在活动中要给其注册一个相应的点击事件(注册一个监听器)\n&lt;Button       android:id=&quot;@+id/button&quot;       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;wrap_content&quot;       android:text=&quot;@string/button&quot;       android:textAllCaps=&quot;false&quot; /&gt;\n\nButton button=(Button) findViewById(R.id.button);button.setOnClickListener(new View.OnClickListener() &#123;           @Override           public void onClick(View view) &#123;               ProgressDialog dialog = new ProgressDialog(MainActivity.this);              //此处添加逻辑代码           &#125;       &#125;);\n\nEditText1.android:id唯一标识符2.android:layout-width确定宽度3.android:layout_height高度4.android:hint指定一段提示性文字，输入内容后文字会自己消失5.android:maxLines指定文本输入的最大行数6.EditText与Button可以结合使用，首先使用findViewById方法得到EditText的实例，然后在按钮点击事件里修改通过getText获取文本内容利用toString转换成字符串，最后利用Toast将内容通过按钮显示\n&lt;EditText      android:id=&quot;@+id/edit_text&quot;      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;wrap_content&quot;      android:hint=&quot;@string/type_something_here&quot;      android:textSize=&quot;20sp&quot;      android:maxLines=&quot;2&quot;      /&gt;\n\nprivate EditText editText; @Override   protected void onCreate(Bundle savedInstanceState) &#123;       super.onCreate(savedInstanceState);       setContentView(R.layout.activity_main);        Button button=(Button) findViewById(R.id.button);       editText=(EditText) findViewById(R.id.edit_text);           button.setOnClickListener(new View.OnClickListener() &#123;           @Override           public void onClick(View view) &#123;             String inputText=editText.getText().toString;             Toast.makeText(MainActivity.this,inputText,Toast.LENGTH_SHORT).show();           &#125;       &#125;);   &#125;\n\nImageView1.android:id2.android:layout_width3.android:layout_height4.android:src选择显示的图片5.可以和按钮一起使用动态的更改图片\n&lt;ImageView      android:id=&quot;@+id/image_view&quot;      android:layout_width=&quot;wrap_content&quot;      android:layout_height=&quot;wrap_content&quot;      android:src=&quot;@drawable/img_1&quot;       /&gt;\n\nprivate ImageView imageView;  @Overrideprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    Button button=(Button) findViewById(R.id.button);     imageView=(ImageView) findViewById(R.id.image_view) ;    button.setOnClickListener(new View.OnClickListener() &#123;        @Override        public void onClick(View view) &#123;         imageView.setImageResource(R.drawable.img_2);        &#125;    &#125;);&#125;\n\nProgressBar用途:用于显示进度条1.android:id2.android:layout_width3.android:layout_height4.android:max设置进度条最大值5.style设置进度条的种类6.通过按钮可以实现，进度条可见变为不可见，不可见变为可见7.通过按钮可以使进度条发生动态变化\n&lt;ProgressBar       android:id=&quot;@+id/progress_bar&quot;       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;wrap_content&quot;       style=&quot;?android:attr/progressBarStyleHorizontal&quot;       android:max=&quot;100&quot;/&gt;\n\nprivate ProgressBar progressBar; @Override protected void onCreate(Bundle savedInstanceState) &#123;     super.onCreate(savedInstanceState);     setContentView(R.layout.activity_main);     Button button=(Button) findViewById(R.id.button);      progressBar=(ProgressBar) findViewById(R.id.progress_bar);     button.setOnClickListener(new View.OnClickListener() &#123;         @Override         public void onClick(View view) &#123;           /*6.if(progressBar.getVisibility()==View.GONE)&#123;           progressBar.setVisibility(View.VISIBLE);           &#125; else&#123;           progressBar.setVisibility(View.GONE);           &#125;           */           /*7.int progress = progressBar.getProgress();               progress=progress+10;               progressBar.setProgress(progress);           */         &#125;     &#125;); &#125;\n\nAlertDialog作用:弹出对话框，用于提示一些重要信息\nAlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this);dialog.setTitle(&quot;This is a dialog&quot;);//标题dialog.setMessage(&quot;Something important&quot;);//内容dialog.setCancelable(false);//是否可以通过点击其他区域来关闭对话框dialog.setPositiveButton(&quot;OK&quot;,new DialogInterface.OnClickListener()&#123;    @Overrid    public void Click(DialogInterface dialogInterface,int i)&#123;&#125;&#125;);dialog.setNegativeButton(&quot;No&quot;,new DialogInterface.OnClickListener()&#123;    @Overrid    public void Click(DialogInterface dialogInterface,int i)&#123;&#125;&#125;);dialog.show();\n\nProgressDialog作用:同AlertDialog相似，不过是在弹出的窗口中有一个进度条\nProgressDialog dialog = new ProgressDialog(MainActivity.this);dialog.setTitle(&quot;This is a dialog&quot;);//标题dialog.setMessage(&quot;Loading......&quot;);//内容dialog.setCancelable(true);//是否可以通过点击其他区域来关闭对话框dialog.show();\n\n如果setCancelable()中传入的是false，此时无法通过back键退出，这时在数据加载完成之后一定要调用dismiss()方法关闭对话框\n\n四种基本布局线性布局又叫做1.android:orientation表示排列方向，有两个选择vertical垂直方向，如果排列方向是这个时高度不能是match_parent，horizontal表示水平方向，如果排列方向是这个时，控件宽度不能设置为match_parent,默认为horizontal2.android:layout_width宽度3.android:layout_height高度4.android:layout_gravity指定控件在布局中的对齐方式，如果排列方式是horizontal是只有垂直方向上的对齐方式才会生效，排列方向是vertical时与之相同\n\n5.android:layout_weight这个属性允许我们使用比例的方式来指定控件的大小。使用这个时要把layout_width的值设为“0dp”\n\n使用这个属性时，也可以仅部分控件使用可以达到更好的效果\n相对布局RelativeLayout又称相对布局，也是一种非常常用的布局，它可以通过定位的方式让控件出现在布局的任意位置1.相对于父布局进行定位\n\n\n2.相对于控件进行定位:android:layout_above一个控件在另一个控件上面android:layout_below一个控件在另一个控件下面android:layout_toLeft0f一个控件在另一个控件左侧android:layout_toRight0f一个控件在另一个控件右侧注:引用的控件应该放在前面\n\n\n3.其他定位属性:android:layout_alignLeft表示让一个控件的左边缘同另一个控件左边缘对齐android:layout_alignRight表示让一个控件的右边缘同另一个控件右边缘对齐android:layout_alignTopandroid:layout_alignBottom\n帧布局FrameLayout又叫帧布局，应用场景较少，所有控件都会默认摆在布局左上角，也可以使用android:layout_gravity进行对齐操作，此方法应用场景过少，不做过多赘述\n百分比布局百分比布局是对帧布局和相对布局两种布局方式的扩展重点:使用前要先添加百分比布局库的依赖\n\n(1)帧布局的百分比布局需要定义一个app空间\nxmlns:app=“http://schemas.android.com/apk/res-auto”\n\n1.app:layout_widthPercent2.app:layout_heightPercent其余继承FrameLayout\n\n\n(2)相对布局的百分比布局:与上述相似\n\n创建自定义控件引入布局1.新建一个布局，在里面写需要的代码\n&lt;include layout=&quot;@layout/title&quot;/&gt;\n\n2.利用include语句引入3.利用ActionBar隐藏自带标题\nActionBar actionBar=getSupportActionBar();if(actionBar!=null)&#123;    actionBar.hide();&#125;\n\n创建自定义控件1.创建通用的布局代码。\n2.新建一个类继承自LinearLayout\npublic class TitleLayout extends LinearLayout &#123;    public TitleLayout(Context context, AttributeSet attrs)&#123;        super(context,attrs);        LayoutInflater.from(context).inflate(R.layout.title,this);        &#125;\n\n3.将创建好的控件添加到布局文件中\n&lt;com.example.uicustomviews.TitleLayout     android:layout_width=&quot;match_parent&quot;     android:layout_height=&quot;wrap_content&quot;/&gt;\n\n4.可以为按钮注册点击事件在新建那个类中\npublic class TitleLayout extends LinearLayout &#123;    public TitleLayout(Context context, AttributeSet attrs)&#123;        super(context,attrs);        LayoutInflater.from(context).inflate(R.layout.title,this);        Button titleBack = (Button) findViewById(R.id.title_back);        Button titleEdit=(Button) findViewById(R.id.title_edit);        titleBack.setOnClickListener(new View.OnClickListener()&#123;            @Override            public void onClick(View view) &#123;                ( (Activity) getContext()).finish();            &#125;        &#125;);        titleEdit.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                Toast.makeText(getContext(), &quot;You clicked &quot;, Toast.LENGTH_SHORT).show();            &#125;        &#125;);    &#125;&#125;\n\n\nListViewListView的简单用法以一个数组数据进行举例讲解1.在布局中直接加入布局2.数组中的数据无法直接传给ListView,故需借助适配器完成，这里推荐使用ArrayAdapter,这里需要传入三个数据上下文，Listview子项布局id及适配数据3.创建一个listview对象调用setAdapter传入适配器，这样就关联好了\n&lt;ListView     android:id=&quot;@+id/list_view&quot;     android:layout_width=&quot;match_parent&quot;     android:layout_height=&quot;match_parent&quot;/&gt;\n\n\n定制ListView界面1.先定义一个实体类作为listview的适配类型\n\n2.然后给listview的子项指定一个自定义的布局，用imageview显示图片，textview显示名字\n\n3.接下来创建一个自定义适配器继承自ArrayAdapter,将上下文，子项布局的id和数据都传入进来，通过getItem方法获取实例，然后使用LayoutInflater来为子项加载布局，这里LayoutInflater中的inflate方法接收三个数据，第三个参数指定为false表示只让父布局中声明的layout属性失效，但不为这个View添加父布局，因为一旦View有了父布局，它就不能再添加到ListView中了\n\n4.添加一个initFruits方法，对数据进行初始化，将水果名称及图片这些数据传入列表中，并利用新建的那个适配器传递给ListView\n\n\n提升ListView运行效率主要在适配器中进行修改1.原本布局需要多次重复加载，这样性能很低，所以可以利用convertView对其进行修改，用它来对布局进行缓存，重复利用。2.控件也需要多次创建，这个可以通过建立一个内部类viewHolder对控件进行缓存，利用setTag进行缓存，用getTag进行取出，可以得到更好的性能\n\n\nListView的点击事件ListView listView=(ListView) findViewById(R.id.list_view);listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;    @Override    public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123;        Fruit fruit=fruitList.get(i);        Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show();    &#125;&#125;);\n\n\nRecyclerViewRecyclerView基本用法增强版的ListView使用时也需要提前添加依赖库\nimplementation (&quot;androidx.recyclerview:recyclerview:1.3.2&quot;)\n\n1.首先创建一个新的类作为适配类型，创建一个子项布局2.创建一个适配器让这个适配器继承自RecyclerView.Adapter,并把泛型指定为FruitAdapter.ViewHolder.先建立一个内部类，传入一个参数 这个参数通常是子项的最外层布局，通过findViewById获取实例，然后通过其中的构造函数将数据源传入并赋值给一个全局变量，由于其继承自RecyclerView.Adapter所以要重写onCreateViewHolder,onBindViewHolder,getItemCount三个方法，第一个用于创建ViewHolder实例，第二个用于对数据进行赋值，第三个得到有多少个子项3.写一个InitFruits方法初始化数据，获取recyclerview实例，然后创建一个LinearLayoutManager对象指定布局方式并将其设置到recyclerView中，创建适配器的实例并将水果数据传入其中，最后建立联系\n\n\n\n实现横向滚动在原有的代码上进行少量修改：1.修改fruit_item中的代码，将元素改为垂直排列，将ImageView和TextView改为水平居中2.在主活动中添加layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL)即可\n\n实现瀑布流布局瀑布流布局(GridLayoutManager用于实现网格布局，StaggeredGridLayoutManager用于实现瀑布流布局)在原有代码上修改：1.首先对fruit_item进行细微修改2.在主活动onCreate方法中加入一句代码\n\n接受俩参数，第一个用于指定列数，第二个用于指定布局排列方式，到这里瀑布式布局已经完成了，但还可以用一个小技巧使观察的更清晰3.创建一个getRandomLengthName方法，先利用random创造一个随机数，然后将名字重复生成\n\nRecyclerView点击事件无法直接全部直接注册监听器，需要对具体的View分别注册1.先修改ViewHolder在其中加入变量fruitView来保存子项最外层布局2.在onCreateViewHolder中注册点击事件，在点击事件中先获取用户点击的position，拿到相应的实例，再用Toast弹出不同的内容\n\n\n","categories":["Android(Java版)"]},{"title":"UI开发(Kotlin)","url":"/posts/UI%E5%BC%80%E5%8F%91-Kotlin/","content":"常用控件TextView&lt;TextView        android:id=&quot;@+id/textView&quot;//定义唯一标识符        android:layout_width=&quot;match_parent&quot;//控件宽度        android:layout_height=&quot;wrap_content&quot;//控件高度        android:gravity=&quot;center&quot;//文字位置        android:textColor=&quot;@color/red&quot;//文字颜色        android:textSize=&quot;24sp&quot;//文字大小        android:text=&quot;This is TextView&quot;//文字内容       /&gt;\n\n\n\nButton&lt;Button        android:id=&quot;@+id/button&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Button&quot;/&gt;\n\n点击事件：\n(1)\nmyBinding.button.setOnClickListener &#123;    //代码逻辑&#125;\n\n(2)接口法\nclass MainActivity : AppCompatActivity(),View.OnClickListener &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;                   ......    &#125;    override fun onClick(v: View?) &#123;        when(v?.id)&#123;            R.id.button-&gt;&#123;                //在此处添加逻辑            &#125;        &#125;    &#125;&#125;\n\n\n\nEditText&lt;EditText        android:id=&quot;@+id/editText&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:textSize=&quot;26dp&quot;        android:hint=&quot;Type something here&quot;//提示性文字        android:maxLines=&quot;2&quot;//最大行数        /&gt;\n\n\n\nImageView&lt;ImageView        android:id=&quot;@+id/imageView&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:src=&quot;@drawable/ic_launcher_background&quot;/&gt;\n\n动态变化ImageView中图片\nmyBinding.button.setOnClickListener &#123;           myBinding.imageView.setImageResource(R.drawable.b)       &#125;\n\n\n\nProgressBar&lt;ProgressBar        android:id=&quot;@+id/progressBar&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        style=&quot;?android:attr/progressBarStyleHorizontal&quot;//进度条样式        android:max=&quot;100&quot;/&gt;//进度条最大值\n\n\n\nAlertDialogAlertDialog.Builder(this).apply &#123;                setTitle(&quot;This is Dialog&quot;)                setMessage(&quot;Something important&quot;)                setCancelable(false)//点击别的地方是否可以取消弹出框                setPositiveButton(&quot;OK&quot;)&#123;                    dialog,which-&gt;                &#125;                setNegativeButton(&quot;Cancel&quot;)&#123;                    dialog,which-&gt;                &#125;                show()            &#125;\n\n\n\n\n布局LinearLayout\nandroid:layout_weight这个属性允许我们使用比例的方式来指定控件的大小。使用这个时要把layout_width的值设为“0dp”\n\nRelativeLayout相对父布局\n\n\n相对其他控件\n**注：**引用控件放在前面\n\n\n其他定位属性:android:layout_alignLeft表示让一个控件的左边缘同另一个控件左边缘对齐android:layout_alignRight表示让一个控件的右边缘同另一个控件右边缘对齐android:layout_alignTopandroid:layout_alignBottom\nFrameLayoutFrameLayout又叫帧布局，应用场景较少，所有控件都会默认摆在布局左上角，也可以使用android:layout_gravity进行对齐操作，此方法应用场景过少，不做过多赘述\n\n自定义控件引入布局1.创建一个子项布局\n2.在相应活动布局中引用该布局\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;horizontal&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:background=&quot;@drawable/title_bg&quot;&gt;    &lt;Button        android:id=&quot;@+id/titleBack&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Back&quot;        android:layout_gravity=&quot;center&quot;        android:layout_margin=&quot;5dp&quot;        android:textColor=&quot;#fff&quot;        android:background=&quot;@drawable/back_bg&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/titleText&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_weight=&quot;1&quot;        android:text=&quot;Title Text&quot;        android:gravity=&quot;center&quot;        android:layout_gravity=&quot;center&quot;        android:textColor=&quot;@color/black&quot;        android:textSize=&quot;24sp&quot;        /&gt;    &lt;Button        android:id=&quot;@+id/titleEdit&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Edit&quot;        android:layout_gravity=&quot;center&quot;        android:layout_margin=&quot;5dp&quot;        android:textColor=&quot;#fff&quot;        android:background=&quot;@drawable/edit_bg&quot;/&gt;&lt;/LinearLayout&gt;\n\n&lt;include layout=&quot;@layout/title&quot;/&gt;\n\n因为建立的是标题栏需要将系统自带的隐藏\nsupportActionBar?.hind()\n\n创建自定义控件1.新建一个自定义类继承LinearLayout作为控件\n2.在布局文件中添加这个控件\n3.在自定义类中添加点击事件\nclass TitleLayout(context: Context,attrs:AttributeSet):LinearLayout(context,attrs) &#123;    init &#123;        //动态加载标题栏布局        LayoutInflater.from(context).inflate(R.layout.title,this)        val titleBack=findViewById&lt;Button&gt;(R.id.titleBack)        val titleEdit=findViewById&lt;Button&gt;(R.id.titleEdit)        titleBack.setOnClickListener &#123;            val activity =context as Activity            activity.finish()        &#125;        titleEdit.setOnClickListener &#123;            Toast.makeText(context,&quot;You clicked edit button&quot;,Toast.LENGTH_SHORT).show()        &#125;    &#125;&#125;\n\n &lt;com.example.uicustomviews.TitleLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;\n\n\nListView1.在布局中添加该控件\n2.制作一个适配器并定义一个类作为适配器类型\n3.定义一个子项布局\n4.将适配器和listview建立联系\n5.定义其点击事件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;   &gt;    &lt;ListView        android:id=&quot;@+id/listView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt;\n\n//适配器类型class Fruit(val name:String,val imageId:Int)\n\nclass FruitAdapter(activity: Activity,val resourceId:Int,data:List&lt;Fruit&gt;):ArrayAdapter&lt;Fruit&gt;(activity,resourceId,data) &#123;    //用于对控件实例进行缓存    inner class ViewHolder(val fruitImage:ImageView,val fruitName:TextView)    //该方法在每个子项被滚动到屏幕内的时候会被调用    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View &#123;        val view:View        val viewHolder:ViewHolder        //利用convertView对加载好的布局进行缓存以便于复用        //不为空则调用之前缓存的布局控件        if(convertView!=null)&#123;            view=convertView            viewHolder=view.tag as ViewHolder        &#125;        else&#123;            //动态加载布局            view =LayoutInflater.from(context).inflate(resourceId,parent,false)            //获取控件实例            val fruitImage:ImageView=view.findViewById(R.id.fruit_image)            val fruitName:TextView=view.findViewById(R.id.fruitName)           //缓存控件实例以便于复用            viewHolder=ViewHolder(fruitImage,fruitName)            //利用View的setTag()方法将viewHolder对象存储在View中            view.tag=viewHolder        &#125;        //获取当前项的Fruit实例        val fruit=getItem(position)        //设置图片和文本        if(fruit!=null)&#123;            viewHolder.fruitImage.setImageResource(fruit.imageId)            viewHolder.fruitName.text=fruit.name        &#125;        return view    &#125;&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;60dp&quot;&gt;    &lt;ImageView        android:id=&quot;@+id/fruit_image&quot;        android:layout_width=&quot;40dp&quot;        android:layout_height=&quot;40dp&quot;        android:layout_gravity=&quot;center_vertical&quot;        android:layout_marginLeft=&quot;10dp&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/fruitName&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;center_vertical&quot;        android:layout_marginLeft=&quot;10dp&quot;/&gt;&lt;/LinearLayout&gt;\n\n  private val fruitList=ArrayList&lt;Fruit&gt;()//获取适配器实例val adapter=FruitAdapter(this,R.layout.fruit_item,fruitList)//建立联系        binding.listView.adapter=adapter\n\n //设置点击事件binding.listView.setOnItemClickListener &#123; _, _, position, _ -&gt;            val fruit=fruitList[position]            Toast.makeText(this,fruit.name,Toast.LENGTH_SHORT).show()        &#125;\n\n\nRecyclerView1.添加依赖库\n2.添加控件\n3.准备一个适配器并定义一个适配器类型\n4.定义一个子项布局\n5.将适配器和RecyclerView建立联系并设置其布局形式\n6.设置点击事件(在适配器的**onCreateViewHolder()**方法中设置)\nimplementation (&quot;androidx.recyclerview:recyclerview:1.3.2&quot;)\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;androidx.recyclerview.widget.RecyclerView        android:id=&quot;@+id/recyclerView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt;\n\n//适配器类型class Fruit(val name:String,val imageId:Int)\n\nclass FruitAdapter(val fruitList: List&lt;Fruit&gt;):RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;() &#123;    //内部类ViewHolder存储控件    inner class ViewHolder(view: View):RecyclerView.ViewHolder(view)&#123;        val fruitImage:ImageView=view.findViewById(R.id.fruit_image)        val fruitName:TextView=view.findViewById(R.id.fruitName)    &#125;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder &#123;        //动态加载布局        val view=LayoutInflater.from(parent.context).inflate(R.layout.fruit_item,parent,false)        //获取viewHolder实例        val viewHolder=ViewHolder(view)        //设置点击事件        viewHolder.itemView.setOnClickListener &#123;            //获取位置            val position=viewHolder.adapterPosition            //获取实体类实例            val fruit=fruitList[position]            //具体事件            Toast.makeText(parent.context,&quot;you clivked view $&#123;fruit.name&#125;&quot;,Toast.LENGTH_SHORT).show()        &#125;        viewHolder.fruitImage.setOnClickListener &#123;             //获取位置            val position=viewHolder.adapterPosition            //获取实体类实例            val fruit=fruitList[position]             //具体事件            Toast.makeText(parent.context,&quot;you clivked image $&#123;fruit.name&#125;&quot;,Toast.LENGTH_SHORT).show()        &#125;        return viewHolder    &#125;//对RecyclerView的子项数据进行赋值    @SuppressLint(&quot;SuspiciousIndentation&quot;)    override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123;      val fruit =fruitList[position]        holder.fruitImage.setImageResource(fruit.imageId)        holder.fruitName.text=fruit.name    &#125;    override fun getItemCount()=fruitList.size&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;60dp&quot;&gt;    &lt;ImageView        android:id=&quot;@+id/fruit_image&quot;        android:layout_width=&quot;40dp&quot;        android:layout_height=&quot;40dp&quot;        android:layout_gravity=&quot;center_vertical&quot;        android:layout_marginLeft=&quot;10dp&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/fruitName&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;center_vertical&quot;        android:layout_marginLeft=&quot;10dp&quot;/&gt;&lt;/LinearLayout&gt;\n\nclass MainActivity : AppCompatActivity() &#123;    private val fruitList=ArrayList&lt;Fruit&gt;()    private lateinit var binding:ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        binding=ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        //初始化数据        initFruits()        //创建LinearLayoutManager对象        //LayoutManager用于指定布局方式，LinearLayoutManager(this)指线性布局，GridLayoutManager()是网格布局       //设置布局排列方向(线性布局)       /* layoutManager.orientation=LinearLayoutManager.HORIZONTAL*/        //瀑布流布局传入两个参数第一个指定布局的列数，第二个指定布局排列的方向        val layoutManager=StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL)        //将该对象设置到recyclerView中        binding.recyclerView.layoutManager=layoutManager        //获取FruitAdapter实例        val adapter=FruitAdapter(fruitList)        //完成适配器设置        binding.recyclerView.adapter=adapter    &#125;    private fun initFruits() &#123;        repeat(2) &#123;            fruitList.add(Fruit(getRandomLengthName(&quot;Apple&quot;), R.drawable.apple_pic))            fruitList.add(Fruit(getRandomLengthName(&quot;Banana&quot;), R.drawable.banana_pic))            fruitList.add(Fruit(getRandomLengthName(&quot;Orange&quot;), R.drawable.orange_pic))            fruitList.add(Fruit(getRandomLengthName(&quot;Watermelon&quot;), R.drawable.watermelon_pic))            fruitList.add(Fruit(getRandomLengthName(&quot;Pear&quot;), R.drawable.pear_pic))            fruitList.add(Fruit(getRandomLengthName(&quot;Grape&quot;), R.drawable.grape_pic))            fruitList.add(Fruit(getRandomLengthName(&quot;Pineapple&quot;), R.drawable.pineapple_pic))            fruitList.add(Fruit(getRandomLengthName(&quot;Strawberry&quot;), R.drawable.strawberry_pic))            fruitList.add(Fruit(getRandomLengthName(&quot;Cherry&quot;), R.drawable.cherry_pic))            fruitList.add(Fruit(getRandomLengthName(&quot;Mango&quot;), R.drawable.mango_pic))        &#125;    &#125;    private fun getRandomLengthName(name: String): String &#123;        val n=(1..20).random()        val builder = StringBuilder()       repeat(n)&#123;           builder.append(name)       &#125;        return builder.toString()    &#125;&#125;\n\n\n","categories":["Android(Kotlin版)"]},{"title":"try,catch和finally","url":"/posts/try-catch%E5%92%8Cfinally/","content":"在 Java 中，try、catch 和 finally 是异常处理机制的核心部分。它们用于捕获、处理异常，并确保无论是否发生异常，某些代码都会被执行。下面是对它们的详细解释：\ntry块try 块用于包含可能会抛出异常的代码。如果 try 块中的代码抛出了异常，程序会立即跳转到匹配的 catch 块进行处理。\ntry&#123;    //可能抛出异常的代码&#125;\n\n\ntry 中的代码是你认为可能会发生异常的部分。例如，读取文件、连接数据库等操作可能会抛出异常。\n\n\n\ncatch块catch 块用于捕获和处理异常。如果 try 块中的代码抛出了异常，程序会跳转到与异常类型匹配的 catch 块来处理这个异常。\ntry &#123;    // 可能抛出异常的代码&#125; catch (ExceptionType1 e1) &#123;    // 处理异常类型 1&#125; catch (ExceptionType2 e2) &#123;    // 处理异常类型 2&#125;\n\n\n你可以有多个 catch 块来处理不同类型的异常。catch 块中传入的参数（如 ExceptionType1 e1）是捕获到的异常对象，你可以通过它来访问异常的详细信息（如异常的消息、堆栈跟踪等）。\n如果 try 块抛出的异常类型与某个 catch 块中的异常类型匹配，那么该 catch 块将会被执行。\n\n\nfinally块finally 块中的代码总会在 try-catch 执行完后执行，无论是否发生异常。这使得 finally 块非常适合用于清理资源、关闭流等操作。\ntry &#123;    // 可能抛出异常的代码&#125; catch (ExceptionType e) &#123;    // 处理异常&#125; finally &#123;    // 总会执行的代码&#125;\n\n\nfinally 块中的代码不受是否发生异常的影响，无论 try 块中的代码是否抛出异常，finally 块都会执行，除非程序被强制中断（如调用 System.exit()，或者发生严重的错误）。\n\nfinally 常用于关闭资源（如文件流、数据库连接等），确保即使在出现异常时资源也能被正确释放。\n\n例子：\ntry &#123;    FileReader reader = new FileReader(&quot;somefile.txt&quot;);    // 处理文件&#125; catch (IOException e) &#123;    System.out.println(&quot;文件操作失败: &quot; + e.getMessage());&#125; finally &#123;    // 确保文件流关闭    System.out.println(&quot;关闭文件流&quot;);&#125;\n\n\ntry-catch-finally 的完整流程\n执行 try 块：\n\n如果 try 块中的代码没有抛出异常，catch 块会被跳过，接着执行 finally 块。\n如果 try 块中的代码抛出了异常，程序会跳转到匹配的 catch 块执行，finally 块会被执行。\n\n\n执行 catch 块：\n\n如果有异常发生并且与某个 catch 块中的异常类型匹配，该 catch 块会处理异常。多个 catch 块可以用来捕获不同类型的异常。\n\n\n执行 finally 块：\n\nfinally 块会在 try 和 catch 完成后执行，无论是否发生异常。即使在 try 或 catch 块中调用了 return 语句，finally 也会执行。\n\n\n\n\n\n完整的语法实例：try &#123;    // 可能抛出异常的代码    int result = 10 / 0; // 这里会抛出 ArithmeticException&#125; catch (ArithmeticException e) &#123;    // 捕获并处理 ArithmeticException    System.out.println(&quot;发生异常: &quot; + e.getMessage());&#125; finally &#123;    // 无论是否发生异常，都会执行的代码    System.out.println(&quot;最终执行：无论异常与否都执行&quot;);&#125;\n\n运行过程：\n执行 try 块，抛出 ArithmeticException。\n跳到 catch 块，处理该异常。\n无论是否发生异常，finally 块都将被执行。\n\n总结：\ntry：用于包含可能抛出异常的代码。\ncatch：用于捕获并处理异常。如果 try 块抛出异常，程序跳到合适的 catch 块处理异常。\nfinally：用于包含必须执行的代码，通常用于资源清理或关闭文件等操作。它无论是否发生异常都会执行。\n\n这种异常处理机制帮助开发者处理程序中可能出现的错误，并保证程序在发生错误时不会崩溃，还能执行一些必要的清理工作。\n\n\n​     内容源于github用户11111-beep的Android学习笔记&#96;&#96;\n\n","categories":["Android(Java版)"]},{"title":"事务篇","url":"/posts/%E4%BA%8B%E5%8A%A1%E7%AF%87/","content":"简介\n\n默认MYSQL事务是自动提交的，所以需要手动开启事务，手动提交事务，有异常手动回滚事务\n\n\n事务操作\n方法一\n\n\n方法二\n\n\n\n\n事务四大特性\n\n并发事务问题\n\n事务隔离级别\n注意：事务隔离级别越高，安全性越高，性能越低\n\n","categories":["数据库(SQL)"]},{"title":"分享功能","url":"/posts/%E5%88%86%E4%BA%AB%E5%8A%9F%E8%83%BD/","content":"分享纯文本fun shareText(text: String) &#123;    val sendIntent = Intent().apply &#123;        action = Intent.ACTION_SEND        putExtra(Intent.EXTRA_TEXT, text)        type = &quot;text/plain&quot;    &#125;    // 创建一个选择器，让用户选择用哪个 App 分享    val shareIntent = Intent.createChooser(sendIntent, &quot;分享文本到...&quot;)    startActivity(shareIntent)&#125;\n\n注意：始终使用 Intent.createChooser() 是一个好习惯。这会强制系统每次都显示一个应用选择列表，避免用户因为设置了某个应用的“默认操作”而无法选择其他应用。\n分享单张图片或单个文件\n在 AndroidManifest.xml 中声明 FileProvider\n\n&lt;manifest ...&gt;    &lt;application ...&gt;        ...        &lt;provider            android:name=&quot;androidx.core.content.FileProvider&quot;            android:authorities=&quot;$&#123;applicationId&#125;.fileprovider&quot;            android:exported=&quot;false&quot;            android:grantUriPermissions=&quot;true&quot;&gt;            &lt;meta-data                android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;                android:resource=&quot;@xml/file_paths&quot; /&gt;        &lt;/provider&gt;        ...    &lt;/application&gt;&lt;/manifest&gt;\n\n\n创建 res/xml/file_paths.xml 文件\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;cache-path name=&quot;my_cache_images&quot; path=&quot;images/&quot;/&gt;    &lt;files-path name=&quot;my_files&quot; path=&quot;docs/&quot;/&gt;    &lt;external-path name=&quot;my_external_files&quot; path=&quot;.&quot;/&gt;&lt;/paths&gt;\n\n\n编写分享代码\n\nprivate fun saveImgAndGetUri(context: Context,bitmap: Bitmap):Uri&#123;        val imageFolder= File(context.cacheDir,&quot;images&quot;)        val uri:Uri?        imageFolder.mkdirs()        val file= File(imageFolder,&quot;shared_image.png&quot;)        val stream= FileOutputStream(file)        bitmap.compress(Bitmap.CompressFormat.PNG,90,stream)        stream.flush()        stream.close()        uri = FileProvider.getUriForFile(            context,            &quot;com.example.daysmatter.fileprovider&quot;, // 必须和 Manifest 中的 authorities 一致            file        )        return uri    &#125;private fun shareImage(context: Context, uri: Uri) &#123;     // 创建 Intent        val shareIntent = Intent().apply &#123;            action = Intent.ACTION_SEND            putExtra(Intent.EXTRA_STREAM, uri)            type = &quot;image/png&quot;            // 设置正确的 MIME Type           // 授予临时读取权限            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)        &#125;     // 4. 启动选择器        startActivity(Intent.createChooser(shareIntent, &quot;分享图片到...&quot;))    &#125;\n\n分享多张图片或多个文件与分享单张基本相同，有个别点有差异\n\nIntent Action: Intent.ACTION_SEND_MULTIPLE\n\n分享内容: 使用 putParcelableArrayListExtra(Intent.EXTRA_STREAM, ...) 存放一个包含多个 Uri 的 ArrayList。\n\n\nfun shareMultipleImages(context: Context, imageFiles: List&lt;File&gt;) &#123;    val uriList = ArrayList&lt;Uri&gt;()    imageFiles.forEach &#123; file -&gt;        val uri = FileProvider.getUriForFile(            context,            &quot;$&#123;context.packageName&#125;.fileprovider&quot;,            file        )        uriList.add(uri)    &#125;    val shareIntent = Intent().apply &#123;        action = Intent.ACTION_SEND_MULTIPLE        putParcelableArrayListExtra(Intent.EXTRA_STREAM, uriList)        type = &quot;image/*&quot; // 可以使用通配符        addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)    &#125;    startActivity(Intent.createChooser(shareIntent, &quot;分享多张图片...&quot;))&#125;\n\n","categories":["Android随笔"]},{"title":"内容提供器(Java)","url":"/posts/%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8/","content":"运行时权限危险权限表格\n运行时申请权限(以打电话为例)1.先借助ContextCompat.checkSelfPermission()方法判断用户是否进行了授权。\ncheckSelfPermission()接收两个参数，第一个是Context，第二个是具体的权限名\n2.使用方法的返回值和PackageManager.PERMISSION_GRANTED作比较，不等表示未授权，相等表示已授权\n3.把打电话的逻辑封装在**call()方法当中如果授权直接执行该方法，如果未授权，利用ActivityCompat.requestPermissions()**方法向用户申请授权，**requestPermissions()**接收三个参数，第一个是Activity实例，第二个是String数组，把权限名放入其中，第三个是请求码，只要是唯一值就行。\n4.调用requestPermissions()方法后最终会回调到onRequestPermissionResult()方法，而授权结果会封装在grantResults参数中，判断最后的授权结果\n完整的实例：\npublic class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button makeCall=(Button) findViewById(R.id.make_call);        makeCall.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.CALL_PHONE)!= PackageManager.PERMISSION_GRANTED)&#123;                    ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.CALL_PHONE&#125;,1);                &#125;                else&#123;                    call();                &#125;            &#125;        &#125;);    &#125;    private void call()&#123;        try&#123;            Intent intent=new Intent(Intent.ACTION_CALL);            intent.setData(Uri.parse(&quot;tel:10086&quot;));            startActivity(intent);        &#125;catch (SecurityException e)&#123;            e.printStackTrace();        &#125;    &#125;    @SuppressLint(&quot;MissingSuperCall&quot;)    @Override    public void onRequestPermissionsResult(int requestCode,String[] permissions,int[] grantResults)&#123;        switch(requestCode)&#123;            case 1:                if(grantResults.length&gt;0 &amp;&amp; grantResults[0]== PERMISSION_GRANTED)&#123;                    call();                &#125;else&#123;                    Toast.makeText(this, &quot;You denied the permission&quot;, Toast.LENGTH_SHORT).show();                &#125;                break;            default:        &#125;    &#125;&#125;\n\n\n\n\n访问其他程序的数据ContentResolver的基本用法通过getContentResolver()方法获取ContentResolver实例ContentResolver提供了一系列方法，用于对数据进行CRUD和SQLite相似但参数上略有一些区别。\n不同于数据库的是表名参数被Uri参数代替，主要由两部分组成authority和path，authority一般以程序包名进行命名，path则对同一程序不同表进行区分，标准格式为：content:&#x2F;&#x2F;com.example.app.provider&#x2F;table1,还需要将其解析才可以作为参数传入，\nUri uri=Uri.parse(&quot;content://com.example.app.provider/table1&quot;)\nQuery( )Cursor cursor=getContentResolver().query(uri,projection,selection,selectionArgs,sortOrder);if(cursor!=null)&#123;    while(cursor.moveToNext())&#123;        String column1=cursor.getString(cursor.getColumnIndex(&quot;column1&quot;));         int column2=cursor.getInt(cursor.getColumnIndex(&quot;column2&quot;));    &#125;    cursor.close();&#125;\n\nInsert( )ContentValues values=new ContentValues();values.put(&quot;column1&quot;,&quot;text&quot;);values.put(&quot;column2&quot;,1);getContentResolver().insert(uri,values);\n\nupdate( )ContentValues values=new ContentValues();values.put(&quot;column1&quot;,&quot;&quot;);getContentResolver().update(uri,values,&quot;column1=? and column2=?&quot;,new String[]&#123;&quot;text&quot;,&quot;1&quot;&#125;);\n\ndelete( )getContentResolver().delete(uri,&quot;column2=?&quot;,new String[]&#123;&quot;1&quot;&#125;);\n\n\n\n读取系统联系人完整实例：\npublic class MainActivity extends AppCompatActivity &#123;    ArrayAdapter&lt;String&gt;adapter;    List&lt;String&gt;contactsList=new ArrayList&lt;&gt;();    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        ListView contactsView=(ListView) findViewById(R.id.contacts_view);        adapter=new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1,contactsList);        contactsView.setAdapter(adapter);        if(ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS)!= PackageManager.PERMISSION_GRANTED)&#123;            ActivityCompat.requestPermissions(this,new String[]&#123;Manifest.permission.READ_CONTACTS&#125;,1);        &#125;        else&#123;            readContacts();        &#125;    &#125;    private void readContacts() &#123;        Cursor cursor=null;        try&#123;            cursor=getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null,null);            if(cursor!=null)&#123;                while(cursor.moveToNext())&#123;                    @SuppressLint(&quot;Range&quot;) String displayName=cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));                    @SuppressLint(&quot;Range&quot;) String number=cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));                    contactsList.add(displayName+&quot;\\n&quot;+number);                &#125;                adapter.notifyDataSetChanged();            &#125;        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;finally&#123;            if(cursor!=null)&#123;                cursor.close();            &#125;        &#125;    &#125;    @SuppressLint(&quot;MissingSuperCall&quot;)    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;        if(requestCode==1)&#123;            if(grantResults.length&gt;0&amp;&amp;grantResults[0]==PackageManager.PERMISSION_GRANTED)&#123;                readContacts();            &#125;            else&#123;                Toast.makeText(this, &quot;You denied the permission&quot;, Toast.LENGTH_SHORT).show();            &#125;        &#125;    &#125;&#125;\n\n重点看readContacts()方法 里面的uri与前面讲的不太一样，这是为什么呢？这是因为ContactsContract.CommonDataKinds.Phone类已经帮我们做好了封装，提供另一个CONTENT_URI常量，而这个常量就是Uri.parse解析出来的结果。\n\n创建内容提供器1.利用Android Studio创建一个Content Provider，已经在在AndroidManifest.xml中自动注册。\nonCraete():返回true表示创建成功，返回false表示创建失败。\nquery():返回值为Cursor类型\ninsert():返回一个表示这条新记录的URI\nupdate():更新已有数据\ndelete():被删除的行数将作为返回值返回\ngetType():根据传入的URI来返回相应的MIME类型。\n使用通配符表示两种格式的URI：\n***：*表示匹配任意长度的任意字符。例子content:&#x2F;&#x2F;com.example.app.provider&#x2F;\n**#：**表示匹配任意长度的数字。例子content:&#x2F;&#x2F;com.example.app.provider&#x2F;table1&#x2F;#\n2.可以借助UriMatcher这个类实现匹配内容URI的功能，利用UriMatcher中的addURI（）方法，接受三个参数，第一个是authority第二个是path第三个是自定义代码，这样当调用match()方法时就能匹配相应的表数据。\n public static final int TABLE1_DIR=0;    public static final int TABLE1_ITEM=1;    public static final int TABLE2_DIR=2;    public static final int TABLE2_ITEM=3;    private static UriMatcher uriMatcher;    static &#123;        uriMatcher=new UriMatcher(UriMatcher.NO_MATCH);        uriMatcher.addURI(&quot;com.example.app.provider&quot;,&quot;table1&quot;,TABLE1_DIR);        uriMatcher.addURI(&quot;com.example.app.provider&quot;,&quot;table1&quot;,TABLE1_DIR);        uriMatcher.addURI(&quot;com.example.app.provider&quot;,&quot;table1&quot;,TABLE1_DIR);        uriMatcher.addURI(&quot;com.example.app.provider&quot;,&quot;table1&quot;,TABLE1_DIR);    &#125;@Override    public Cursor query(@NonNull Uri uri, @Nullable String[] strings, @Nullable String s, @Nullable String[] strings1, @Nullable String s1) &#123;        if(uriMatcher.match(uri)==TABLE1_DIR)&#123;        &#125; else if (uriMatcher.match(uri)==TABLE1_ITEM) &#123;        &#125; else if (uriMatcher.match(uri)==TABLE2_DIR) &#123;        &#125; else if (uriMatcher.match(uri) == TABLE2_ITEM) &#123;        &#125;        return null;    &#125;\n\n3.getType()方法一个URI内容对应的MIME字符由三部分组成：\n&lt;必须以vnd开头&gt;\n&lt;如果内容以路径结尾，则后接android.cursor.dir&#x2F;，如果以id结尾则后接android.cursor.item&#x2F;.&gt;\n&lt;最后接上vnd..&gt;\nURI为“content:&#x2F;&#x2F;com.example.app.provider&#x2F;table1”对应的MIME类型为“vnd.android.cursor.dir&#x2F;vnd.com.example.app.provider.table1”\nURI为“content:&#x2F;&#x2F;com.example.app.provider&#x2F;table1&#x2F;1”对应的MIME类型为“vnd.android.cursor.item&#x2F;vnd.com.example.app.provider.table1”\n实例：\n@Override   public String getType(@NonNull Uri uri) &#123;       if(uriMatcher.match(uri)==TABLE1_DIR)&#123;           return &quot;vnd.android.cursor.dir/vnd.com.example.app.provider.table1&quot;;       &#125; else if (uriMatcher.match(uri)==TABLE1_ITEM) &#123;           return &quot;vnd.android.cursor.item/vnd.com.example.app.provider.table1&quot;;       &#125; else if (uriMatcher.match(uri)==TABLE2_DIR) &#123;           return &quot;vnd.android.cursor.dir/vnd.com.example.app.provider.table2&quot;;       &#125; else if (uriMatcher.match(uri) == TABLE2_ITEM) &#123;           return &quot;vnd.android.cursor.item/vnd.com.example.app.provider.table2&quot;;       &#125;        return null;   &#125;\n\n\n\n\n","categories":["Android(Java版)"]},{"title":"使用网络技术(Java)","url":"/posts/%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/","content":"WebView可以利用其嵌入一个浏览器\n1.在布局文件中引入WebView控件\n2.获取该控件实例并设置浏览器属性\n3.用setWebViewClient使目标网页在WebView显示\n4.调用loadUrl方法传入网址并获取权限\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;WebView        android:id=&quot;@+id/web_view&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt;\n\npublic class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        WebView webView=(WebView) findViewById(R.id.web_view);        webView.getSettings().setJavaScriptEnabled(true);        webView.setWebViewClient(new WebViewClient());        webView.loadUrl(&quot;https://www.baidu.com&quot;);    &#125;&#125;\n\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;\n\n\n使用HTTP协议访问网络使用HttpURLConnectionGET1.调用sendRequestWithHttpURLConnection()方法开启子线程,并使用HttpURLConnection发出HTTP请求\n2.利用BufferedReader对服务器返回的流进行读取，并将结果传入到showResponse()中\n3.在showResponse里通过runOnUiThread将线程切换到主线程,然后更新UI元素（安卓不允许在子线程进行UI操作）\n4.获取权限\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;    //定义TextView    TextView responseText;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        //获取按钮实例        Button sendRequest=(Button) findViewById(R.id.send_request);        //获取TextView实例        responseText=(TextView) findViewById(R.id.response_text);        //设置按钮点击事件        sendRequest.setOnClickListener(this);    &#125;    //按钮点击事件    @Override    public void onClick(View view) &#123;        if(view.getId()==R.id.send_request)&#123;            //发送网络请求            sendRequestWithHttpURLConnection();        &#125;    &#125;    private void sendRequestWithHttpURLConnection() &#123;        //开启线程来发起网络请求        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                //获取HttpURLConnection和BufferedReader对象                HttpURLConnection connection=null;                BufferedReader reader=null;                try&#123;                    //获取URL对象，并传入目标网址                    URL url=new URL(&quot;https://www.baidu.com&quot;);                    //获取HttpURLConnection实例                    connection=(HttpURLConnection) url.openConnection();                    //设置HTTP请求使用的方法(方法主要有两个，一个是GET表示希望从服务器那里获取数据，POST表示希望提交数据给服务器)                    connection.setRequestMethod(&quot;GET&quot;);                    //自由定制一些设置如连接超时或读取超时的毫秒数                    connection.setConnectTimeout(8000);                    connection.setReadTimeout(8000);                    //获取到服务器返回的输入流                    InputStream in=connection.getInputStream();                    //下面对获取到的输入流进行读取                    reader=new BufferedReader(new InputStreamReader(in));                    StringBuilder response=new StringBuilder();                    String line;                    //readLine一行一行读取并将其返回成字符串                    while((line= reader.readLine())!=null)&#123;                        response.append(line);                    &#125;                    //将返回的数据显示显示到界面上                    showResponse(response.toString());                &#125;catch (Exception e)&#123;                    e.printStackTrace();                &#125;finally &#123;                    if(reader!=null)&#123;                        try&#123;                            //关掉BufferedReader对象                            reader.close();                        &#125;catch (IOException e)&#123;                            e.printStackTrace();                        &#125;                    &#125;                    if(connection!=null)&#123;                        //将HTTP连接关掉                        connection.disconnect();                    &#125;                &#125;            &#125;        &#125;).start();    &#125;    //将返回的数据显示显示到界面上    private void showResponse(final String response)&#123;        runOnUiThread(new Runnable() &#123;            @Override            public void run() &#123;                //在这里进行UI操作，将结果显示到界面上                responseText.setText(response);            &#125;        &#125;);    &#125;&#125;\n\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;\n\nPOST将请求方法改为POST，并在获取输入流之前把要提交数据写出即可。注意每条数据都要以键值对形式存在，数据与数据间用“&amp;”隔开\nconnection.setRequestMethod(&quot;POST&quot;);DataOutputStream out=new DataOutputStream(connection.getOutputStream);out.writeBytes(&quot;username=admin &amp; password=123456&quot;)\n\n\n\n使用OkHttpGET1.添加依赖库\n2.获取OkHttpClient实例\n3.创建Request对象，发起一条HTTP请求，可以在build之前连缀很多方法来丰富该对象\n4.调用newCall()创建一个Call对象，并用execute方法发送请求并获取服务器返回的数据\n5.获取返回数据具体内容\n6.获取权限\nimplementation (&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;)\n\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;    //定义TextView    TextView responseText;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        //获取按钮实例        Button sendRequest=(Button) findViewById(R.id.send_request);        //获取TextView实例        responseText=(TextView) findViewById(R.id.response_text);        //设置按钮点击事件        sendRequest.setOnClickListener(this);    &#125;    @Override    public void onClick(View view) &#123;        sendRequestWithOkHttp();    &#125;    private void sendRequestWithOkHttp() &#123;        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    OkHttpClient client = new OkHttpClient();                    Request request = new Request.Builder()                            .url(&quot;https://www.baidu.com&quot;)                            .build();                        Response response = client.newCall(request).execute();                        String responseData = response.body().string();                        showResponse(responseData);                &#125;catch (Exception e)&#123;                    e.printStackTrace();                &#125;            &#125;        &#125;).start();    &#125;    //将返回的数据显示显示到界面上    private void showResponse(final String response)&#123;        runOnUiThread(new Runnable() &#123;            @Override            public void run() &#123;                //在这里进行UI操作，将结果显示到界面上                responseText.setText(response);            &#125;        &#125;);    &#125;&#125;\n\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n\nPOST1.先构建一个RequestBody对象来存放待提交的参数\n2.在Request.Builder()中调用post()方法将RequestBody对象传入\n3.接下来操作和GET的一样\nRequestBody requestBody=new FormBody.Builder()    .add(&quot;username&quot;,&quot;admin&quot;)    .add(&quot;password&quot;,&quot;123456&quot;)    .build();\n\nRequest request = new Request.Builder()    .url(&quot;https://www.baidu.com&quot;)    .post(requestBody)    .build();\n\n\n\n\n","categories":["Android(Java版)"]},{"title":"原码补码反码","url":"/posts/%E5%8E%9F%E7%A0%81%E8%A1%A5%E7%A0%81%E5%8F%8D%E7%A0%81/","content":"三者关系\n原码的弊端\n反码出现的目的解决原码不能计算负数的问题\n反码的弊端负数计算时结果不跨0没有任何问题，但是结果跨0会和实际结果有1的偏差\n补码出现的目的解决反码计算时的跨0问题\n注意：\n\n计算机中数据的存储及运算都是以补码的形式进行的，补码完美解决了二进制负数的运算问题\n\n原码反码的范围是-127~+127\n\n补码的范围是-128~+127\n\n\n运算符\n左移一次相当于乘2\n右移一次相当于除2\n","categories":["计算机底层"]},{"title":"各集合特点","url":"/posts/%E5%90%84%E9%9B%86%E5%90%88%E7%89%B9%E7%82%B9/","content":"\n","categories":["Java"]},{"title":"将全景图应用到项目的方法","url":"/posts/%E5%B0%86%E5%85%A8%E6%99%AF%E5%9B%BE%E5%BA%94%E7%94%A8%E5%88%B0%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%B9%E6%B3%95/","content":"准备工作\n自己准备的全景图\npannellum.js文件\npannellum.css文件\n\n正式步骤\n将准备的三个文件移动到assets文件夹下\n\n在assets文件夹下创建index.html\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Panorama&lt;/title&gt;        &lt;link rel=&quot;stylesheet&quot; href=&quot;pannellum.css&quot;/&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;pannellum.js&quot;&gt;&lt;/script&gt;    &lt;style&gt;        html, body &#123;            margin: 0;            padding: 0;            width: 100%;            height: 100%;            overflow: hidden; /* 隐藏滚动条 */        &#125;        #panorama &#123;            width: 100%;            height: 100%;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;panorama&quot;&gt;&lt;/div&gt;&lt;script&gt;// 5. 初始化 Pannellumpannellum.viewer(&#x27;panorama&#x27;, &#123;    &quot;type&quot;: &quot;equirectangular&quot;,    &quot;panorama&quot;: &quot;my_panorama.jpg&quot;,  // &lt;-- 确保这个名字和你的图片文件名一致    &quot;autoLoad&quot;: true,    &quot;showControls&quot;: true // 显示控制按钮 (缩放、全屏)&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n布局添加webview\n&lt;androidx.constraintlayout.widget.ConstraintLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.ui.scenery.SceneryFragment&quot;&gt;    &lt;WebView        android:id=&quot;@+id/webView&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;0dp&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;    &lt;View        android:id=&quot;@+id/scrim&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;160dp&quot;        android:background=&quot;@drawable/scrim_bottom_dark&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/sceneryText&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:textColor=&quot;@android:color/white&quot;        android:textSize=&quot;18sp&quot;        android:textAlignment=&quot;center&quot;        android:lineSpacingExtra=&quot;4dp&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        android:layout_marginBottom=&quot;32dp&quot;        android:layout_marginStart=&quot;24dp&quot;        android:layout_marginEnd=&quot;24dp&quot;        /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n\n在drawable里面添加渐变scrim_bottom_dark.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;gradient        android:angle=&quot;90&quot;        android:startColor=&quot;#B3000000&quot;        android:endColor=&quot;@android:color/transparent&quot; /&gt;&lt;/shape&gt;\n\n界面布局\n// 定义延迟和动画时长 (毫秒)    private val START_DELAY_MS = 5000L  // 5秒后开始    private val FADE_DURATION_MS = 1000L // 1秒渐变     override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123;        super.onViewCreated(view, savedInstanceState)        //配置WebView        setupWebView()        //在这里启动淡出动画逻辑        startFadeOutAnimation()    &#125;private fun startFadeOutAnimation() &#123;        // 启动一个与 Fragment 视图生命周期绑定的协程        viewLifecycleOwner.lifecycleScope.launch &#123;            //  等待 5 秒            delay(START_DELAY_MS)            // 确保视图仍然存在（例如用户没有立即退出）            if (binding == null) return@launch            //同时执行蒙版和文本的淡出动画            binding.scrim.animate()                .alpha(0f)// 透明度变为 0（完全透明）                .setDuration(FADE_DURATION_MS)// 持续时间                .withEndAction &#123;                    //  动画结束后，彻底隐藏视图                    binding.scrim.visibility = View.GONE                &#125;                .start()            binding.sceneryText.animate()                .alpha(0f)                .setDuration(FADE_DURATION_MS)                .withEndAction &#123;                    //  动画结束后，彻底隐藏视图                    binding.sceneryText.visibility = View.GONE                &#125;                .start()        &#125;    &#125;    //配置WebView    @SuppressLint(&quot;SetJavaScriptEnabled&quot;)    private fun setupWebView() &#123;        // (这是您配置 WebView 的代码)        val webSettings: WebSettings = binding.webView.settings        webSettings.javaScriptEnabled = true        webSettings.allowFileAccess = true        webSettings.allowContentAccess = true        webSettings.allowFileAccessFromFileURLs = true        webSettings.allowUniversalAccessFromFileURLs = true        //加载你项目中的本地网页        binding.webView.loadUrl(&quot;file:///android_asset/index.html&quot;)    &#125;\n\n","categories":["Android随笔"]},{"title":"如何给项目引入AI助手","url":"/posts/%E5%A6%82%E4%BD%95%E7%BB%99%E9%A1%B9%E7%9B%AE%E5%BC%95%E5%85%A5AI%E5%8A%A9%E6%89%8B/","content":"这里拿Gemini进行示范\n先根据返回的JSON数据格式写出数据模型\n\n//AI的api调用请求体和响应体json格式不相同需要区别开来data class GeminiRequestBody(val contents:List&lt;Content&gt;)data class GeminiResponseBody(val candidates: List&lt;Candidate&gt;)data class Candidate(val content: Content)data class Content(val parts:List&lt;Part&gt;)data class Part(val text:String)\n\n\n定义接口，这里使用POST注解，GET注解只用于获取数据，这里不适用\n\ninterface AIService &#123;    @POST(&quot;v1beta/models/gemini-2.5-flash:generateContent&quot;)     suspend fun generateContent(        @Query(&quot;key&quot;) apiKey: String = MyApplication.GEMINI_API_KEY,        @Body requestBody: GeminiRequestBody    ) :Response&lt;GeminiResponseBody&gt;&#125;\n\n\n搭建Retrofit构建器\n\nobject AICreator &#123;    private const val BASE_URL = &quot;https://generativelanguage.googleapis.com/&quot;    private val retrofit = Retrofit.Builder()        .baseUrl(BASE_URL)        .addConverterFactory(GsonConverterFactory.create())        .build()            fun &lt;T&gt; create(serviceClass:Class&lt;T&gt;):T= retrofit.create(serviceClass)    inline fun &lt;reified T&gt;create():T=create(T::class.java)&#125;\n\n\n提交申请并对返回的数据进行解析\n\nobject AInetwork &#123;    //创建接口的动态代理对象    private val aiService = AICreator.create&lt;AIService&gt;()    //向AI服务器发送一个请求，并处理返回的结果。    suspend fun generateContent(requestBody: GeminiRequestBody): Result&lt;GeminiResponseBody&gt; &#123;        return try &#123;            val response = aiService.generateContent(requestBody=requestBody)            if (response.isSuccessful &amp;&amp; response.body() != null) &#123;                Result.success(response.body()!!)            &#125; else &#123;                val errorMessage = response.errorBody()?.string() ?: &quot;未知错误&quot;                Log.e(&quot;AInetwork&quot;, &quot;数据获取失败: $errorMessage&quot;)                Result.failure(RuntimeException(&quot;API请求失败: $&#123;response.code()&#125; - $errorMessage&quot;))            &#125;        &#125; catch (e: Exception) &#123;            Log.e(&quot;AInetwork&quot;, &quot;网络请求失败: $&#123;e.message&#125;&quot;, e)            Result.failure(e)        &#125;    &#125;&#125;\n\n\n进行调用\n\n//界面逻辑class AIActivity : AppCompatActivity() &#123;    private lateinit var binder: ActivityAiactivityBinding    private lateinit var viewModel: AIViewModel    private val  msgList=ArrayList&lt;Msg&gt;()    private var adapter: MsgAdapter? = null        override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        binder = ActivityAiactivityBinding.inflate(layoutInflater)        setContentView(binder.root)                // 初始化ViewModel        viewModel = ViewModelProvider(this)[AIViewModel::class.java]                // 设置工具栏        setSupportActionBar(binder.AiToolbar)        supportActionBar?.let &#123;            it.title = &quot;&quot;            it.setDisplayHomeAsUpEnabled(true)            it.setHomeAsUpIndicator(R.drawable.ic_return)        &#125;                // 设置RecyclerView        binder.AiRecyclerView.layoutManager = LinearLayoutManager(this)        adapter = MsgAdapter(msgList)        binder.AiRecyclerView.adapter = adapter                // 设置按钮点击事件        binder.AiButton.setOnClickListener &#123;            send()        &#125;                // 观察数据变化        observeViewModel()    &#125;    /**     * 观察ViewModel数据变化     */    private fun observeViewModel() &#123;        // 观察消息列表变化        viewModel.messages.observe(this) &#123; messages -&gt;            adapter?.let &#123; adapter -&gt;                // 更新适配器数据                adapter.updateMessages(messages)                // 滚动到最新消息                if (messages.isNotEmpty()) &#123;                    binder.AiRecyclerView.scrollToPosition(messages.size - 1)                &#125;            &#125;        &#125;        // 观察加载状态        viewModel.isLoading.observe(this) &#123; isLoading -&gt;            // 当AI正在思考时，禁用发送按钮            binder.AiButton.isEnabled = !isLoading        &#125;    &#125;        /**     * 发送消息     */    private fun send() &#123;        val content = binder.AiEditText.text.toString()        if (content.isNotEmpty()) &#123;            Log.d(&quot;AIActivity&quot;, &quot;用户发送问题: $content&quot;)                        // 清空输入框            binder.AiEditText.setText(&quot;&quot;)                        // 通过ViewModel发送消息            viewModel.sendMessage(content)        &#125;    &#125;    &#125;\n\n//ViewModel部分class AIViewModel : ViewModel() &#123;    // 消息列表    private val _messages = MutableLiveData&lt;List&lt;Msg&gt;&gt;()    val messages: LiveData&lt;List&lt;Msg&gt;&gt; = _messages    // 加载状态    private val _isLoading = MutableLiveData&lt;Boolean&gt;()    val isLoading: LiveData&lt;Boolean&gt; = _isLoading    // 错误状态    private val _error = MutableLiveData&lt;String?&gt;()    val error: LiveData&lt;String?&gt; = _error    // 内部消息列表    private val messageList = mutableListOf&lt;Msg&gt;()    init &#123;        _messages.value = messageList        _isLoading.value = false        _error.value = null    &#125;    /**     * 发送消息     */    fun sendMessage(content: String) &#123;        if (content.isBlank()) return        // 添加用户消息        addMessage(Msg(content, Msg.TYPE_SENT))        // 请求AI回复        requestAIResponse(content)    &#125;    /**     * 请求AI回复     */    private fun requestAIResponse(question: String) &#123;        viewModelScope.launch &#123;            try &#123;                _isLoading.value = true                _error.value = null                // 添加加载提示                addMessage(Msg(&quot;正在思考中...&quot;, Msg.TYPE_RESERVED))                // 在IO线程中执行网络请求                val result = withContext(Dispatchers.IO) &#123;                    val requestBody = GeminiRequestBody(                        contents = listOf(Content(parts = listOf(Part(text = question))))                    )                    AInetwork.generateContent(requestBody)                &#125;                // 移除加载提示                removeLastMessage()                // 处理结果                result.onSuccess &#123; response -&gt;                    val aiResponse = response.candidates.firstOrNull()?.content?.parts?.firstOrNull()?.text                    if (aiResponse.isNullOrEmpty()) &#123;                        addMessage(Msg(&quot;抱歉，我暂时无法回答您的问题。&quot;, Msg.TYPE_RESERVED))                    &#125; else &#123;                        addMessage(Msg(aiResponse, Msg.TYPE_RESERVED))                    &#125;                &#125;.onFailure &#123; exception -&gt;                    val errorMsg = &quot;网络请求失败: $&#123;exception.message&#125;&quot;                    addMessage(Msg(errorMsg, Msg.TYPE_RESERVED))                    _error.value = errorMsg                &#125;            &#125; catch (e: Exception) &#123;                removeLastMessage()                val errorMsg = &quot;发生未知错误，请稍后重试。&quot;                addMessage(Msg(errorMsg, Msg.TYPE_RESERVED))                _error.value = errorMsg            &#125; finally &#123;                _isLoading.value = false            &#125;        &#125;    &#125;    /**     * 添加消息到列表     */    private fun addMessage(message: Msg) &#123;        messageList.add(message)        _messages.value = messageList.toList()    &#125;    /**     * 移除最后一条消息     */    private fun removeLastMessage() &#123;        if (messageList.isNotEmpty()) &#123;            messageList.removeAt(messageList.size - 1)            _messages.value = messageList.toList()        &#125;    &#125;&#125;\n\n","categories":["AI"]},{"title":"广播机制(Kotlin)","url":"/posts/%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6-Kotlin/","content":"接收系统广播动态注册class MainActivity : AppCompatActivity() &#123;    // 声明广播接收器变量    lateinit var timeChangeReceiver:TimeChangeReceiver    // 声明视图绑定变量    private lateinit var binding:ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        // 初始化视图绑定        binding=ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        // 创建IntentFilter并添加系统时间变化的广播action        val intentFilter=IntentFilter()        intentFilter.addAction(&quot;android.intent.action.TIME_TICK&quot;)        // 初始化广播接收器        timeChangeReceiver=TimeChangeReceiver()        // 注册广播接收器        registerReceiver(timeChangeReceiver,intentFilter)    &#125;    override fun onDestroy() &#123;        super.onDestroy()        // 在Activity销毁时注销广播接收器，防止内存泄漏        unregisterReceiver(timeChangeReceiver)    &#125;    // 内部类：时间变化广播接收器    inner class TimeChangeReceiver:BroadcastReceiver()&#123;        override fun onReceive(context: Context?, intent: Intent?) &#123;            // 当接收到时间变化的广播时，显示Toast提示            Toast.makeText(context,&quot;Time has changed&quot;,Toast.LENGTH_SHORT).show()        &#125;    &#125;&#125;\n\n查看完整的系统广播列表(查看路径)：\n&#x2F;platforms&#x2F;&lt;任意 android api 版本&gt;&#x2F;data&#x2F;broadcast_actions.txt\n静态注册特点：开机自启动\n步骤：\n\n使用Android Studio创建的Broadcast Receiver,会自动注册\n\n添加相应的权限并添加action属性\nclass BootCompleteReceiver : BroadcastReceiver() &#123;    override fun onReceive(context: Context, intent: Intent) &#123;                Toast.makeText(context,&quot;Boot Complete&quot;,Toast.LENGTH_SHORT).show()    &#125;&#125;\n\n &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&lt;receiver      android:name=&quot;.BootCompleteReceiver&quot;      android:enabled=&quot;true&quot;      android:exported=&quot;true&quot;&gt;      &lt;intent-filter&gt;          &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;      &lt;/intent-filter&gt;  &lt;/receiver&gt;\n\n\n发送自定义广播发送标准广播\n新建BroadcastReceiver并定义接收逻辑\n\n在Manifest.xml中添加action属性\n\n构建Intent对象发送广播\nclass MyBroadcastReceiver : BroadcastReceiver() &#123;    override fun onReceive(context: Context, intent: Intent) &#123;        Toast.makeText(context,&quot;received in MyBroadcastReceiver&quot;,Toast.LENGTH_SHORT).show()        abortBroadcast()    &#125;&#125;\n\n&lt;receiver    android:name=&quot;.MyBroadcastReceiver&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot;&gt;    &lt;intent-filter android:priority=&quot;100&quot;&gt;        &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot; /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;\n\nclass MainActivity : AppCompatActivity() &#123;    // 声明视图绑定变量    private lateinit var binding:ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        // 初始化视图绑定        binding=ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        // 设置按钮点击事件        binding.button.setOnClickListener &#123;            // 创建自定义广播Intent            val intent=Intent(&quot;com.example.broadcasttest.MY_BROADCAST&quot;)            // 设置包名，将隐式广播转换为显式广播（Android 8.0及以上版本要求）            intent.setPackage(packageName)            //发送标准广播            sendBroadcast(intent)        &#125;    &#125;\n\n发送有序广播\n新建广播接收器\n\n添加action属性并设置优先级\n\n利用sendOrderedBroadcast()发送广播\n\n在广播接收器中使用abortBroadcast()方法可以中断后续广播发送\nclass AnotherBroadcastReceiver : BroadcastReceiver() &#123;    override fun onReceive(context: Context, intent: Intent) &#123;        Toast.makeText(context,&quot;received in AnotherBroadcastReceiver&quot;,Toast.LENGTH_SHORT).show()    &#125;&#125;\n\n&lt;receiver            android:name=&quot;.AnotherBroadcastReceiver&quot;            android:enabled=&quot;true&quot;            android:exported=&quot;true&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot;/&gt;            &lt;/intent-filter&gt;        &lt;/receiver&gt;        &lt;receiver            android:name=&quot;.MyBroadcastReceiver&quot;            android:enabled=&quot;true&quot;            android:exported=&quot;true&quot;&gt;            &lt;intent-filter android:priority=&quot;100&quot;&gt;//设置优先级                &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/receiver&gt;\n\n// 设置按钮点击事件        binding.button.setOnClickListener &#123;            // 创建自定义广播Intent            val intent=Intent(&quot;com.example.broadcasttest.MY_BROADCAST&quot;)            // 设置包名，将隐式广播转换为显式广播（Android 8.0及以上版本要求）            intent.setPackage(packageName)            // 发送有序广播            sendOrderedBroadcast(intent,null)        &#125;\n\nclass MyBroadcastReceiver : BroadcastReceiver() &#123;    override fun onReceive(context: Context, intent: Intent) &#123;        Toast.makeText(context,&quot;received in MyBroadcastReceiver&quot;,Toast.LENGTH_SHORT).show()        //截断广播        abortBroadcast()    &#125;&#125;\n\n\n","categories":["Android(Kotlin版)"]},{"title":"广播机制(Java)","url":"/posts/%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/","content":"广播机制简介标准广播\n有序广播\n\n接收系统广播动态注册监听网络变化简易版首先先创建一个类，按例子来是建立一个内部类，并在里面重写父类的onReceive()方法。\n然后在onCreate()方法中首先创建一个IntentFilter的实例，并给他添加一个值为”android.net.conn.CONNECTIVITY_CHANGE”的action，为什么添加这个值，就是因为当网络状态发生变化时，系统发出的正是一条值为”android.net.conn.CONNECTIVITY_CHANGE”的广播，也就是说想监听什么广播就要添加相应的action。接下来创建内部类实例然后调用 registerReceiver()方法进行注册，然后把NetworkChangeReceiver实例和IntentFilter实例都传进去。\n最后记的也要取消注册，在onDestroy()中调用 unregisterReceiver实现。\npublic class MainActivity extends AppCompatActivity &#123;    private IntentFilter intentFilter;    private NetworkChangeReceiver networkChangeReceiver;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        intentFilter=new IntentFilter();        intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);       networkChangeReceiver=new NetworkChangeReceiver();        registerReceiver(networkChangeReceiver, intentFilter);    &#125;    @Override    protected void onDestroy() &#123;        super.onDestroy();        unregisterReceiver( networkChangeReceiver);    &#125;    class NetworkChangeReceiver extends BroadcastReceiver&#123;        @Override        public void onReceive(Context context, Intent intent) &#123;            Toast.makeText(context, &quot;network changes&quot;, Toast.LENGTH_SHORT).show();        &#125;    &#125;&#125;\n\n优化版使提醒网络发生变化更人性化，可以进一步修改：\nclass NetworkChangeReceiver extends BroadcastReceiver &#123;  @Override  public void onReceive(Context context, Intent intent) &#123;   ConnectivityManager connectivityManager=(ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);   NetworkInfo networkInfo=connectivityManager.getActiveNetworkInfo();   if(networkInfo!=null&amp;&amp;networkInfo.isAvailable())&#123;    Toast.makeText(context, &quot;network is available&quot;, Toast.LENGTH_SHORT).show();   &#125;   else&#123;    Toast.makeText(context, &quot;network is unavailable&quot;, Toast.LENGTH_SHORT).show();   &#125;  &#125; &#125;\n\n首先通过getSystemService()方法得到ConnectivityManager实例，这是一个系统服务类，专门用于管理网络连接。然后调用他的getActiveNetworkInfo方法得到NetworkInfo实例，然后用它的isAvailable()方法判断是否有网络\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;\n静态注册实现开机启动动态注册的广播必须在程序启动之后才能实现，而静态注册的可以实现开机启动。\n先用Android Studio提供的快捷方式来创建一个广播接收器&lt;右击包-&gt;New-&gt;Other-&gt;Broadcast Receiver&gt;，然后修改其中代码，作为广播内容。\n其次静态注册的广播需要在Androidmanifest.xml中进行注册&lt;快捷方式创建，注册自动完成&gt;，然后在注册的receiver里面添加一条action\n&lt;intent-filter&gt;    &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;&lt;/intent-filter&gt;\n最后也要添加一项权限\n&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;\n\n自定义广播发送标准广播首先新建一个广播接收器\npublic class MyBroadcastReceiver extends BroadcastReceiver &#123;    @Override    public void onReceive(Context context, Intent intent) &#123;        Toast.makeText(context, &quot;received in MyBroadcastReceiver&quot;, Toast.LENGTH_SHORT).show();    &#125;&#125;\n\n然后在AndroidManifest中 添加一条action\n&lt;intent-filter&gt;    &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot;/&gt;&lt;/intent-filter&gt;\n\n接着可以定义一个按钮作为触发点\n然后修改主活动中的代码，首先构建出来一个Intent对象，并把要发送的广播的值传入，然后调用sendBroadcast()方法将广播消息发送，这样所有监听”com.example.broadcasttest.MY_BROADCAST”这条广播的接收器都会收到消息\n Button button=(Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123;  @Override  public void onClick(View view) &#123;   Intent intent=new Intent(&quot;com.example.casttest.MY_BROADCAST&quot;);   intent.setPackage(getPackageName());   sendBroadcast(intent);  &#125; &#125;);&#125;\n\n发送有序广播先新建一个广播接收器，用于接收自定义广播。并在广播接收器中添加想要显示的内容\npublic class AnotherBroadcastReceiver extends BroadcastReceiver &#123;    @Override    public void onReceive(Context context, Intent intent) &#123;        Toast.makeText(context, &quot;received in AnotherBroadcastReceiver&quot;, Toast.LENGTH_SHORT).show();    &#125;&#125;\n\n然后在AndroidManifest.xml中对该接收器进行修改添加一条action\n&lt;intent-filter&gt;      &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt;\n\n使用sendOrderedBroadcast()发送有序广播\nIntent intent=new Intent(&quot;com.example.broadcasttest.MY_BROADCAST&quot;);intent.setPackage(getPackageName());sendOrderedBroadcast(intent,null);\n\n设置优先级(在AndroidManifest中使用android:priority&#x3D;””设置优先级，优先级大的先执行)并利用abortBroadcast截断广播\n&lt;intent-filter android:priority=&quot;100&quot;&gt;\n在优先级高的广播接收器中使用abortBroadcast方法\n\n本地广播\n\n\n\n基本上和之前动态注册广播一样，只是首先通过LocalBroadcastManager的getInstance()方法获取一个他的实例，然后注册的时候调用LocalBroadcastManager的registerReceiver()方法，发送广播的时候调用LocalBroadcastManager的sendBroadcast()方法，仅此而已。\n以下是完整的代码展示：\npublic class MainActivity extends AppCompatActivity &#123;    private IntentFilter intentFilter;    private LocalReceiver localReceiver;    private LocalBroadcastManager localBroadcastManager;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        localBroadcastManager = LocalBroadcastManager.getInstance(this);        Button button = (Button) findViewById(R.id.button);        button.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                Intent intent = new Intent(&quot;com.example.broadcasttest.LOCAL_BROADCAST&quot;);                localBroadcastManager.sendBroadcast(intent);            &#125;        &#125;);        intentFilter = new IntentFilter();        intentFilter.addAction(&quot;com.example.broadcasttest.LOCAL_BROADCAST&quot;);        localReceiver = new LocalReceiver();        localBroadcastManager.registerReceiver(localReceiver, intentFilter);    &#125;    @Override    protected void onDestroy() &#123;        super.onDestroy();        localBroadcastManager.unregisterReceiver(localReceiver);    &#125;    class LocalReceiver extends BroadcastReceiver &#123;        @Override        public void onReceive(Context context, Intent intent) &#123;            Toast.makeText(context, &quot;received local broadcast&quot;, Toast.LENGTH_SHORT).show();        &#125;    &#125;&#125;\n\n\n","categories":["Android(Java版)"]},{"title":"手机多媒体(Kotlin)","url":"/posts/%E6%89%8B%E6%9C%BA%E5%A4%9A%E5%AA%92%E4%BD%93-Kotlin/","content":"通知(进阶)\n创建通知渠道\nval manager=getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager       if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)&#123;           /*参数介绍：           1.渠道id           2.渠道名称           3.重要等级           */           val channel=NotificationChannel(&quot;normal&quot;,&quot;Normal&quot;,NotificationManager.IMPORTANCE_DEFAULT)           val channel2=NotificationChannel(&quot;important&quot;,&quot;Important&quot;,NotificationManager.IMPORTANCE_HIGH)           //创建通道           manager.createNotificationChannel(channel2)           manager.createNotificationChannel(channel)       &#125;\n\n\n\n创建Notification对象\n\n通过连缀设置丰富的Notification对象\nval notification=NotificationCompat.Builder(this,&quot;important&quot;)                .setContentTitle(&quot;Title&quot;)                .setContentText(&quot;Text&quot;)                .setSmallIcon(R.drawable.small_icon)                .setLargeIcon(BitmapFactory.decodeResource(resources,R.drawable.large_icon))                .setContentIntent(pi)//点击界面跳转                .setAutoCancel(true)//点击后图标自动消失//富文本                .setStyle(NotificationCompat.BigTextStyle().bigText(&quot;Learn how to build notifications, send and sync data, and use voice actions. Get the official Android IDE and developer tools to build apps for Android.&quot;))    //显示图片.setStyle(NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(resources,R.drawable.big_image)))                .build()\n\n\n\n显示通知\nmanager.notify(1,notification)\n\n\n\n设置点击事件\n val intent=Intent(this,NotificationActivity::class.java) val pi=PendingIntent.getActivity(this,0,intent,0)//在Notification对象中加入setContentIntent连缀\n\n\n图标消失的两种方法：\n//1.在Notification对象后加setAutoCancel连缀//2.在界面跳转后的那个界面输入以下代码：//val manager=getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager//manager.cancel(1)“1”是指notify方法中传入的那个id\n\n\n调用摄像头和相册用摄像头拍照\n首先创建一个File对象，用于存储拍下的照片\n\n接下来通过判断版本进行操作，如果版本低于Android7.0就调用Uri的**fromFile()**方法转换为Uri对象（这个标识着图片的本地真实路径），如果版本高于7.0就调用FileProvider的getUriForFile()方法，将File转换成一个封装过的Uri对象\n\n构建Intent对象，启动相机程序(利用startActivityForResult进行启动)\n\n重写onActivityResult方法\n\n判断图片方向，如果需要旋转并进行旋转\n\n由于用到ContentProvider，故需要注册\n&lt;provider           android:authorities=&quot;com.example.cameraalbumtest.fileprovider&quot;           android:name=&quot;androidx.core.content.FileProvider&quot;           android:exported=&quot;false&quot;           android:grantUriPermissions=&quot;true&quot;           &gt;           &lt;meta-data               android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;               android:resource=&quot;@xml/file_paths&quot;/&gt;       &lt;/provider&gt;\n\n\n\n指定共享路径\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;external-path        name=&quot;my_images&quot;        path=&quot;/&quot;/&gt;&lt;/paths&gt;\n\n从相册中选择\n构建一个Intent对象表示打开文件选择器，并设置条件过滤\n结果返回到onActivityResult中，调用getBitmapFromUri方法将Uri转换成Bitmap对象\n将图片显示出来\n\nclass MainActivity : AppCompatActivity() &#123;    // ViewBinding对象    private lateinit var binding:ActivityMainBinding    // 从相册选择照片的请求码    val fromAlbum=2    // 拍照请求码    val takePhoto=1    // 用于存储拍照后图片的Uri    lateinit var imageUri:Uri    // 用于存储拍照后图片的文件    lateinit var outputImage:File    @SuppressLint(&quot;ObsoleteSdkInt&quot;)    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        // 启用沉浸式状态栏        enableEdgeToEdge()        // 初始化ViewBinding        binding=ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        // 适配系统窗口，防止内容被遮挡        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) &#123; v, insets -&gt;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)            insets        &#125;        // 拍照按钮点击事件        binding.takephoto.setOnClickListener &#123;            // 创建File对象，用于存储照片            outputImage=File(externalCacheDir,&quot;output_image.jpg&quot;)            if (outputImage.exists())&#123;                // 如果文件已存在则删除                outputImage.delete()            &#125;            // 创建新文件            outputImage.createNewFile()            // 判断Android版本，获取图片Uri            imageUri=if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.N)&#123;                // 7.0及以上使用FileProvider                /**                *第一个参数是Context                第二个参数是任意的唯一字符串                第三个是刚创建的File对象                **/                FileProvider.getUriForFile(this,&quot;com.example.cameraalbumtest.fileprovider&quot;,outputImage)            &#125;else&#123;                // 7.0以下直接使用Uri.fromFile                Uri.fromFile(outputImage)            &#125;            // 启动相机程序            val intent=Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;)            // 指定图片输出地址            intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri)            // 启动相机Activity            startActivityForResult(intent,takePhoto)        &#125;        // 从相册选择按钮点击事件        binding.fromAlbumBtn.setOnClickListener &#123;            // 打开文件选择器            val intent=Intent(Intent.ACTION_OPEN_DOCUMENT)            // 添加可打开的类别，确保文件可以被打开            intent.addCategory(Intent.CATEGORY_OPENABLE)            // 指定只显示图片类型的文件            intent.type=&quot;image/*&quot;            // 启动文件选择器Activity            startActivityForResult(intent,fromAlbum)        &#125;    &#125;    // 拍照Activity返回结果回调    override fun onActivityResult(        requestCode: Int,        resultCode: Int,        data: Intent?,        caller: ComponentCaller    ) &#123;        super.onActivityResult(requestCode, resultCode, data, caller)        when(requestCode)&#123;            takePhoto-&gt;&#123;                if(resultCode== Activity.RESULT_OK)&#123;                    // 将拍摄照片显示出来                    val bitmap=BitmapFactory.decodeStream(contentResolver.openInputStream(imageUri))                    // 处理图片旋转问题后显示                    binding.imageView.setImageBitmap(rotateIfRequired(bitmap))                &#125;            &#125;            // 处理从相册选择照片的返回结果            fromAlbum-&gt;&#123;                // 检查结果码是否成功且数据不为空                if(resultCode==Activity.RESULT_OK&amp;&amp;data!=null)&#123;                    // 获取选定图片的Uri                    data.data?.let &#123; uri-&gt;                        // 根据Uri获取Bitmap对象并显示                        val bitmap=getBitmapFromUri(uri)                        binding.imageView.setImageBitmap(bitmap)                    &#125;                &#125;            &#125;        &#125;    &#125;    // 根据Uri获取图片的Bitmap对象    private fun getBitmapFromUri(uri: Any)=contentResolver.openFileDescriptor(uri as Uri,&quot;r&quot;)?.use &#123;        // 使用文件描述符解码Bitmap        BitmapFactory.decodeFileDescriptor(it.fileDescriptor)    &#125;    // 判断图片是否需要旋转，并进行旋转    private fun rotateIfRequired(bitmap: Bitmap?): Bitmap? &#123;         val exif=ExifInterface(outputImage.path)        // 读取图片的旋转角度        val orientation=exif.getAttributeInt(ExifInterface.TAG_ORIENTATION,ExifInterface.ORIENTATION_NORMAL)        return when(orientation)&#123;            ExifInterface.ORIENTATION_ROTATE_90-&gt;rotateBitmap(bitmap,90)            ExifInterface.ORIENTATION_ROTATE_180-&gt;rotateBitmap(bitmap,180)            ExifInterface.ORIENTATION_ROTATE_270-&gt;rotateBitmap(bitmap,270)            else-&gt;bitmap        &#125;    &#125;    // 旋转Bitmap图片    private fun rotateBitmap(bitmap: Bitmap?, i: Int): Bitmap? &#123;            val matrix=Matrix()        // 设置旋转角度        matrix.postRotate(degree.toFloat())        // 创建旋转后的Bitmap        val rotatedBitmap=Bitmap.createBitmap(bitmap!!,0,0,bitmap.width,bitmap.height,matrix,true)        // 将不再需要的Bitmap对象回收，释放内存        bitmap.recycle()        return rotatedBitmap    &#125;&#125;\n\n\n\n\n播放多媒体播放音频\nMdeiaPlayer类常用方法\n\n\n过程\n\n首先在main文件夹下创建一个assets文件夹，在里面放入要播放的音频\n\n创建一个MediaPlayer对象\n\n初始化MdeiaPlayer对象\n\n利用MediaPlayer中的方法对音频文件状态进行判断并执行相应的操作\nclass MainActivity : AppCompatActivity() &#123;    private lateinit var binding:ActivityMainBinding    //创建对象    private val mediaPlayer=MediaPlayer()    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        enableEdgeToEdge()        binding=ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) &#123; v, insets -&gt;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)            insets        &#125;        //初始化        initMediaPlayer()        binding.play.setOnClickListener &#123;            if(!mediaPlayer.isPlaying)&#123;                mediaPlayer.start()//开始播放            &#125;        &#125;        binding.pause.setOnClickListener &#123;            if(mediaPlayer.isPlaying)&#123;                mediaPlayer.pause()//暂停播放            &#125;        &#125;        binding.stop.setOnClickListener &#123;            if(mediaPlayer.isPlaying)&#123;                //停止播放                mediaPlayer.reset()                initMediaPlayer()            &#125;        &#125;    &#125;    private fun initMediaPlayer() &#123;        //得到AssetManager实例，读取assets目录下任何资源        val assetManager=assets        //将音频文件句柄打开        val fd=assetManager.openFd(&quot;music.mp3&quot;)        //为音频做好播放前准备        mediaPlayer.setDataSource(fd.fileDescriptor,fd.startOffset,fd.length)        mediaPlayer.prepare()    &#125;    override fun onDestroy() &#123;        super.onDestroy()        mediaPlayer.stop()        mediaPlayer.release()    &#125;&#125;\n\n\n\n播放视频\nVideoView常用方法\n\n\n过程\n\n利用VideoView控件显示视频\n\n在res文件夹下新建raw文件夹放置视频文件\n\n利用VideoView中的方法对音频文件状态进行判断并执行相应的操作\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;Button            android:id=&quot;@+id/play&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:text=&quot;Play&quot;/&gt;        &lt;Button            android:id=&quot;@+id/pause&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:text=&quot;Pause&quot;/&gt;        &lt;Button            android:id=&quot;@+id/replay&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:text=&quot;Replay&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;VideoView        android:id=&quot;@+id/videoView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;\n\nclass MainActivity : AppCompatActivity() &#123;    private lateinit var binding:ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        enableEdgeToEdge()        binding=ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) &#123; v, insets -&gt;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)            insets        &#125;        val uri=Uri.parse(&quot;android.resource://$packageName/$&#123;R.raw.video&#125;&quot;)        binding.videoView.setVideoURI(uri)        binding.play.setOnClickListener &#123;            if(!binding.videoView.isPlaying)&#123;                binding.videoView.start()            &#125;        &#125;        binding.pause.setOnClickListener &#123;            if(binding.videoView.isPlaying)&#123;                binding.videoView.pause()            &#125;        &#125;        binding.replay.setOnClickListener &#123;            if(binding.videoView.isPlaying)&#123;                binding.videoView.resume()            &#125;        &#125;    &#125;    override fun onDestroy() &#123;        super.onDestroy()        binding.videoView.suspend()    &#125;&#125;\n\n\n\n\n","categories":["Android(Kotlin版)"]},{"title":"探究ContentProvider(Kotlin)","url":"/posts/%E6%8E%A2%E7%A9%B6ContentProvider-Kotlin/","content":"运行时权限权限机制\n分类\n普通权限和危险权限（还包括一些特殊权限但使用不多，不参与讨论）\n\n危险权限\n\n\n特点\n普通权限直接在AndroidManifest.xml中声明即可\n危险权限需要进行运行时权限处理\n原则上用户一旦同意某一个权限申请，同组的其它权限会自动授权，但不要基于此规则来实现任何逻辑功能\n\n\n运行时申请权限1.在AndroidManifest.xml中声明权限\n&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt;\n\n2.检查权限是否授权\nif (ContextCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) &#123;             // 修正权限请求的字符串格式               ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CALL_PHONE), 1)            &#125; else &#123;               call()           &#125;\n\n3.调用onRequestPermissionsResult()方法申请授权\noverride fun onRequestPermissionsResult(        requestCode: Int,        permissions: Array&lt;out String&gt;,        grantResults: IntArray    ) &#123;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)        when(requestCode)&#123;            1-&gt;&#123;                if(grantResults.isNotEmpty()&amp;&amp;grantResults[0]==PackageManager.PERMISSION_GRANTED)&#123;                    call()                &#125;else&#123;                   Toast.makeText(this, &quot;You denied the permission&quot;, Toast.LENGTH_SHORT).show()                &#125;            &#125;        &#125;    &#125;\n\n4.把权限授权后执行的逻辑封装\nprivate fun call() &#123;       try &#123;           val intent=Intent(Intent.ACTION_CALL)           intent.data=Uri.parse(&quot;tel:10086&quot;)           startActivity(intent)       &#125;catch (e:SecurityException)&#123;           e.printStackTrace()       &#125;   &#125;\n\n\nContentProvider基本用法 1.获取 ContentResolver 实例\n在 Android 中，通常通过上下文（Context）来获取 ContentResolver 实例：\nval contentResolver = context.contentResolver\n\n2.添加数据\ninsert() 方法用于在 ContentProvider 中插入新数据，参数说明如下：\n\nuri：目标数据的 URI\n\nContentValues：存储键值对数据\nval uri = Uri.parse(&quot;content://com.example.app.provider/city&quot;)val values = ContentValues().apply &#123;    put(&quot;name&quot;, &quot;Beijing&quot;)    put(&quot;code&quot;, &quot;BJ&quot;)&#125;val newUri = contentResolver.insert(uri, values)println(&quot;插入成功，新记录URI：$newUri&quot;)\n\n3.删除数据\ndelete() 方法用于删除 ContentProvider 中的数据，参数说明如下：\n\nuri：目标数据的 URI\n\nselection：删除条件\n\nselectionArgs：条件参数数组\nval uri = Uri.parse(&quot;content://com.example.app.provider/city&quot;)val selection = &quot;id = ?&quot;val selectionArgs = arrayOf(&quot;1&quot;)val deleteCount = contentResolver.delete(uri, selection, selectionArgs)println(&quot;删除了 $deleteCount 条记录&quot;)\n\n4.查询数据\nquery() 方法用于从 ContentProvider 查询数据，参数说明如下：\n\nuri：需要访问的数据的 URI，例如：content://com.example.app.provider/city\n\nprojection：需要查询的列数组，如果传入 null，则返回所有列\n\nselection：过滤条件（WHERE 子句），可使用 ? 占位符\n\nselectionArgs：过滤条件对应的参数数组\n\nsortOrder：排序规则\nval uri = Uri.parse(&quot;content://com.example.app.provider/city&quot;)val projection = arrayOf(&quot;id&quot;, &quot;name&quot;, &quot;code&quot;)val cursor = contentResolver.query(uri, projection, null, null, &quot;id ASC&quot;)cursor?.use &#123;    while (it.moveToNext()) &#123;        val id = it.getInt(it.getColumnIndexOrThrow(&quot;id&quot;))        val name = it.getString(it.getColumnIndexOrThrow(&quot;name&quot;))        val code = it.getString(it.getColumnIndexOrThrow(&quot;code&quot;))        println(&quot;City: id=$id, name=$name, code=$code&quot;)    &#125;&#125;\n\n5.更新数据\nupdate() 方法用于更新 ContentProvider 中的数据，参数说明如下：\n\nuri：目标数据的 URI\n\nContentValues：存储需要更新的字段和值\n\nselection：指定更新条件\n\nselectionArgs：条件参数数组\nval uri = Uri.parse(&quot;content://com.example.app.provider/city&quot;)val values = ContentValues().apply &#123;    put(&quot;name&quot;, &quot;Shanghai&quot;)&#125;val selection = &quot;id = ?&quot;val selectionArgs = arrayOf(&quot;1&quot;)val updateCount = contentResolver.update(uri, values, selection, selectionArgs)println(&quot;更新了 $updateCount 条记录&quot;)\n\n\n创建ContentProvider\n新建一个类继承ContentProvider并重写6个方法(onCreate(),query(),insert(),update(),delete(),getType())\n\n实现数据操作\n\nquery()：根据传入的 URI 查询数据，并返回一个 Cursor 对象。\ninsert()：根据传入的 URI 插入数据，返回新插入数据的 URI。\nupdate()：根据 URI 更新数据，返回受影响的行数。\ndelete()：根据 URI 删除数据，返回删除的行数。\ngetType()：返回指定 URI 对应的数据 MIME 类型。\n\n\n配置 URI 匹配器 使用 UriMatcher 对传入的 URI 进行匹配，以便确定请求类型并执行相应操作。可以在静态代码块中添加匹配规则\n\n\nprivate static final UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);init &#123;    uriMatcher.addURI(&quot;your.authority&quot;, &quot;your_path&quot;, CODE_CONSTANT);&#125;\n\n\n在 AndroidManifest.xml 中注册 ContentProvider 在清单文件中注册你的 ContentProvider：\n\n&lt;provider    android:name=&quot;.YourContentProvider&quot;    android:authorities=&quot;your.authority&quot;    android:exported=&quot;true&quot; /&gt;\n\n注意：android:exported 的值根据你的需求设置为 true 或 false。\n\n通配符\n*表示匹配任意长度的任意字符\n#表示匹配任意长度的数字\n\nMIME字符串组成\n\nvnd开头\n如果内容URI以路径结尾则接android.cursor.dir&#x2F;，如果内容URI以id结尾则接android.cursor.item&#x2F;\n最后接上vnd..\n\n\n\n/** * 数据库内容提供器 * 用于对外共享数据库中的数据，实现跨应用数据访问 */class DatabaseProvider : ContentProvider() &#123;    // URI匹配码    private val bookDir = 0      // 访问图书表中的所有数据    private val bookItem = 1     // 访问图书表中的单条数据    private val categoryDir = 2  // 访问分类表中的所有数据    private val categoryItem = 3 // 访问分类表中的单条数据        // 内容提供器的唯一标识    private val authority = &quot;com.example.databasetest.provider&quot;    // 数据库帮助类实例    private var dbHelper: MyDatabaseHelper? = null        /**     * 懒加载初始化UriMatcher     * 用于匹配内容URI，分别添加四种URI匹配规则     */    private val uriMatcher by lazy &#123;        val matcher = UriMatcher(UriMatcher.NO_MATCH)        matcher.addURI(authority, &quot;book&quot;, bookDir)         // content://com.example.databasetest.provider/book        matcher.addURI(authority, &quot;book/#&quot;, bookItem)      // content://com.example.databasetest.provider/book/1        matcher.addURI(authority, &quot;category&quot;, categoryDir) // content://com.example.databasetest.provider/category        matcher.addURI(authority, &quot;category/#&quot;, categoryItem) // content://com.example.databasetest.provider/category/1        matcher    &#125;    /**     * 删除数据     * @param uri 待删除数据的URI     * @param selection WHERE约束条件     * @param selectionArgs WHERE约束条件的参数     * @return 删除的行数     */    override fun delete(uri: Uri, selection: String?, selectionArgs: Array&lt;String&gt;?) = dbHelper?.let &#123;        val db = it.writableDatabase        val deletedRows = when (uriMatcher.match(uri)) &#123;            bookDir -&gt; db.delete(&quot;Book&quot;, selection, selectionArgs)            bookItem -&gt; &#123;                val bookId = uri.pathSegments[1]  // 获取图书id                db.delete(&quot;Book&quot;, &quot;id = ?&quot;, arrayOf(bookId))            &#125;            categoryDir -&gt; db.delete(&quot;Category&quot;, selection, selectionArgs)            categoryItem -&gt; &#123;                val categoryId = uri.pathSegments[1]  // 获取分类id                db.delete(&quot;Category&quot;, &quot;id = ?&quot;, arrayOf(categoryId))            &#125;            else -&gt; 0        &#125;        deletedRows    &#125; ?: 0    /**     * 根据URI返回MIME类型     * vnd.android.cursor.dir/表示返回多条数据     * vnd.android.cursor.item/表示返回单条数据     */    override fun getType(uri: Uri) = when (uriMatcher.match(uri)) &#123;        bookDir -&gt; &quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.book&quot;        bookItem -&gt; &quot;vnd.android.cursor.item/vnd.com.example.databasetest.provider.book&quot;        categoryDir -&gt; &quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.category&quot;        categoryItem -&gt; &quot;vnd.android.cursor.item/vnd.com.example.databasetest.provider.category&quot;        else -&gt; null    &#125;    /**     * 插入数据     * @param uri 待插入的位置     * @param values 待插入的数据     * @return 新插入数据的URI     */    override fun insert(uri: Uri, values: ContentValues?) = dbHelper?.let &#123;        val db = it.writableDatabase        val uriReturn = when(uriMatcher.match(uri)) &#123;            bookDir, bookItem -&gt; &#123;                val newBookId = db.insert(&quot;Book&quot;, null, values)                Uri.parse(&quot;content://$authority/book/$newBookId&quot;)            &#125;            categoryDir, categoryItem -&gt; &#123;                val newCategoryId = db.insert(&quot;Category&quot;, null, values)                Uri.parse(&quot;content://$authority/category/$newCategoryId&quot;)            &#125;            else -&gt; null        &#125;        uriReturn    &#125;    /**     * 初始化内容提供器     * @return 初始化是否成功     */    override fun onCreate() = context?.let &#123;        dbHelper = MyDatabaseHelper(it, &quot;BookStore.db&quot;, 2)        true    &#125; ?: false    /**     * 查询数据     * @param uri 查询的URI     * @param projection 查询的列名     * @param selection WHERE约束条件     * @param selectionArgs WHERE约束条件的参数     * @param sortOrder 排序方式     * @return 查询的结果集     */    override fun query(        uri: Uri, projection: Array&lt;String&gt;?, selection: String?,        selectionArgs: Array&lt;String&gt;?, sortOrder: String?    ) = dbHelper?.let &#123;        val db = it.readableDatabase        val cursor = when(uriMatcher.match(uri)) &#123;            bookDir -&gt; db.query(&quot;Book&quot;, projection, selection, selectionArgs, null, null, sortOrder)            bookItem -&gt; &#123;                val bookId = uri.pathSegments[1]                db.query(&quot;Book&quot;, projection, &quot;id=?&quot;, arrayOf(bookId), null, null, sortOrder)            &#125;            categoryDir -&gt; db.query(&quot;Category&quot;, projection, selection, selectionArgs, null, null, sortOrder)            categoryItem -&gt; &#123;                val categoryId = uri.pathSegments[1]                db.query(&quot;Category&quot;, projection, &quot;id=?&quot;, arrayOf(categoryId), null, null, sortOrder)            &#125;            else -&gt; null        &#125;        cursor    &#125;    /**     * 更新数据     * @param uri 更新的URI     * @param values 新的值     * @param selection WHERE约束条件     * @param selectionArgs WHERE约束条件的参数     * @return 更新的行数     */    override fun update(        uri: Uri, values: ContentValues?, selection: String?,        selectionArgs: Array&lt;String&gt;?    ) = dbHelper?.let &#123;        val db = it.writableDatabase        val updatedRows = when(uriMatcher.match(uri)) &#123;            bookDir -&gt; db.update(&quot;Book&quot;, values, selection, selectionArgs)            bookItem -&gt; &#123;                val bookId = uri.pathSegments[1]                db.update(&quot;Book&quot;, values, &quot;id=?&quot;, arrayOf(bookId))            &#125;            categoryDir -&gt; db.update(&quot;Category&quot;, values, selection, selectionArgs)            categoryItem -&gt; &#123;                val categoryId = uri.pathSegments[1]                db.update(&quot;Category&quot;, values, &quot;id=?&quot;, arrayOf(categoryId))            &#125;            else -&gt; 0        &#125;        updatedRows    &#125; ?: 0&#125;\n\n\n","categories":["Android(Kotlin版)"]},{"title":"数据存储(Kotlin)","url":"/posts/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8-Kotlin/","content":"文件存储存储数据\n通过openFileOutput()得到FileOutputStream对象\n\n借助它构建一个OutputStreamWriter对象在借助这个构建一个BufferedWriter对象\n\n利用BufferedWriter将内容写入文件\nprivate fun save(inputText: String) &#123;        try &#123;           val output=openFileOutput(&quot;data&quot;,Context.MODE_PRIVATE)            val writer=BufferedWriter(OutputStreamWriter(output))            writer.use&#123;                it.write(inputText)            &#125;        &#125; catch (e: IOException) &#123;            e.printStackTrace()        &#125;    &#125;\n\n读取数据\n通过openFileInput()方法获取了一个FileInputStream对象\n\n利用它构建InputStreamReader()对象再借助这个构建BufferedReader对象\n\n最后利用这个对象将文件一行行读取出来并拼接到StringBuilder对象中\nprivate fun load(): String &#123;       val content = StringBuilder()       try &#123;               val input=openFileInput(&quot;data&quot;)               val reader=BufferedReader(InputStreamReader(input))                   reader.use&#123;                       reader.forEachLine&#123;                           content.append(it)                       &#125;                   &#125;       &#125; catch (e: IOException) &#123;           e.printStackTrace()              &#125;       return content.toString()   &#125;\n\n\nSharedPreferences存储数据\n得到SharedPreferences对象\n(1)Context类中的getSharedPreferences()方法得到（第一个参数是文件名，第二个是模式）\n(2)Activity类中的getPreferences()方法得到（只接收模式参数）\n\n调用其edit()方法得到SharedPreferences.Editor对象\n\n像这个对象中添加数据\n\n调用apply()提交数据\nval editor=getSharedPreferences(&quot;data&quot;, Context.MODE_PRIVATE).edit()editor.putString(&quot;name&quot;,&quot;Tom&quot;)editor.putInt(&quot;age&quot;,28)editor.putBoolean(&quot;married&quot;,false)editor.apply()\n\n读取数据\n得到SharedPreferences对象\n\n调用get系列方法获取数据\nval prefs=getSharedPreferences(&quot;data&quot;,Context.MODE_PRIVATE)            val name=prefs.getString(&quot;name&quot;,&quot;&quot;)            val age=prefs.getInt(&quot;age&quot;,0)            val married=prefs.getBoolean(&quot;married&quot;,false)\n\n\nSQLite数据库创建和升级\n创建\n\n新建一个类继承自SQLiteOpenHelper\n建立表格\n在onCreate方法中使用execSQL()方法在数据库中创建表格\n在活动中使用writableDatabase方法创建数据库\n\n\n升级\n\n在帮助类中建立新的表格或作出一些更改\n如果建立新的表格需要在oncreate方法中用execSQL()方法创建表格\n在onUpgrade()方法中使用execSQL()方法进行更新再调用onCreate()\n活动中数据库版本号改为比原来大的数字\n\n\n\nclass MyDatabaseHelper(val context:Context,name:String,version: Int) :SQLiteOpenHelper(context,name,null,version)&#123;   private val createBook=&quot;create table Book(&quot;+           &quot;id integer primary key autoincrement,&quot;+           &quot;author text,&quot;+           &quot;price real,&quot;+           &quot;pages integer,&quot;+           &quot;name text)&quot;    private val createCategory=&quot;create table Category(&quot;+            &quot;id integer primary key autoincrement,&quot;+            &quot;category_name text,&quot;+            &quot;category_code integer)&quot;    override fun onCreate(db: SQLiteDatabase) &#123;        db.execSQL(createBook)        db.execSQL(createCategory)        Toast.makeText(context,&quot;Create succeeded&quot;,Toast.LENGTH_SHORT).show()    &#125;    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123;         db.execSQL(&quot;drop table if exists Book&quot;)        db.execSQL(&quot;drop table if exists Category&quot;)        onCreate(db)    &#125;&#125;\n\n添加，更新，删除，查询\n添加\n\n调用SQLiteOpenHelper的writableDatabase方法获取SQLiteDataBase对象\n\n利用ContentValues()对象组装数据\n\n利用insert方法插入数据\nbinding.addData.setOnClickListener &#123;            //获取SQLiteDatabase对象            val db=dbHelper.writableDatabase            //组装第一条数据            val values1=ContentValues().apply &#123;                put(&quot;name&quot;,&quot;The Da Vinci Code&quot;)                put(&quot;author&quot;,&quot;Dan Brown&quot;)                put(&quot;pages&quot;,454)                put(&quot;price&quot;,16.96)            &#125;            //插入第一条数据            db.insert(&quot;Book&quot;,null,values1)            //组装第二条数据            val values2=ContentValues().apply &#123;                put(&quot;name&quot;,&quot;The Lost Symbol&quot;)                put(&quot;author&quot;,&quot;Dan Brown&quot;)                put(&quot;pages&quot;,510)                put(&quot;price&quot;,19.95)            &#125;            //插入第二条数据            db.insert(&quot;Book&quot;,null,values2)        &#125;\n\n\n更新\n\n获取SQLiteDataBase对象\n\n获取ContentValues对象\n\n指定更新的数据\n\n利用update更新数据\nbinding.updateData.setOnClickListener &#123;            //获取SQLiteDatabase对象            val db=dbHelper.writableDatabase            val value=ContentValues()            value.put(&quot;price&quot;,10.99)            db.update(&quot;Book&quot;,value,&quot;name=?&quot;,arrayOf(&quot;The Da Vinci Code&quot;))        Toast.makeText(this,&quot;更新成功&quot;,Toast.LENGTH_SHORT).show()        &#125;\n\n\n删除\n\n获取SQLiteDataBase对象\n\n利用delete删除数据\nbinding.deleteData.setOnClickListener &#123;            //获取SQLiteDatabase对象            val db=dbHelper.writableDatabase            db.delete(&quot;Book&quot;,&quot;pages&gt;?&quot;,arrayOf(&quot;500&quot;))            Toast.makeText(this,&quot;删除成功&quot;,Toast.LENGTH_SHORT).show()        &#125;\n\n\n查询\n\n获取SQLiteDataBase对象 \n\n调用query方法查询数据\n\n查询后得到Cursor对象,遍历查询每一行数据在循环中通过Cursor的getColumnIndex()方法索引\n\n查询完成后关闭Cursor\nbinding.queryData.setOnClickListener &#123;           //获取SQLiteDatabase对象           val db=dbHelper.writableDatabase           //查询Book中所有数据           val cursor=db.query(&quot;Book&quot;,null,null,null,null,null,null)           if(cursor.moveToFirst())&#123;               do&#123;//遍历Cursor对象，取出数据并打印                   val name=cursor.getString(cursor.getColumnIndex(&quot;name&quot;))                   val author=cursor.getString(cursor.getColumnIndex(&quot;author&quot;))                   val pages=cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;))                   val price=cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;))                   Log.d(&quot;MainActivity&quot;, &quot;book name is $name &quot;)                   Log.d(&quot;MainActivity&quot;, &quot;book author is $author &quot;)                   Log.d(&quot;MainActivity&quot;, &quot;book pages is $pages &quot;)                   Log.d(&quot;MainActivity&quot;, &quot;book price is $price &quot;)               &#125;while (cursor.moveToNext())                &#125;           cursor.close()       &#125;\n\n\n\nSQL操作数据库//添加数据db.execSQL(&quot;insert into Book(name,author,pages,price) values(?,?,?,?)&quot;,          arrayOf(&quot;The Da Vinci Code&quot;,&quot;Dan Brown&quot;,&quot;454&quot;,&quot;16.96&quot;)          )db.execSQL(&quot;insert into Book(name,author,pages,price) values(?,?,?,?)&quot;,          arrayOf(&quot;The Lost Symbol&quot;,&quot;Dan Brown&quot;,&quot;510&quot;,&quot;19.95&quot;)          )//更新数据db.execSQL(&quot;update Book set price=? where name=? &quot;,arrayOf(&quot;10.99&quot;,&quot;The Da Vinci Code&quot;))//删除数据db.execSQL(&quot;delete from book where pages&gt;?&quot;,arrayOf(&quot;500&quot;))//查询数据val cursor=db.rawQuery(&quot;select * from Book&quot;,null)\n\n\n\n使用事务特点：操作要失败一起失败要成功一起成功\nbinding.replaceData.setOnClickListener &#123;           //获取SQLiteDatabase对象           val db=dbHelper.writableDatabase           //开启事务           db.beginTransaction()           try &#123;               db.delete(&quot;Book&quot;,null,null)               /*if(true)&#123;                   //手动抛出异常，让事务失败                   throw NullPointerException()               &#125;*/               val values=ContentValues().apply &#123;                   put(&quot;name&quot;,&quot;Game of Thrones&quot;)                   put(&quot;author&quot;,&quot;George Martin&quot;)                   put(&quot;pages&quot;,720)                   put(&quot;price&quot;,20.85)               &#125;               db.insert(&quot;Book&quot;,null,values)               //事务已经执行成功               db.setTransactionSuccessful()           &#125;catch (e:Exception)&#123;               e.printStackTrace()           &#125;finally &#123;               //结束事务               db.endTransaction()           &#125;       &#125;\n\n\n\n升级数据库最佳写法每进行一次更新都在onUpgrade()方法中加入一个if判断语句\n这样就算跨版本升级也不会出现数据丢失\nclass MyDatabaseHelper(val context:Context,name:String,version: Int) :SQLiteOpenHelper(context,name,null,version)&#123;   private val createBook=&quot;create table Book(&quot;+           &quot;id integer primary key autoincrement,&quot;+           &quot;author text,&quot;+           &quot;price real,&quot;+           &quot;pages integer,&quot;+           &quot;name text,&quot;+           &quot;category_id)&quot;    private val createCategory=&quot;create table Category(&quot;+            &quot;id integer primary key autoincrement,&quot;+            &quot;category_name text,&quot;+            &quot;category_code integer)&quot;    override fun onCreate(db: SQLiteDatabase) &#123;        db.execSQL(createBook)        db.execSQL(createCategory)        Toast.makeText(context,&quot;Create succeeded&quot;,Toast.LENGTH_SHORT).show()    &#125;    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123;        if(oldVersion&lt;=1)&#123;            db.execSQL(createCategory)        &#125;        if(oldVersion&lt;=2)&#123;            db.execSQL(&quot;alter table Book add column category_id integer&quot;)        &#125;    &#125;&#125;\n\n\n","categories":["Android(Kotlin版)"]},{"title":"手机多媒体(Java)","url":"/posts/%E6%89%8B%E6%9C%BA%E5%A4%9A%E5%AA%92%E4%BD%93/","content":"通知(进阶)1.创建通知通道并请求通知权限\n2.用getSystemService()获取一个NotificationManager对通知进行管理\n3.创建Notification对象并进行一些基础设置\n4.用notify()显示通知\n/** * 演示通知功能的主活动类 */public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        // 加载布局文件        setContentView(R.layout.activity_main);        // 创建通知通道（仅在 Android 8.0 及以上版本需要）        createNotificationChannel();        // 获取按钮控件并绑定点击事件        Button sendNotice = findViewById(R.id.send_notice);        sendNotice.setOnClickListener(this);    &#125;    @Override    public void onClick(View v) &#123;        // 判断是否是发送通知按钮被点击        if (v.getId() == R.id.send_notice) &#123;            try &#123;                // 创建一个Intent，用于在通知被点击时启动NotificationActivity                Intent intent = new Intent(this, NotificationActivity.class);                // 创建一个PendingIntent，作为通知的点击动作                PendingIntent pi = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);                // 获取通知管理器实例                NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);                // 构建通知对象                Notification notification = new NotificationCompat.Builder(this, &quot;default_channel_id&quot;)                        // 设置通知标题                        .setContentTitle(&quot;This is content title&quot;)                        // 设置通知内容                        .setContentText(&quot;Learn how to build notifications, send and sync data, and use voice actions. Get the official Android IDE and developer tools to build apps for Android.&quot;)                        // 设置通知时间                        .setWhen(System.currentTimeMillis())                        // 设置小图标                        .setSmallIcon(R.mipmap.ic_launcher)                        // 设置大图标                        .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))                        // 设置通知点击的Intent                        .setContentIntent(pi)                        // 设置自动取消通知                        .setAutoCancel(true)                        // 设置默认通知声音、震动、灯光                        .setDefaults(NotificationCompat.DEFAULT_ALL)                        // 使用大文本样式                        .setStyle(new NotificationCompat.BigTextStyle().bigText(&quot;Learn how to build notifications, send and&quot; +                                &quot;sync data, and use voice actions,Get the official Android IDE and developer tools to build apps for Android.&quot;))                        // 设置通知优先级                        .setPriority(NotificationCompat.PRIORITY_MAX)                        // 构建通知对象                        .build();                // 处理 Android 13 及以上版本的 POST_NOTIFICATIONS 权限                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) &#123;                    if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) &#123;                        // 如果没有权限，请求权限                        ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.POST_NOTIFICATIONS&#125;, 1);                    &#125; else &#123;                        // 如果有权限，发送通知                        manager.notify(1, notification);                    &#125;                &#125; else &#123;                    // Android 13 以下版本直接发送通知                    manager.notify(1, notification);                &#125;            &#125; catch (Exception e) &#123;                // 捕获并处理异常                e.printStackTrace();                Toast.makeText(this, &quot;发送通知失败： &quot; + e.getMessage(), Toast.LENGTH_LONG).show();            &#125;        &#125;    &#125;    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);        // 获取通知管理器实例        NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);        try &#123;            // 重新构建通知对象（与 onClick 中相同）            Notification notification = new NotificationCompat.Builder(this, &quot;default_channel_id&quot;)                    .setContentTitle(&quot;This is content title&quot;)                    .setContentText(&quot;Learn how to build notifications, send and sync data, and use voice actions. Get the official Android IDE and developer tools to build apps for Android.&quot;)                    .setWhen(System.currentTimeMillis())                    .setSmallIcon(R.mipmap.ic_launcher)                    .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))                    .setAutoCancel(true)                    .setDefaults(NotificationCompat.DEFAULT_ALL)                    .setStyle(new NotificationCompat.BigTextStyle().bigText(&quot;Learn how to build notifications, send and&quot; +                            &quot;sync data, and use voice actions,Get the official Android IDE and developer tools to build apps for Android.&quot;))                    .setPriority(NotificationCompat.PRIORITY_MAX)                    .build();            // 根据请求码处理权限请求结果            switch (requestCode) &#123;                case 1:                    // 处理 POST_NOTIFICATIONS 权限请求结果                    if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;                        // 权限授予，发送通知                        manager.notify(1, notification);                    &#125; else &#123;                        // 权限被拒绝，显示提示信息                        Toast.makeText(this, &quot;You denied the permission&quot;, Toast.LENGTH_SHORT).show();                    &#125;                    break;                default:                    // 处理其他请求码                    break;            &#125;        &#125; catch (Exception e) &#123;            // 捕获并处理异常            e.printStackTrace();            Toast.makeText(this, &quot;发送通知失败： &quot; + e.getMessage(), Toast.LENGTH_LONG).show();        &#125;    &#125;    /**     * 创建通知通道（仅在 Android 8.0 及以上版本需要）     * 通知通道用于分组和管理不同的通知     */    private void createNotificationChannel() &#123;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;            // 创建一个 NotificationChannel 对象            NotificationChannel channel = new NotificationChannel(                    &quot;default_channel_id&quot;, // 通道 ID                    &quot;Default Channel&quot;,    // 通道名称                    NotificationManager.IMPORTANCE_DEFAULT // 重要性级别            );            // 获取通知管理器实例            NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);            // 创建通知通道            manager.createNotificationChannel(channel);        &#125;    &#125;&#125;\n\npublic class NotificationActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.notification_layout);        NotificationManager manager=(NotificationManager) getSystemService(NOTIFICATION_SERVICE);        manager.cancel(1);    &#125;&#125;\n\n&lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt;\n\n\n\n\n摄像头和相册调用摄像头拍照1.设置Button和ImageView控件\n2.申请相机权限,创建File对象存放在SD卡的应用关联缓存目录下\n3.把File转换为Uri,被内容提供器FileProvider通过getUriForFile()接收\n4.构建intent启动相机\n5.重写onActivityResult处理结果\n6.在AndroidManifest.xml注册内容提供器,声明权限\n7.在xml目录下创建file_paths.xml共享路径\npublic class MainActivity extends AppCompatActivity &#123;    public static final int TAKE_PHOTO=1;//声明一个请求码，用于识别返回的结果    public static final int CHOOSE_PHOTO=2;    private ImageView picture;    private Uri imageUri;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button takePhoto=(Button) findViewById(R.id.take_photo);        picture =(ImageView) findViewById(R.id.picture);        takePhoto.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                //创建File对象，用于存储拍照后的图片                File outputImage=new File(getExternalCacheDir(),&quot;output_image.jpg&quot;);                try //判断图片是否存在，存在则删除重建，不存在则直接创建                &#123;                    if(outputImage.exists())&#123;                        outputImage.delete();                    &#125;                    outputImage.createNewFile();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;                if(Build.VERSION.SDK_INT&gt;=24)                    //判断安卓的版本是否高于7.0，高于则调用高于的方法，低于则调用低于的方法                    //把文件转化成Uri对象                    /*之所以这样是因为android7.0之后直接使用本地真实路径是不安全的，会抛出异常。                    FileProvider是一种特殊的内容提供器，可以对数据进行保护*/                &#123;                    imageUri= FileProvider.getUriForFile(MainActivity.this,&quot;com.example.cameraalbumtest.fileprovider&quot;,outputImage);                    /*                    第一个参数：content对象                    第二个参数：任意唯一的字符串                    第三个参数：文件对象                    */                &#125;else&#123;                    imageUri=Uri.fromFile(outputImage);                &#125;                //启动相机程序                Intent intent=new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;);                intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);                startActivityForResult(intent,TAKE_PHOTO);            &#125;        &#125;);    &#125;    @Override    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;        super.onActivityResult(requestCode, resultCode, data);       switch(requestCode)&#123;           case TAKE_PHOTO:            if (resultCode == RESULT_OK) &#123;                try &#123;                    Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri));                    picture.setImageBitmap(bitmap);                &#125; catch (FileNotFoundException e) &#123;                    e.printStackTrace();                &#125;            &#125;            break;                   default:               break;        &#125;    &#125;        &#125;&#125;\n\n&lt;provider     android:name=&quot;androidx.core.content.FileProvider&quot;     android:authorities=&quot;com.example.cameraalbumtest.fileprovider&quot;     android:exported=&quot;false&quot;     android:grantUriPermissions=&quot;true&quot;&gt;     &lt;meta-data         android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;         android:resource=&quot;@xml/file_paths&quot;/&gt; &lt;/provider&gt;\n\n&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;\n\n&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;external-path        name=&quot;my_images&quot;        path=&quot;&quot; /&gt;&lt;/paths&gt;\n\n\n\n从相册中选择图片1.申请权限\n2.创建并调用openAlum()方法\n3.重写onActivityResult处理结果\n4.针对不同图片格式进行不同操作\npublic class MainActivity extends AppCompatActivity &#123;    public static final int TAKE_PHOTO=1;//声明一个请求码，用于识别返回的结果    public static final int CHOOSE_PHOTO=2;    private ImageView picture;    private Uri imageUri;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button takePhoto=(Button) findViewById(R.id.take_photo);        Button choosePhoto=(Button) findViewById(R.id.choose_from_album);        picture =(ImageView) findViewById(R.id.picture);        takePhoto.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                //创建File对象，用于存储拍照后的图片                File outputImage=new File(getExternalCacheDir(),&quot;output_image.jpg&quot;);                try //判断图片是否存在，存在则删除重建，不存在则直接创建                &#123;                    if(outputImage.exists())&#123;                        outputImage.delete();                    &#125;                    outputImage.createNewFile();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;                if(Build.VERSION.SDK_INT&gt;=24)                    //判断安卓的版本是否高于7.0，高于则调用高于的方法，低于则调用低于的方法                    //把文件转化成Uri对象                    /*之所以这样是因为android7.0之后直接使用本地真实路径是不安全的，会抛出异常。                    FileProvider是一种特殊的内容提供器，可以对数据进行保护*/                &#123;                    imageUri= FileProvider.getUriForFile(MainActivity.this,&quot;com.example.cameraalbumtest.fileprovider&quot;,outputImage);                    /*                    第一个参数：content对象                    第二个参数：任意唯一的字符串                    第三个参数：文件对象                    */                &#125;else&#123;                    imageUri=Uri.fromFile(outputImage);                &#125;                //启动相机程序                Intent intent=new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;);                intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);                startActivityForResult(intent,TAKE_PHOTO);            &#125;        &#125;);        choosePhoto.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE)!= PackageManager.PERMISSION_GRANTED)&#123;                    ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123; Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1);                &#125;                else&#123;                    openAlbum();                &#125;            &#125;        &#125;);    &#125;private void openAlbum()&#123;        Intent intent=new Intent(&quot;android.intent.action.GET_CONTENT&quot;);        intent.setType(&quot;image/*&quot;);        startActivityForResult(intent,CHOOSE_PHOTO);&#125;    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);       if(requestCode==1)&#123;           if(grantResults.length&gt;0&amp;&amp;grantResults[0]==PackageManager.PERMISSION_GRANTED)&#123;               openAlbum();           &#125;else&#123;               Toast.makeText(this, &quot;You denide the permission&quot;, Toast.LENGTH_SHORT).show();           &#125;       &#125;    &#125;    @Override    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;        super.onActivityResult(requestCode, resultCode, data);       switch(requestCode)&#123;           case TAKE_PHOTO:            if (resultCode == RESULT_OK) &#123;                try &#123;                    Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri));                    picture.setImageBitmap(bitmap);                &#125; catch (FileNotFoundException e) &#123;                    e.printStackTrace();                &#125;            &#125;            break;           case CHOOSE_PHOTO:               if(resultCode==RESULT_OK)&#123;                   if( Build.VERSION.SDK_INT&gt;=19)&#123;                       //4.4以上系统使用这个方法处理照片                       handleImageOnKitKat(data);                   &#125;                   else&#123;                       //4.4以下使用                       handleImageBeforeKitKat(data);                   &#125;               &#125;               break;           default:               break;        &#125;    &#125;    private void handleImageBeforeKitKat(Intent data) &#123;        Uri uri=data.getData();        String imagePath=getImagePath(uri,null);        displayImage(imagePath);//根据路径显示图片    &#125;    private void handleImageOnKitKat(Intent data) &#123;        String imagePath=null;        Uri uri=data.getData();        if (DocumentsContract.isDocumentUri(this,uri)) &#123;            //如果是document类型的Uri，则通过document id处理            String docId = DocumentsContract.getDocumentId(uri);            if (&quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority())) &#123;                String id = docId.split(&quot;:&quot;)[1];//解析出数字格式的id                String selection = MediaStore.Images.Media._ID + &quot;=&quot; + id;                imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);            &#125; else if (&quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority())) &#123;                Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;), Long.valueOf(docId));                imagePath = getImagePath(contentUri, null);            &#125;        &#125;else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) &#123;                //如果是Content类型的uri则使用普通方法处理                imagePath=getImagePath(uri,null);            &#125; else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) &#123;                imagePath=uri.getPath();            &#125;            displayImage(imagePath);//根据路径显示图片        &#125;        @SuppressLint(&quot;Range&quot;)        private String getImagePath(Uri uri, String selection)&#123;        String path=null;        //通过Uri和selection来获取真实的图片路径            Cursor cursor=getContentResolver().query(uri,null,selection,null,null);            if(cursor!=null)&#123;                if(cursor.moveToFirst())&#123;                    path=cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));                &#125;                cursor.close();            &#125;            return path;        &#125;        private void displayImage(String imagePath)&#123;        if(imagePath!=null)&#123;            Bitmap bitmap=BitmapFactory.decodeFile(imagePath);            picture.setImageBitmap(bitmap);        &#125;else&#123;            Toast.makeText(this, &quot;failed to get image&quot;, Toast.LENGTH_SHORT).show();        &#125;        &#125;&#125;\n\n\n\n\n播放多媒体文件播放音频MediaPlayer类的方法：\n\n1.创建一个MediaPlayer类\n2.动态申请权限\n3.调用initMediaPlayer方法对其进行初始化\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    &gt;    &lt;Button        android:id=&quot;@+id/play&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Play&quot;         /&gt;    &lt;Button        android:id=&quot;@+id/pause&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Pause&quot;         /&gt;    &lt;Button        android:id=&quot;@+id/stop&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Stop&quot; /&gt;&lt;/LinearLayout&gt;\n\n\n\npublic class MainActivity extends AppCompatActivity &#123;private MediaPlayer mediaPlayer=new MediaPlayer();    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button play=(Button) findViewById(R.id.play);        Button pause=(Button) findViewById(R.id.pause);        Button stop=(Button) findViewById(R.id.stop);        play.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                if(!mediaPlayer.isPlaying())&#123;                    mediaPlayer.start();                &#125;            &#125;        &#125;);        pause.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                if(mediaPlayer.isPlaying())&#123;                    mediaPlayer.pause();                &#125;            &#125;        &#125;);        stop.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                if(mediaPlayer.isPlaying())&#123;                    mediaPlayer.reset();//停止播放                    initMediaPlayer();                &#125;            &#125;        &#125;);        if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE)!= PackageManager.PERMISSION_GRANTED)&#123;            ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1);        &#125;else&#123;            initMediaPlayer();        &#125;    &#125;    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);        if(requestCode==1)&#123;            if(grantResults.length&gt;0&amp;&amp;grantResults[0]==PackageManager.PERMISSION_GRANTED)&#123;                initMediaPlayer();            &#125;else&#123;                Toast.makeText(this, &quot;拒绝权限将无法使用程序&quot;, Toast.LENGTH_SHORT).show();                finish();            &#125;        &#125;    &#125;    @Override    protected void onDestroy() &#123;        super.onDestroy();        if(mediaPlayer!=null)&#123;            mediaPlayer.stop();            mediaPlayer.release();        &#125;    &#125;    private void initMediaPlayer()&#123;        try&#123;            File file=new File(Environment.getExternalStorageDirectory(),&quot;music.mp3&quot;);            mediaPlayer.setDataSource(file.getPath());//指定音频文件的路径            mediaPlayer.prepare();//让mediaPlayer进入到准备状态        &#125;        catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;\n\n\n\n播放视频VideoView类的方法：\n\n1.创建VideoView实例\n2.动态申请权限\n3.利用initVideoView方法初始化\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    &gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;Button            android:id=&quot;@+id/play&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:text=&quot;Play&quot;/&gt;       &lt;Button           android:id=&quot;@+id/pause&quot;           android:layout_width=&quot;0dp&quot;           android:layout_height=&quot;wrap_content&quot;           android:layout_weight=&quot;1&quot;           android:text=&quot;Pause&quot;/&gt;        &lt;Button            android:id=&quot;@+id/replay&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;1&quot;            android:text=&quot;Replay&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;VideoView        android:id=&quot;@+id/video_view&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;\n\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;private VideoView videoView;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        videoView=(VideoView) findViewById(R.id.video_view);        Button play=(Button) findViewById(R.id.play);        Button pause=(Button) findViewById(R.id.pause);        Button replay=(Button) findViewById(R.id.replay);        play.setOnClickListener(this);        pause.setOnClickListener(this);        replay.setOnClickListener(this);        if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE)!= PackageManager.PERMISSION_GRANTED)&#123;            ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1);        &#125;else&#123;            initVideoPath();//初始化MediaPlayer        &#125;    &#125;    private void initVideoPath() &#123;        File file=new File(Environment.getExternalStorageDirectory(),&quot;movie.mp4&quot;);        videoView.setVideoPath(file.getPath());    &#125;    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);        if(requestCode==1)&#123;            if(grantResults.length&gt;0&amp;&amp;grantResults[0]==PackageManager.PERMISSION_GRANTED)&#123;                initVideoPath();            &#125;            else&#123;                Toast.makeText(this, &quot;拒绝权限将无法使用该程序&quot;, Toast.LENGTH_SHORT).show();                finish();            &#125;        &#125;    &#125;    @Override    protected void onDestroy() &#123;        super.onDestroy();        if(videoView!=null)&#123;            videoView.suspend();        &#125;    &#125;    @Override    public void onClick(View view) &#123;       if(view.getId()==R.id.play)&#123;           if(!videoView.isPlaying())&#123;               videoView.start();           &#125;       &#125; else if (view.getId()==R.id.pause) &#123;           if(videoView.isPlaying())&#123;               videoView.pause();           &#125;       &#125; else if (videoView.isPlaying()) &#123;           //停止播放视频，并释放资源           videoView.resume();       &#125;    &#125;&#125;\n\n&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;\n\n\n","categories":["Android(Java版)"]},{"title":"数据存储(Java)","url":"/posts/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","content":"文件存储数据存储1.新建save方法，运用openFileOutput接收(“文件名”，保存模式（强制覆盖：MODE_PRIVATE,增添追加：MODE_APPEND）)，openFileOutput方法返回的是FileOutputStream对象，通过BufferedWriter将其写入到文件中。\n2.重写onDestroy()方法，确保销毁前一定会调用save方法。\npublic class MainActivity extends AppCompatActivity &#123;private EditText edit;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        edit=(EditText) findViewById(R.id.edit_text);    &#125;//确保销毁时能够调用save方法    @Override    protected void onDestroy() &#123;        super.onDestroy();        String inputText=edit.getText().toString();        save(inputText);    &#125;    //保存输入文本到文件中去    public void save(String inputText)&#123;        FileOutputStream out=null;//声明文件输出流        BufferedWriter writer=null;//声明缓冲写入流        try&#123;            //打开文件输出流，MODE_PRIVATE表示私有模式，文件只能被该应用访问            out=openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE);            //将输出流包装成缓冲写入流，使用UTF-8编码            writer=new BufferedWriter(new OutputStreamWriter(out));            //将文本写入文件            writer.write(inputText);        &#125;catch (IOException e)&#123;            e.printStackTrace();//捕获并打印异常        &#125;finally &#123;            try &#123;                //关闭writer流                if (writer!=null)&#123;                    writer.close();                &#125;            &#125;catch (IOException e)&#123;                e.printStackTrace();//捕获并打印关闭流时的异常            &#125;        &#125;    &#125;&#125;\n\n\n\n读取数据新建load()方法，运用openFileInput接收(“文件名”),通过BufferedReader一行行读取对象\npublic String load()&#123;        FileInputStream in=null;//声明文件输入流        BufferedReader reader=null;//声明缓冲读取流        StringBuilder content=new StringBuilder();//来存储读取的内容        try&#123;            //打开文件输入流，读取名为“data”的文件            in=openFileInput(&quot;data&quot;);            //将文件输入流包装成缓冲读取流            reader=new BufferedReader(new InputStreamReader(in));            String line=&quot;&quot;;//用于存储每次读取的一行内容            while((line=reader.readLine())!=null)&#123;                content.append(line);//将读取的每一行都追加到content中            &#125;        &#125;catch (IOException e)&#123;            e.printStackTrace();//捕获并打印异常        &#125;finally&#123;            //确保reader流被关闭            if(reader!=null)&#123;                try&#123;                    reader.close();//关闭缓冲读取流                &#125;catch (IOException e)&#123;                    e.printStackTrace();//捕获并打印关闭流时的异常                &#125;            &#125;        &#125;        return content.toString();//返回读取到的所有内容    &#125;\n\n完整代码：\npublic class MainActivity extends AppCompatActivity &#123;private EditText edit;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        edit=(EditText) findViewById(R.id.edit_text);        String inputText=load();        if(!TextUtils.isEmpty(inputText))&#123;            edit.setText(inputText);            edit.setSelection(inputText.length());            Toast.makeText(this, &quot;Restoring succeeded&quot;, Toast.LENGTH_SHORT).show();        &#125;    &#125;    @Override    protected void onDestroy() &#123;        super.onDestroy();        String inputText=edit.getText().toString();        save(inputText);    &#125;    public void save(String inputText)&#123;        FileOutputStream out=null;        BufferedWriter writer=null;        try&#123;            out=openFileOutput(&quot;data&quot;, Context.MODE_APPEND);            writer=new BufferedWriter(new OutputStreamWriter(out));            writer.write(inputText);        &#125;catch (IOException e)&#123;            e.printStackTrace();        &#125;finally &#123;            try &#123;                if (writer!=null)&#123;                    writer.close();                &#125;            &#125;catch (IOException e)&#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public String load()&#123;        FileInputStream in=null;        BufferedReader reader=null;        StringBuilder content=new StringBuilder();        try&#123;            in=openFileInput(&quot;data&quot;);            reader=new BufferedReader(new InputStreamReader(in));            String line=&quot;&quot;;            while((line=reader.readLine())!=null)&#123;                content.append(line);            &#125;        &#125;catch (IOException e)&#123;            e.printStackTrace();        &#125;finally&#123;            if(reader!=null)&#123;                try&#123;                    reader.close();                &#125;catch (IOException e)&#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return content.toString();    &#125;&#125;\n\n\n\n\nSharedPreferences存储数据存储1.用getSharedPreferences设置存放的文件名与模式（唯一）\n2.调用edit()方法\n3.存入数据并调用apply()方法提交\n@Override   protected void onCreate(Bundle savedInstanceState) &#123;       super.onCreate(savedInstanceState);       setContentView(R.layout.activity_main);       Button saveData=(Button) findViewById(R.id.save_data);       saveData.setOnClickListener(new View.OnClickListener() &#123;           @Override           public void onClick(View view) &#123;               //获取SharedPreferences对象，存储在“data”文件中，MODE_PRIVATE表示私有模式               SharedPreferences.Editor editor=getSharedPreferences(&quot;data&quot;,MODE_PRIVATE).edit();               //使用SharedPreferences.Editor存储数据               editor.putString(&quot;name&quot;,&quot;Tom&quot;);//存储字符串               editor.putInt(&quot;age&quot;,28);//存储整型数据               editor.putBoolean(&quot;married&quot;,false);//存储布尔值数据               //提交数据（apply()为异步提交不返回结果）               editor.apply();           &#125;       &#125;);   &#125;\n\n\n\n读取数据Button restoreData=(Button) findViewById(R.id.restore_data);       restoreData.setOnClickListener(new View.OnClickListener() &#123;           @Override           public void onClick(View view) &#123;                //获取SharedPreferences对象，用于读取“data”文件中的数据               SharedPreferences pref=getSharedPreferences(&quot;data&quot;,MODE_PRIVATE);               //从SharedPreferences中读取数据，如果没找到则使用默认值              String name= pref.getString(&quot;name&quot;,&quot;&quot;);              int age= pref.getInt(&quot;age&quot;,0);              boolean married=pref.getBoolean(&quot;married&quot;,false);               //输出日志，打印恢复的数据               Log.d(&quot;MainActivity&quot;, &quot;name is &quot;+name);               Log.d(&quot;MainActivity&quot;, &quot;age is &quot;+age);               Log.d(&quot;MainActivity&quot;, &quot;married is &quot;+married);           &#125;       &#125;);\n\n\n\nSQLite数据库存储SQL语句整型：integer\n浮点型：real\n文本型：text\n二进制型：blob\n创建一个表格：\n 1.public static final String CREATE_BOOK=&quot;create table Book(&quot;//创建一个名为Book的表            +&quot;id integer primary key autoincrement, &quot;//定义id字段，设为主键，并设为自增            +&quot;author text, &quot;            +&quot;price real, &quot;            +&quot;pages integer, &quot;            +&quot;name text)&quot;;2.private static final String CREATE_TABLE_SQL=&quot;create table&quot;+TABLE_NAME_NOTE+&quot;(id integer primary key autoincrement,title text,content,text,create_time text)&quot;;//两种方法都可以使用\n\n\n\n创建数据库1.新建帮助类MyDatabaseHelper继承自SQLiteOpenHelper\n2.重写构造方法\n3.重写onCreate调用execSQL执行建表语句\n4.重写onUpgrade\n5.之后可以调用getWritableDatabase（）或getReadableDatabase（）获取数据库\n//构造方法，初始化数据库public MyDatabaseHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123;        super(context, name, factory, version);    &#125;//创建数据库表    @Override    public void onCreate(SQLiteDatabase db)&#123;        db.execSQL(CREATE_BOOK);    &#125;//更新数据库，暂时不操作    @Override    public void onUpgrade(SQLiteDatabase db, int i, int i1) &#123;    &#125;\n\n\n\n升级数据库如果需要在已经创建好的数据库的基础上还想添加几类数据就需要升级数据库\npublic class MyDatabaseHelper extends SQLiteOpenHelper &#123;    public static final String CREATE_BOOK=&quot;create table Book(&quot;            +&quot;id integer primary key autoincrement, &quot;            +&quot;author text, &quot;            +&quot;price real, &quot;            +&quot;pages integer, &quot;            +&quot;name text)&quot;;    public static final String CREATE_CATEGORY=&quot;create table Category(&quot;            +&quot;id integer primary key autoincrement, &quot;            +&quot;category_name text, &quot;            +&quot;category_code integer)&quot;;    private Context mContext;    public MyDatabaseHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123;        super(context, name, factory, version);                mContext=context;    &#125;    @Override    public void onCreate(SQLiteDatabase db)&#123;        db.execSQL(CREATE_BOOK);        db.execSQL(CREATE_CATEGORY);        Toast.makeText(mContext, &quot;Create succeeded&quot;, Toast.LENGTH_SHORT).show();    &#125;    @Override    public void onUpgrade(SQLiteDatabase db, int i, int i1) &#123;        db.execSQL(&quot;drop table if exists Book&quot;);//如果存在Book表则删除        db.execSQL(&quot;drop table if exists Category&quot;);//如果存在Category表则删除        onCreate(db);//重新创建表格    &#125;&#125;\n\nCRUD：Create添加Read查询Update更新Delete删除\n添加数据可以使用insert()方法插入数据\npublic long insertData(Note note)&#123;                          SQLiteDatabase db=getWritableDatabase();//获取数据库              ContentValues values=new ContentValues();//创建ContentValues存储插入数据              //开始组装第一条数据              values.put(&quot;title&quot;,note.getTitle());              values.put(&quot;content&quot;,note.getContent());              values.put(&quot;create_time&quot;,note.getCreatTime());            return  db.insert(&quot;Note&quot;,null,values);//插入数据，返回插入的行号&#125;\n\n\n\n更新数据利用updata()方法更新\npublic int updateData(Note note)&#123;                SQLiteDatabase db=getWritableDatabase();                ContentValues values=new ContentValues();                values.put(&quot;title&quot;,note.getTitle());                values.put(&quot;content&quot;,note.getContent());                values.put(&quot;create_time&quot;,note.getCreatTime());                return db.update(&quot;Note&quot;,values,&quot;id=?&quot;,new String[]&#123;note.getId()&#125;);&#125;\n\n\n\n删除数据用delete()方法删除\npublic int deleteData(String id)&#123;                SQLiteDatabase db=getWritableDatabase();               return db.delete(&quot;Note&quot;,&quot;id=?&quot;,new String[]&#123;id&#125;);&#125;\n\n\n\n查询数据1**.方法：**通过query()方法\n2.**基本语法：**public Cursor query(String table, String[] columns, String selection,String[] selectionArgs, String groupBy, String having, String orderBy)\n3.**参数说明：**table：要查询的表名。columns：要返回的列名数组。可以指定要查询的具体列，若为 null，表示查询所有列。selection：查询条件，相当于 SQL 中的 WHERE 子句。可以为 null，表示没有条件（即返回所有记录）。selectionArgs：selection 中占位符（?）的实际值，必须与 selection 中的 ? 占位符一一对应。如果没有占位符，传入 null。groupBy：对查询结果进行分组的列名数组，通常与 GROUP BY 子句结合使用。如果不需要分组，可以传入 null。having：分组后筛选的条件，相当于 SQL 中的 HAVING 子句。如果不需要筛选分组后的数据，可以传入 null。orderBy：排序方式，相当于 SQL 中的 ORDER BY 子句。如果为 null，则不进行排序。\n4.返回值：query() 方法返回一个 Cursor 对象，它包含了查询的结果。通过 Cursor，你可以逐行遍历查询结果并获取每一行的数据。\n   SQLiteDatabase db=dbHelper.getWritableDatabase();   //查询表中所有数据    Cursor cursor=db.query(&quot;Book&quot;,null,null,null,null,null,null);    if(cursor.moveToFirst())&#123;        do&#123;            //遍历表中所有数据，并打印            @SuppressLint(&quot;Range&quot;) String name=cursor.getString(cursor.getColumnIndex(&quot;name&quot;));            @SuppressLint(&quot;Range&quot;) String author=cursor.getString(cursor.getColumnIndex(&quot;author&quot;));            @SuppressLint(&quot;Range&quot;) int pages=cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;));            @SuppressLint(&quot;Range&quot;) double price=cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;));            Log.d(&quot;MainActivity&quot;, &quot;book name is: &quot;+name);            Log.d(&quot;MainActivity&quot;, &quot;book author is: &quot;+author);            Log.d(&quot;MainActivity&quot;, &quot;book pages is: &quot;+pages);            Log.d(&quot;MainActivity&quot;, &quot;book price is: &quot;+price);        &#125;while(cursor.moveToNext());    &#125;    cursor.close();;&#125;\n\n\n\n使用SQL操作数据库添加数据：\ndb.execSQL(&quot;insert into Book(name,author,pages,price) values(? ,?, ?, ?)&quot;,new String[]&#123;&quot;The Da Vinci Code&quot;,&quot;Dan Brown&quot;,&quot;454&quot;,&quot;16.96&quot;&#125;);\n\n插入数据：\ndb.execSQL(&quot;update Book set price=? where name=?&quot;,new String[]{&quot;10.99&quot;,&quot;The Da Vinci Code&quot;});\n删除数据：\ndb.execSQL(&quot;delete from Book where pages&gt;?&quot;,new String[]{&quot;500&quot;});\n查询数据：\ndb.rawQuery(&quot;select * from Book&quot;,null);\n\n","categories":["Android(Java版)"]},{"title":"正则表达式","url":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"作用\n检验字符串是否满足规则\n在一段文本中查找满足要求的内容\n\n规则\n\n\n","categories":["Java"]},{"title":"泛型和委托","url":"/posts/%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%A7%94%E6%89%98/","content":"泛型定义泛型类\n语法结构\n//T代指泛型是一种约定俗成class MyClass&lt;T&gt; &#123;    fun method(param:T):T&#123;        return param    &#125;&#125;\n\n调用\nval myClass=MyClass&lt;Int&gt;()   val result=myClass.method(123)   println(result)\n\n定义泛型方法\n语法结构\nclass MyClass&#123;    fun&lt;T&gt;method(param:T):T&#123;        return param    &#125;&#125;\n\n调用\nval myClass=MyClass()    val result=myClass.method&lt;Int&gt;(123)    println(result)\n\n泛型上界对泛型类型进行限制\n\n语法结构\nclass MyClass&#123;    fun&lt;T:Number&gt;method(param:T):T&#123;        return param    &#125;&#125;\n\n调用\nval myClass=MyClass()val result=myClass.method(123)println(result)\n\n\n类委托和委托属性类委托\n原理\n将一个类的具体实现委托给另一个类去完成\n\n意义\n大部分方法实现调用辅助对象的方法，少部分方法实现自己重写，甚至加入自己独有的方法\n\n实例\nMySet构造函数中接收了一个HashSet参数这就相当于一个辅助对象，Set接口中所有方法的实现都是调用了辅助对象中相应的方法实现的，这就是类委托\nclass MySet&lt;T&gt;(val helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt;  &#123;    override val size: Int        get() = helperSet.size    override fun isEmpty()=helperSet.isEmpty()    override fun iterator()=helperSet.iterator()    override fun containsAll(elements: Collection&lt;T&gt;)=helperSet.containsAll(elements)    override fun contains(element: T)=helperSet.contains(element)&#125;\n\n使用by类委托关键字简化\n哪个方法需要重新实现只需要写那一个方法即可，不需要把所有继承方法都写下来\nclass MySet&lt;T&gt;(val helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; by helperSet &#123;    fun helloWorld() = println(&quot;Hello World&quot;)    override fun isEmpty() = false&#125;\n\n委托属性\n原理\n将一个属性(字段)的具体实现委托给另一个类去完成\n\n语法结构\n将p属性具体实现委托给Delegate类完成，当调用p时会自动调用Delegate的getValue()方法，当给其赋值会调用Delegate的setValue()方法\nclass MyClass&#123;    var p by Delegate()&#125;\n\nDelegate()的实现\nclass Delegate &#123;    var propValue: Any? = null    /**     * 第一个参数声明该委托功能可以在哪个类中使用     第二个参数是一个属性操作类，当前情景用不着但必须声明     */    operator fun getValue(myClass: MyClass, prop: KProperty&lt;*&gt;): Any? &#123;        return propValue    &#125;   /**     * 第一个参数声明该委托功能可以在哪个类中使用     第二个参数是一个属性操作类，当前情景用不着但必须声明     第三个参数表示具体赋给委托属性的值，必须与getValue方法返回值类型一致     */    operator fun setValue(myClass: MyClass, prop: KProperty&lt;*&gt;, value: Any?) &#123;       propValue = value &#125;&#125;\n\n**注意：**当p属性用val修饰时不需要再去实现setValue方法\n\n\n\n实现一个自己的lazy函数\n高阶函数\nclass Later&lt;T&gt;(val block:()-&gt;T)&#123;    var value:Any?=null    operator fun getValue(any:Any?,prop:KProperty&lt;*&gt;):T&#123;        if(value==null)&#123;            value=block()        &#125;        return value as T    &#125;&#125;\n\n创建Later类实例并将接收的函数类型参数传给Later类的构造函数\nfun &lt;T&gt;later(block:()-&gt;T)=Later(block)\n\n实现\nval uriMatcher by later&#123;    val matcher=UriMatcher(UriMatcher.NO_MATCH)    matcher.addURI(authority,path,CODE_CREATE)    ......    matcher&#125;\n\n验证\nval p by later&#123;    Log.d(&quot;TAG&quot;,&quot;run codes inside later block&quot;)    &quot;test later&quot;&#125;\n\n注意：一般还是更常用Kotlin内置的lazy函数\n\n\n\n","categories":["Kotlin"]},{"title":"最美UI体验,Material Design(Kotlin)","url":"/posts/%E6%9C%80%E7%BE%8EUI%E4%BD%93%E9%AA%8C-Material-Design-Kotlin/","content":"各版块颜色的代表标识\n\nToolbar\n在布局文件中使用\n在活动中设置\n\n&lt;androidx.appcompat.widget.Toolbar    android:id=&quot;@+id/toolbar&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;?attr/actionBarSize&quot;    android:background=&quot;?attr/colorPrimary&quot;    android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;//为弹出的菜单项设置主题    app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot;/&gt;//用于控制Toolbar或其他顶部栏的滚动行为\n\nsetSupportActionBar(binding.toolbar)\n\n\nDrawerLayout这是一个布局，允许放入两个直接子控件，第一个是主屏幕显示的内容，第二个是滑动菜单中显示的内容\n&lt;androidx.drawerlayout.widget.DrawerLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:id=&quot;@+id/drawerLayout&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;FrameLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; &gt;\t    &lt;androidx.appcompat.widget.Toolbar                android:id=&quot;@+id/toolbar&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;?attr/actionBarSize&quot;                android:background=&quot;@color/colorPrimary&quot;                android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;                app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;                app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot;/&gt;    &lt;/FrameLayout&gt;\t&lt;TextView \t\tandroid:layout_width=&quot;match_parent&quot;     \tandroid:layout_height=&quot;match_parent&quot;\t\tandroid:text=&quot;This is menu&quot;/&gt;  \t&lt;/androidx.drawerlayout.widget.DrawerLayout&gt;\n\n//调用getSupportActionBar方法获取ActionBar实例        supportActionBar?.let &#123;            //让导航按钮显示            it.setDisplayHomeAsUpEnabled(true)            //设置导航图标            it.setHomeAsUpIndicator(R.drawable.ic_menu)        &#125;\n\n//设置按钮点击事件    override fun onOptionsItemSelected(item: MenuItem): Boolean &#123;        when(item.itemId)&#123;            //openDrawer将滑动菜单显示出来            android.R.id.home-&gt;binding.drawerLayout.openDrawer(GravityCompat.START)            ...        &#125;        return true    &#125;\n\n\nNavigationView作用： NavigationView 用于在侧滑菜单中显示导航菜单项，可方便地配置菜单资源、头部布局等。\n\n依赖库\nmenu\nheaderLayout\n点击事件\n\nimplementation(&quot;com.google.android.material:material:1.12.0&quot;)implementation(&quot;de.hdodenhof:circleimageview:3.1.0&quot;)\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;group android:checkableBehavior=&quot;single&quot;&gt;        &lt;item            android:id=&quot;@+id/navCall&quot;            android:icon=&quot;@drawable/nav_call&quot;            android:title=&quot;Call&quot;/&gt;        &lt;item            android:id=&quot;@+id/navFriends&quot;            android:icon=&quot;@drawable/nav_friends&quot;            android:title=&quot;Friends&quot;/&gt;        &lt;item            android:id=&quot;@+id/navLocation&quot;            android:icon=&quot;@drawable/nav_location&quot;            android:title=&quot;Location&quot;/&gt;        &lt;item            android:id=&quot;@+id/navMail&quot;            android:icon=&quot;@drawable/nav_mail&quot;            android:title=&quot;Mail&quot;/&gt;        &lt;item            android:id=&quot;@+id/navTask&quot;            android:icon=&quot;@drawable/nav_task&quot;            android:title=&quot;Task&quot;/&gt;    &lt;/group&gt;&lt;/menu&gt;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;180dp&quot;    android:padding=&quot;10dp&quot;    android:background=&quot;@color/colorPrimary&quot;&gt;    &lt;de.hdodenhof.circleimageview.CircleImageView        android:id=&quot;@+id/iconImage&quot;        android:layout_width=&quot;70dp&quot;        android:layout_height=&quot;70dp&quot;        android:src=&quot;@drawable/nav_icon&quot;        android:layout_centerInParent=&quot;true&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/mailText&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_alignParentBottom=&quot;true&quot;        android:text=&quot;buyu@qq.com&quot;        android:textColor=&quot;#FFF&quot;        android:textSize=&quot;14sp&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/userText&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_above=&quot;@id/mailText&quot;        android:text=&quot;Buyu&quot;        android:textColor=&quot;#FFF&quot;        android:textSize=&quot;14sp&quot;/&gt;&lt;/RelativeLayout&gt;\n\n&lt;com.google.android.material.navigation.NavigationView        android:id=&quot;@+id/navView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:layout_gravity=&quot;start&quot;        app:menu=&quot;@menu/nav_menu&quot;        app:headerLayout=&quot;@layout/nav_header&quot;/&gt;\n\n//设置默认选中项       binding.navView.setCheckedItem(R.id.navCall)       //设置菜单项选中事件的监听器       binding.navView.setNavigationItemSelectedListener &#123;           //将滑动菜单关闭           binding.main.closeDrawers()           //true表示事件已处理           true       &#125;\n\n\nFloatingActionButton&lt;com.google.android.material.floatingactionbutton.FloatingActionButton            android:id=&quot;@+id/fab&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_gravity=&quot;bottom|end&quot;            android:layout_margin=&quot;16dp&quot;            android:src=&quot;@drawable/ic_done&quot;            app:elevation=&quot;8dp&quot;/&gt;//指定高度值\n\n\nSnackbar作用： Snackbar 用于短暂地在屏幕底部显示信息反馈。虽然 Snackbar 主要在代码中调用显示，但其依赖于包含在布局中的 CoordinatorLayout 来获得自动动画和交互。\nSnackbar.make(findViewById(R.id.coordinator_layout), &quot;这是一个Snackbar&quot;, Snackbar.LENGTH_LONG)    .setAction(&quot;Undo&quot;) &#123;        // 处理点击事件    &#125;    .show()\n\n\nCoordinatorLayout加强版的FrameLayout\n作用： CoordinatorLayout 是一个高级布局容器可以监听内部的所有控件，可以协调其内部子控件的交互,控件自动调整合适的位置\n&lt;androidx.coordinatorlayout.widget.CoordinatorLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:id=&quot;@+id/coordinator_layout&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;!-- 这里可以嵌入 AppBarLayout、FloatingActionButton 等 --&gt;&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt;\n\n\nMaterialCardView额外提供了圆角阴影等效果的FrameLayout\n&lt;com.google.android.material.card.MaterialCardView    android:id=&quot;@+id/material_card&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_margin=&quot;16dp&quot;    app:cardCornerRadius=&quot;8dp&quot;//指定卡片圆角的弧度    app:elevation=&quot;4dp&quot;&gt;//指定卡片高度    &lt;!-- 卡片内部内容 --&gt;    &lt;TextView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:padding=&quot;16dp&quot;        android:text=&quot;这是一个MaterialCardView&quot; /&gt;        &lt;/com.google.android.material.card.MaterialCardView&gt;\n\n\nAppBarLayout作用： AppBarLayout 是用于实现应用栏（如 Toolbar、Tabs）的容器，它通常配合 CollapsingToolbarLayout 实现折叠效果。例如解决RecyclerView遮挡Toolbar问题\n&lt;com.google.android.material.appbar.AppBarLayout    android:id=&quot;@+id/appbar_layout&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt;     &lt;androidx.appcompat.widget.Toolbar                android:id=&quot;@+id/toolbar&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;?attr/actionBarSize&quot;                android:background=&quot;@color/colorPrimary&quot;                android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;                app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;                app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot;/&gt;        &lt;/com.google.android.material.appbar.AppBarLayout&gt;\n\n\nSwipeRefreshLayout作用： SwipeRefreshLayout 用于实现下拉刷新效果，当用户下拉时可以触发刷新操作。\nimplementation(&quot;androidx.swiperefreshlayout:swiperefreshlayout:1.1.0&quot;)\n\n&lt;androidx.swiperefreshlayout.widget.SwipeRefreshLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:id=&quot;@+id/swipe_refresh&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;!-- 包含可刷新的内容区域，例如 RecyclerView --&gt;    &lt;androidx.recyclerview.widget.RecyclerView        android:id=&quot;@+id/recycler_view&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;&lt;/androidx.swiperefreshlayout.widget.SwipeRefreshLayout&gt;\n\n\n可折叠式标题栏CollapsingToolbarLayout不能独立存在必须是AppBarLayout子布局，AppBarLayout又必须是CoordinatorLayout子布局\n这个高级标题栏就是普通标题栏加上背景图片\n&lt;androidx.coordinatorlayout.widget.CoordinatorLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:fitsSystemWindows=&quot;true&quot;&gt;    &lt;com.google.android.material.appbar.AppBarLayout        android:id=&quot;@+id/appBar&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;250dp&quot;        android:fitsSystemWindows=&quot;true&quot;&gt;        &lt;com.google.android.material.appbar.CollapsingToolbarLayout            android:id=&quot;@+id/collapsingToolbar&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;            android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;            android:fitsSystemWindows=&quot;true&quot;            app:contentScrim=&quot;?attr/colorPrimary&quot;            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;            &lt;ImageView                android:id=&quot;@+id/fruitImageView&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;match_parent&quot;                android:scaleType=&quot;centerCrop&quot;                android:fitsSystemWindows=&quot;true&quot;                app:layout_collapseMode=&quot;parallax&quot; /&gt;            &lt;androidx.appcompat.widget.Toolbar                android:id=&quot;@+id/toolbar&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;?attr/actionBarSize&quot;                app:layout_collapseMode=&quot;pin&quot; /&gt;        &lt;/com.google.android.material.appbar.CollapsingToolbarLayout&gt;    &lt;/com.google.android.material.appbar.AppBarLayout&gt;    &lt;androidx.core.widget.NestedScrollView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;        &lt;LinearLayout            android:orientation=&quot;vertical&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;com.google.android.material.card.MaterialCardView                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;                android:layout_marginBottom=&quot;15dp&quot;                android:layout_marginLeft=&quot;15dp&quot;                android:layout_marginRight=&quot;15dp&quot;                android:layout_marginTop=&quot;35dp&quot;                app:cardCornerRadius=&quot;4dp&quot;&gt;                &lt;TextView                    android:id=&quot;@+id/fruitContentText&quot;                    android:layout_width=&quot;wrap_content&quot;                    android:layout_height=&quot;wrap_content&quot;                    android:layout_margin=&quot;10dp&quot; /&gt;            &lt;/com.google.android.material.card.MaterialCardView&gt;        &lt;/LinearLayout&gt;    &lt;/androidx.core.widget.NestedScrollView&gt;    &lt;com.google.android.material.floatingactionbutton.FloatingActionButton        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;16dp&quot;        android:src=&quot;@drawable/ic_comment&quot;        app:layout_anchor=&quot;@id/appBar&quot;        app:layout_anchorGravity=&quot;bottom|end&quot; /&gt;&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt;\n\n充分利用系统状态栏空间\n方案一\n\n\n将ImageView及其所有父布局使用android:fitsSystemWindows&#x3D;”true”\n\n使用android:statusBarColor属性将主题状态栏颜色设为透明\n\n在Manifest.xml中对活动主题进行修改\n&lt;style name=&quot;FruitActivityTheme&quot; parent=&quot;AppTheme&quot; &gt;        &lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/transparent&lt;/item&gt;    &lt;/style&gt;\n\n&lt;activity            android:name=&quot;.FruitActivity&quot;            android:theme=&quot;@style/FruitActivityTheme&quot;&gt;&lt;/activity&gt;\n\n\n方案二\nval decorView=window.decorViewdecorView.systemUiVisibility=View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LAYOUT_STABLEwindow.statusBarColor=Color.TRANSPARENT\n\n\n","categories":["Android(Kotlin版)"]},{"title":"服务(Java)","url":"/posts/%E6%9C%8D%E5%8A%A1/","content":"Android多线程编程线程的基本用法（1）1.新建一个类继承自Thread，并重写run方法\n​          2.启动线程\nclass MyThread extends Thread&#123;    @Override    public void run()&#123;        //处理具体逻辑    &#125;&#125;new MyThread().start();\n\n(2) 使用Runnable接口的方式来定义一个线程\nclass MyThread implements Runnable&#123;    @Override    public void run()&#123;        //处理具体逻辑    &#125;&#125;MyYhread myThread=new MyYhread();new Thread(myThread).start();\n\n(3)匿名类的方法\nnew Thread(new Runnable()&#123;     @Override    public void run()&#123;        //处理具体逻辑    &#125;&#125;).start();\n\n在子线程中更新UI1.新建一个Handler对象，并重写了父类的方法，在这里对Message进行具体处理，这里是主线程\n2.在子线程中创建Message对象，并发送\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;    public static  final int UPDATE_TEXT=1;    private TextView textView;    @SuppressLint(&quot;HandlerLeak&quot;)    private Handler handler=new Handler()&#123;        @SuppressLint(&quot;SetTextI18n&quot;)        public void handleMessage(Message msg)&#123;            if (msg.what == UPDATE_TEXT) &#123;                //在这里进行UI操作                textView.setText(&quot;Nice to meet you&quot;);            &#125;        &#125;    &#125;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        textView=(TextView) findViewById(R.id.text);        Button changeText=(Button) findViewById(R.id.change_text);        changeText.setOnClickListener(this);    &#125;    @Override    public void onClick(View view) &#123;        if(view.getId()==R.id.change_text)&#123;            new Thread(new Runnable() &#123;                @Override                public void run() &#123;                   Message msg=new Message();                   msg.what=UPDATE_TEXT;                   handler.sendMessage(msg);                &#125;            &#125;).start();        &#125;    &#125;&#125;\n\n异步消息处理机制\n\nAsyncTask1.创建一个子类去继承它，需要传入三个参数如下\nParams：在后台任务中使用\nProgress：可以作为进度单位\nResult：返回值类型\n2.重写父类方法如下：\nonPreExecute():界面上的初始化操作\ndoInBackground(Params…):所有代码都在子线程中运行，在这里处理耗时任务\nonProgressUpdate(Progress…):对UI进行操作\nonPostExecute(Result):后台任务执行完毕并通过return语句返回时，这个方法被调用\n3.启动任务\nnew DownloadTask().execute();\n\n服务1.定义一个服务(已经自动注册了),并重写onCreate,onStartCommand,onDestroy方法\n2.启动和停止服务\n3.将活动与服务进行联系\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;private MyService.DownloadBinder downloadBinder;private ServiceConnection connection=new ServiceConnection() &#123;    @Override    public void onServiceConnected(ComponentName componentName, IBinder service) &#123;        downloadBinder=(MyService.DownloadBinder) service;        downloadBinder.startDownloads();        downloadBinder.getProgress();    &#125;    @Override    public void onServiceDisconnected(ComponentName componentName) &#123;    &#125;&#125;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button start=(Button) findViewById(R.id.start_service);        Button stop=(Button) findViewById(R.id.stop_service);        Button bind=(Button) findViewById(R.id.bind_service);        Button unbind=(Button) findViewById(R.id.unbind_service);        Button startMyIntent=(Button)findViewById(R.id.start_intent_service);        start.setOnClickListener(this);        stop.setOnClickListener(this);        bind.setOnClickListener(this);        unbind.setOnClickListener(this);        startMyIntent.setOnClickListener(this);    &#125;    @Override    public void onClick(View view) &#123;        if(view.getId()==R.id.start_service)&#123;            Intent startIntent=new Intent(this,MyService.class);            startService(startIntent);//启动服务        &#125;        if(view.getId()==R.id.stop_service)&#123;            Intent stopIntent=new Intent(this,MyService.class);            stopService(stopIntent);//停止服务        &#125;        if(view.getId()==R.id.bind_service)&#123;            Intent bindIntent=new Intent(this,MyService.class);            //绑定服务            bindService(bindIntent,connection,BIND_AUTO_CREATE);        &#125;        if(view.getId()==R.id.unbind_service)&#123;            //解绑服务            unbindService(connection);        &#125;    &#125;&#125;\n\n\n\npublic class MyService extends Service &#123;    //建立联系    private DownloadBinder mBinder=new DownloadBinder();    class DownloadBinder extends Binder&#123;        public void startDownloads()&#123;            Log.d(&quot;MyService&quot;, &quot;startDownloads: &quot;);        &#125;        public int getProgress()&#123;            Log.d(&quot;MyService&quot;, &quot;getProgress: &quot;);            return 0;        &#125;    &#125; public MyService() &#123;    &#125;    @Override    public IBinder onBind(Intent intent) &#123;       return mBinder;    &#125;    @SuppressLint(&quot;ForegroundServiceType&quot;)    @Override    public void onCreate() &#123;        super.onCreate();        Log.d(&quot;MyService&quot;, &quot;onCreate: &quot;);    &#125;    @Override    public int onStartCommand(Intent intent, int flags, int startId) &#123;        Log.d(&quot;MyService&quot;, &quot;onStartCommand: &quot;);        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                //处理具体逻辑                stopSelf();            &#125;        &#125;).start();        return super.onStartCommand(intent, flags, startId);    &#125;    @Override    public void onDestroy() &#123;        super.onDestroy();        Log.d(&quot;MyService&quot;, &quot;onDestroy:&quot;);    &#125;&#125;\n\n\n服务更多的技巧使用前台服务使用startForeground方法\n @SuppressLint(&quot;ForegroundServiceType&quot;)    @Override    public void onCreate() &#123;        super.onCreate();        Log.d(&quot;MyService&quot;, &quot;onCreate: &quot;);        startForegroundService();    &#125;@SuppressLint(&quot;ForegroundServiceType&quot;)    private void startForegroundService() &#123;        NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);        String channelId = &quot;my_channel_id&quot;;        // 创建通知渠道（仅适用于 Android 8.0 及以上）        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;            NotificationChannel channel = new NotificationChannel(                    channelId,                    &quot;My Channel&quot;,                    NotificationManager.IMPORTANCE_DEFAULT            );            notificationManager.createNotificationChannel(channel);        &#125;        // 创建 Notification        Notification notification = new NotificationCompat.Builder(this, channelId)                .setContentTitle(&quot;Service Running&quot;)                .setContentText(&quot;Foreground service is running&quot;)                .setSmallIcon(R.mipmap.ic_launcher)                .setPriority(NotificationCompat.PRIORITY_DEFAULT)                .build();        // 启动前台服务        startForeground(1, notification);    &#125;\n\n使用IntentService1.新建一个类继承自IntentService\n2.在Manifest.xml中注册\npublic class MyIntentService extends IntentService &#123;    public MyIntentService() &#123;        super(&quot;MyIntentService&quot;);//调用父类的有参构造函数    &#125;    @Override    protected void onHandleIntent(@Nullable Intent intent) &#123;        //该方法已经在子线程中运行        //打印当前线程的id        Log.d(&quot;MyIntentService&quot;, &quot;Thread id is &quot;+Thread.currentThread().getId());    &#125;    @Override    public void onDestroy() &#123;        super.onDestroy();        Log.d(&quot;MyIntentService&quot;, &quot;onDestroy executed&quot;);    &#125;&#125;\n\n\n服务最佳实例1.添加依赖\n2.定义一个回调接口\n3.编写下载功能\n4.创建一个下载的服务，保证可以一直在后台运行\n5.将服务与活动建立联系并编写运行逻辑和授予权限\nimplementation (&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;)\n\npublic interface DownloadListener &#123;    void onProgress(int progress);    void onSuccess();    void onFailed();    void onPaused();    void onCanceled();&#125;\n\npublic class DownloadTask extends AsyncTask&lt;String,Integer,Integer&gt; &#123;    public static final int TYPE_SUCCESS=0;    public static final int TYPE_FAILED=1;    public static final int TYPE_PAUSED=2;    public static final int TYPE_CANCELED=3;    private DownloadListener listener;    private boolean isCanceled=false;    private boolean isPaused=false;    private int lastProgress;    public DownloadTask(DownloadListener listener)&#123;        this.listener=listener;    &#125;    @Override    protected Integer doInBackground(String... strings) &#123;        //用于从网络读取数据        InputStream is=null;        //用于写入下载的文件        RandomAccessFile savedFile=null;        //表示下载文件的存储位置        File file=null;        try&#123;            //记录已下载的文件长度            long downloadLength=0;            //获取URL地址            String downloadUrl=strings[0];            //解析下载的文件名            String fileName=downloadUrl.substring(downloadUrl.lastIndexOf(&quot;/&quot;));            //指定将文件下载到Environment.DIRECTORY_DOWNLOADS目录下            String directory= Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath();            file=new File(directory+fileName);            //判断该目录是否已经存在要下载的文件            if(file.exists())&#123;                //读取已下载的字节数                downloadLength=file.length();            &#125;            //获取下载文件的总长度            long contentLength=getContentLength(downloadUrl);            if(contentLength==0)&#123;                return TYPE_FAILED;            &#125; else if (contentLength==downloadLength) &#123;                //已下载字节和文件总字节相等，说明已经下载完成了                return TYPE_SUCCESS;            &#125;            //利用OkHttp发送一条网络请求            OkHttpClient client=new OkHttpClient();            Request request=new Request.Builder()                    //断点下载，指定从哪个字节开始下载                    .addHeader(&quot;RANGE&quot;,&quot;bytes=&quot;+downloadLength+&quot;-&quot;)                    .url(downloadUrl)                    .build();            Response response=client.newCall(request).execute();            if(response!=null)&#123;                //获取字节流                is=response.body().byteStream();                //用于读写文件，“rw”模式表示读写模式                savedFile=new RandomAccessFile(file,&quot;rw&quot;);                //跳过已下载的字节                savedFile.seek(downloadLength);                //创建一个字节数组，用于存储从网络读取的数据                byte[] b=new byte[1024];                //用于记录总共下载的字节数                int total=0;                //用于存储每次从网络读取的字节数                int len;                while((len=is.read(b))!=-1)&#123;                    if(isCanceled)&#123;                        return TYPE_CANCELED;                    &#125; else if (isPaused) &#123;                        return TYPE_PAUSED;                    &#125;else&#123;                        total+=len;                        //将从网络上读取的数据写入到文件中                        savedFile.write(b,0,len);                        //计算已下载的百分比                        int progress=(int) ((total+downloadLength)*100/contentLength);                        //发布下载进度                        publishProgress(progress);                    &#125;                &#125;                //关闭字节流                response.body().close();                return TYPE_SUCCESS;            &#125;        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;finally &#123;                try&#123;                    if(is!=null)&#123;                        is.close();                    &#125;                    if(savedFile!=null)&#123;                        savedFile.close();                    &#125;                    if(isCanceled&amp;&amp;file!=null)&#123;                        file.delete();                    &#125;                &#125;catch (Exception e)&#123;                    e.printStackTrace();                &#125;        &#125;        return TYPE_FAILED;    &#125;    @Override    protected void onProgressUpdate(Integer... values) &#123;        super.onProgressUpdate(values);        int progress=values[0];        if(progress&gt;lastProgress)&#123;            listener.onProgress(progress);            lastProgress=progress;        &#125;    &#125;    @Override    protected void onPostExecute(Integer integer) &#123;        super.onPostExecute(integer);        if(integer==TYPE_SUCCESS)&#123;            listener.onSuccess();        &#125; else if (integer==TYPE_FAILED) &#123;            listener.onFailed();        &#125; else if (integer==TYPE_PAUSED) &#123;            listener.onPaused();        &#125; else if (integer==TYPE_CANCELED) &#123;            listener.onCanceled();        &#125;    &#125;    public void pauseDownload()&#123;        isPaused=true;    &#125;    public void cancelDownload()&#123;        isCanceled=true;    &#125;    private long getContentLength(String downloadUrl) throws IOException &#123;        OkHttpClient client=new OkHttpClient();        Request request=new Request.Builder()                .url(downloadUrl)                .build();        Response response=client.newCall(request).execute();        if(response!=null&amp;&amp;response.isSuccessful())&#123;            long contentLendth=response.body().contentLength();            response.close();            return contentLendth;        &#125;        return 0;    &#125;&#125;\n\npublic class DownloadService extends Service &#123;    private DownloadTask downloadTask;    private String downloadUrl;    public DownloadService() &#123;    &#125;    private DownloadListener listener=new DownloadListener() &#123;        @SuppressLint(&quot;NotificationPermission&quot;)        @Override        public void onProgress(int progress) &#123;            getNotificationManager().notify(1,getNotification(&quot;Downloading...&quot;,progress));        &#125;        @SuppressLint(&quot;NotificationPermission&quot;)        @Override        public void onSuccess() &#123;            downloadTask=null;            //关闭前台通知            stopForeground(true);            //创建通知告知用户下载成功            getNotificationManager().notify(1,getNotification(&quot;Download Success&quot;,-1));            Toast.makeText(DownloadService.this, &quot;Download Success&quot;, Toast.LENGTH_SHORT).show();        &#125;        @SuppressLint(&quot;NotificationPermission&quot;)        @Override        public void onFailed() &#123;            downloadTask=null;            stopForeground(true);            getNotificationManager().notify(1,getNotification(&quot;Download Failed&quot;,-1));            Toast.makeText(DownloadService.this, &quot;Download Failed&quot;, Toast.LENGTH_SHORT).show();        &#125;        @Override        public void onPaused() &#123;                downloadTask=null;            Toast.makeText(DownloadService.this, &quot;Paused&quot;, Toast.LENGTH_SHORT).show();        &#125;        @Override        public void onCanceled() &#123;            downloadTask=null;            stopForeground(true);            Toast.makeText(DownloadService.this, &quot;Canceled&quot;, Toast.LENGTH_SHORT).show();        &#125;    &#125;;    private DownloadBinder mBinder=new DownloadBinder();    @Override    public IBinder onBind(Intent intent) &#123;       return mBinder;    &#125;    class DownloadBinder extends Binder&#123;        @SuppressLint(&quot;ForegroundServiceType&quot;)        public void startDownload(String url)&#123;            if(downloadTask==null)&#123;                downloadUrl=url;                //创建DownloadTask对象                downloadTask=new DownloadTask(listener);                //开启下载                downloadTask.execute(downloadUrl);                startForeground(1,getNotification(&quot;Downloading...&quot;,0));                Toast.makeText(DownloadService.this, &quot;Downloading...&quot;, Toast.LENGTH_SHORT).show();            &#125;        &#125;        public void pauseDownload()&#123;            if(downloadTask!=null)&#123;                downloadTask.pauseDownload();            &#125;        &#125;        public void cancelDownload()&#123;            if(downloadTask!=null)&#123;                downloadTask.cancelDownload();            &#125;            else&#123;                if(downloadUrl!=null)&#123;                    //取消下载时需将文件删除，并将通知关闭                    String fileName=downloadUrl.substring(downloadUrl.lastIndexOf(&quot;/&quot;));                    String directory= Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath();                    File file=new File(directory+fileName);                    if(file.exists())&#123;                        file.delete();                    &#125;                    getNotificationManager().cancel(1);                    stopForeground(true);                    Toast.makeText(DownloadService.this, &quot;Canceled&quot;, Toast.LENGTH_SHORT).show();                &#125;            &#125;        &#125;    &#125;    private NotificationManager getNotificationManager()&#123;        return (NotificationManager) getSystemService(NOTIFICATION_SERVICE);    &#125;    private Notification getNotification(String title,int progress)&#123;        Intent intent=new Intent(this,MainActivity.class);        @SuppressLint(&quot;UnspecifiedImmutableFlag&quot;) PendingIntent pi=PendingIntent.getActivities(this,0, new Intent[]&#123;intent&#125;,0);        NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);        String channelId = &quot;my_channel_id&quot;;        // 创建通知渠道（仅适用于 Android 8.0 及以上）        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;            NotificationChannel channel = new NotificationChannel(channelId, &quot;My Channel&quot;, NotificationManager.IMPORTANCE_DEFAULT);            notificationManager.createNotificationChannel(channel);        &#125;        NotificationCompat.Builder builder=new NotificationCompat.Builder(this, channelId);        // 创建 Notification        builder.setContentTitle(title);        builder.setSmallIcon(R.mipmap.ic_launcher);        builder.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher));        builder.setContentIntent(pi);        if(progress&gt;0)&#123;            builder.setContentText(progress+&quot;%&quot;);            builder.setProgress(100,progress,false);        &#125;return builder.build();    &#125;&#125;\n\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;    private DownloadService.DownloadBinder downloadBinder;    //使活动与服务建立联系    private ServiceConnection connection=new ServiceConnection() &#123;        @Override        public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123;            downloadBinder=(DownloadService.DownloadBinder) iBinder;        &#125;        @Override        public void onServiceDisconnected(ComponentName componentName) &#123;        &#125;    &#125;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button start=(Button) findViewById(R.id.start_download);        Button pause=(Button) findViewById(R.id.pause_download);        Button cancel=(Button) findViewById(R.id.cancel_download);        start.setOnClickListener(this);        pause.setOnClickListener(this);        cancel.setOnClickListener(this);        //启动服务        Intent intent=new Intent(this,DownloadService.class);        startService(intent);        //绑定服务        bindService(intent,connection,BIND_AUTO_CREATE);        //申请权限        if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE)!= PackageManager.PERMISSION_GRANTED)&#123;            ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123; Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1);        &#125;    &#125;    @Override    public void onClick(View view) &#123;        if(downloadBinder==null)&#123;            return;        &#125;        if(view.getId()==R.id.start_download)&#123;            String url=&quot;https://raw.githubusercontent.com/guolindev/eclipse/master/eclipse-inst-win64.exe&quot;;            downloadBinder.startDownload(url);        &#125; else if (view.getId()==R.id.pause_download) &#123;            downloadBinder.pauseDownload();        &#125; else if (view.getId()==R.id.cancel_download) &#123;            downloadBinder.cancelDownload();        &#125;    &#125;    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);        if(requestCode==1)&#123;            if(grantResults.length&gt;0&amp;&amp;grantResults[0]!=PackageManager.PERMISSION_GRANTED)&#123;                Toast.makeText(this, &quot;拒绝授权程序无法使用&quot;, Toast.LENGTH_SHORT).show();                finish();            &#125;        &#125;    &#125;    @Override    protected void onDestroy() &#123;        super.onDestroy();        unbindService(connection);    &#125;&#125;\n\n\n","categories":["Android(Java版)"]},{"title":"活动(Kotlin)","url":"/posts/%E6%B4%BB%E5%8A%A8-1/","content":"Toast1.一种提醒方式\n2.用法\nval button1: Button = findViewById(R.id.button1)           button1.setOnClickListener &#123;               Toast.makeText(this,&quot;You clicked out&quot;,Toast.LENGTH_SHORT).show()           &#125;\n\n\nViewBinding1.先在build.gradle.kts(app)中导入ViewBinding\n2.声明该类型\n3.绑定布局\nandroid &#123;    // 启用 ViewBinding    viewBinding &#123;        enable = true    &#125;&#125;\n\nclass FirstActivity : BaseActivity() &#123;          //声明变量        private lateinit var myBinding:FirstActivityBinding        override fun onCreate(savedInstanceState: Bundle?) &#123;            super.onCreate(savedInstanceState)            //绑定布局            myBinding=FirstActivityBinding.inflate(layoutInflater)            setContentView(myBinding.root)            //使用            myBinding.button1.setOnClickListener &#123;            &#125;        &#125;    &#125;\n\n\nMenu1.创建menu文件夹并创建Menu resource file\n2.重写**onCreateOptionsMenu()**方法对菜单完成创建\n3.重写**onOptionsItemSelected()**方法设计点击事件\noverride fun onCreateOptionsMenu(menu: Menu?): Boolean &#123;            menuInflater.inflate(R.menu.main, menu)            return true        &#125;        override fun onOptionsItemSelected(item: MenuItem): Boolean &#123;            when (item.itemId) &#123;                R.id.add_item -&gt; Toast.makeText(this, &quot;you clicked add&quot;, Toast.LENGTH_SHORT).show()                R.id.remove_item -&gt; Toast.makeText(this, &quot;you clicked remove&quot;, Toast.LENGTH_SHORT)                    .show()            &#125;            return true        &#125;\n\n\nIntent显式Intentval intent=Intent(this,SecondActivity::class.java)//SecondActivity::class.java相当于Java中的SecondActivity.class startActivity(intent)\n\n隐式Intent1.在标签下配置和\n2.直接将action传入Intent构造函数中\n3只有和同时匹配才能响应\n&lt;activity    android:name=&quot;.SecondActivity&quot;    android:exported=&quot;false&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;        &lt;category android:name=&quot;com.example.activitytest.MY_CATEGORY&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;\n\n\n\nval intent=Intent(&quot;com.example.activitytest.ACTION_START&quot;)//添加category(action只有一个category可以有多个)intent.addCategory(&quot;com.example.activitytest.MY_CATEGORY&quot;)startActivity(intent)\n\n隐式Intent用法1.调用系统浏览器\nval intent=Intent(Intent.ACTION_VIEW)intent.data= Uri.parse(&quot;https://www.baidu.com&quot;)startActivity(intent)\n\n2.调用电话\nval intent=Intent(Intent.ACTION_DIAL)intent.data= Uri.parse(&quot;tel:10086&quot;)startActivity(intent)\n\n向下一个活动传递数据利用putExtra传入一个键值对\nval data=&quot;Hello SecondActivity&quot;val intent=Intent(this,SecondActivity::class.java)intent.putExtra(&quot;extra_data&quot;,data)startActivity(intent)\n\n利用getStringExtra接收数据传入“键”\nval extraData=intent.getStringExtra(&quot;extra_data&quot;)\n\n向上一活动返回数据1.第一个活动中通过startActivityForResult启动活动\n2.第二个活动构建要传输的数据\n3.在第一个活动中重onActivityResult方法得到返回数据\nmyBinding.button1.setOnClickListener &#123;    val intent=Intent(this,SecondActivity::class.java)            startActivityForResult(intent,1)&#125;\n\nbutton2.setOnClickListener &#123;val intent= Intent() intent.putExtra(&quot;data_return&quot;,&quot;Hello FirstActivity!!!&quot;) setResult(RESULT_OK,intent) finish()&#125;\n\noverride fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123;            super.onActivityResult(requestCode, resultCode, data)            when (requestCode) &#123;                1 -&gt; if (resultCode == RESULT_OK) &#123;                    val returnData = data?.getStringExtra(&quot;data_return&quot;)                    Log.d(&quot;FirstActivity&quot;, &quot;returned data is $returnData &quot;)                &#125;            &#125;        &#125;\n\n如果通过back键返回：\noverride fun onBackPressed() &#123;        val intent= Intent()        intent.putExtra(&quot;data_return&quot;,&quot;Hello FirstActivity&quot;)        setResult(RESULT_OK,intent)        finish()    &#125;\n\n\nActivity生命周期生存期1. onCreate()\n作用：\n当 Activity 第一次被创建时调用。在这个方法中，你通常会完成以下工作：\n\n设置布局文件（例如调用 setContentView()）\n初始化控件、变量和数据\n配置基本组件（如 Toolbar、Fragment 等）\n\n2.onStart()\n作用：\n在 onCreate() 之后调用，此时 Activity 已经对用户可见，但还未获得焦点，也就是还不能进行用户交互。通常在这里启动一些即将进入前台的操作。\n3.onResume()\n作用：\n在 onStart() 之后调用，此时 Activity 已经位于前台，并且可以接收用户的输入和交互。这也是应用处于“运行”状态的主要阶段。\n4.onPause()\n作用：\n当系统准备启动或恢复另一个 Activity 时调用，此时当前 Activity 仍然部分可见，但失去了用户焦点。通常在这里进行轻量级的保存工作，比如暂停动画、保存数据或释放一些占用较多资源的操作。\n5.onStop()\n作用：\n当 Activity 完全对用户不可见时调用，可能是因为新的 Activity 覆盖在上面或 Activity 被销毁。通常在这里释放不再需要的资源，并执行较重的保存工作。\n6.onDestroy()\n作用：\n在 Activity 被完全销毁之前调用。这可能是因为用户主动关闭 Activity 或系统由于资源不足而销毁 Activity。在此方法中需要清理所有占用的资源，确保内存没有泄漏。\n7.onRestart()\n作用：\n当一个已停止的 Activity 将要重新启动时调用，此方法紧接在 onStop() 之后调用，然后进入 onStart()。常用于重新初始化在 onStop() 中释放的资源或状态恢复。\n生存期类别**1.完整生存期： **\n onCreate()，onStart()，onResume()，onPause()，onStop()，onDestroy()\n2.可见生存期：\nonStart()，onResume()，onPause()，onStop()\n3.前台生存期：\nonResume()，onPause()\n\nActivity被回收了咋办1.重写onSaveInstanceState()方法保存数据\n2.利用onCreate()方法中的Bundle类型读取数据\noverride fun onSaveInstanceState(outState: Bundle) &#123;       super.onSaveInstanceState(outState)       val tempData=&quot;Something you just typed&quot;       outState.putString(&quot;data_key&quot;,tempData)   &#125;\n\noverride fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        if(savedInstanceState!=null)&#123;            val tempData=savedInstanceState.getString(&quot;data_key&quot;)            Log.d(TAG, &quot;tempData is $tempData&quot;)        &#125;    &#125;\n\n\nActivity启动模式standard默认设置，每点击一次按钮均会生成一个新的活动，不管这个活动是否存在\nsingleTop1.在标签中添加android:launchMode属性更改\n2.作用：\n创建活动时会先检查栈顶的是否是该活动，如果栈顶的活动是该活动则直接调用如果不是创建新活动\n3.原理图\n\nsingleTask1.在标签中添加android:launchMode属性更改\n2.作用：\n每次启动该活动时会先检查栈中是否有该活动如果有会直接调用并将该活动上方其他活动直接出栈，如果没有则创建新活动\n3.原理图：\n\nsingleInstance1.在标签中添加android:launchMode属性更改\n2.作用：\n会启用一个新的返回栈来管理该活动，可以实现不同程序之间共享Activity实例\n3.原理图：\n\n\nActivity最佳实践知晓当前是哪个活动1.建立BaseActivity类\n2.在该类onCreate方法中打印一行日志打印当前类名\n3.其余所以活动继承该类\nopen class BaseActivity:AppCompatActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        Log.d(&quot;BaseActivity&quot;, javaClass.simpleName)    &#125;&#125;\n\n随时随地退出程序1.新建一个单例类管理所有活动\n2.修改BaseActivity类中方法实现添加删除\n3.调用方法退出程序\nobject ActivityCollector &#123;    private val activities=ArrayList&lt;Activity&gt;()    fun addActivity(activity:Activity)&#123;        activities.add(activity)    &#125;    fun removeActivity(activity: Activity)&#123;        activities.remove(activity)    &#125;    fun finishAll()&#123;        for(activity in activities)&#123;            if(!activity.isFinishing) &#123;                activity.finish()            &#125;        &#125;        activities.clear()    &#125;&#125;\n\nopen class BaseActivity:AppCompatActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        Log.d(&quot;BaseActivity&quot;, javaClass.simpleName)        ActivityCollector.addActivity(this)    &#125;    override fun onDestroy() &#123;        super.onDestroy()        ActivityCollector.removeActivity(this)    &#125;&#125;\n\nActivityCollector.finishAll()\n\n也可以在最后加一个杀掉当前进程的代码，来保证完全退出程序\nandroid.os.Process.killProcess(android.os.Process.myPid())\n\n\n\n启动Activity最佳写法// 在要启动的活动内添加该静态方法companion object &#123;    // 封装启动 SecondActivity 的静态方法    fun actionStart(context: Context, data: String) &#123;        // 创建一个 Intent 对象，指定从当前上下文启动 SecondActivity        val intent = Intent(context, SecondActivity::class.java)        // 将传入的字符串数据作为额外参数存入 Intent，        // &quot;extra_data&quot; 为键，用于在 SecondActivity 中提取该数据        intent.putExtra(&quot;extra_data&quot;, data)        // 通过上下文启动 SecondActivity        context.startActivity(intent)    &#125;&#125;\n\n  button1.setOnClickListener &#123;        SecondActivity.actionStart(this, &quot;data&quot;)&#125;\n\n\n","categories":["Android(Kotlin版)"]},{"title":"活动(Java)","url":"/posts/%E6%B4%BB%E5%8A%A8/","content":"手动创建一个活动的全过程1.创建一个活动2.创建和加载布局(根元素一般选用LinearLayout的):\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;Button        android:id=&quot;@+id/button_1&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Button 1&quot; /&gt;&lt;/LinearLayout&gt;\n\n①添加按钮用Button控件②利用setContentView()方法加载布局3.在AndroidManifest中注册4.配置主活动(也可以用label给活动添加个标题，标题栏显示在最顶部)\n\nToast1.定义:一种提醒方式，信息出现一段时间会自己消失，不会占用屏幕空间2.使用方式:\nToast.makeText(FirstActivity.this, &quot;You clicked Button 1&quot;, Toast.LENGTH_SHORT).show();\n\n3.利用makeText()创建一个Toast对象，传入三个参数，第一个参数是Context,也就是上下文，第二个参数是文本内容，第三个参数是显示时长\n\nMenu1.要现在res目录下创建一个新的文件夹menu2.创建Menu resource file3.修改其中的代码\n&lt;item    android:id=&quot;@+id/add_item&quot;    android:title=&quot;Add&quot;/&gt;&lt;item    android:id=&quot;@+id/remove_item&quot;    android:title=&quot;Remove&quot;/&gt;\n\n其中 item 标签就是用来创建具体的某一个菜单项\n4.接着重写onCreateOptionsMenu()方法\n\n5.然后利用onOptionsItemSelected()方法定义菜单响应事件\n@Override   public boolean onOptionsItemSelected(MenuItem item)&#123;       if(item.getItemId()==R.id.add_item)&#123;               Toast.makeText(this, &quot;You clicked Add&quot;, Toast.LENGTH_SHORT).show();       &#125; else if (item.getItemId()==R.id.remove_item) &#123;           Toast.makeText(this, &quot;You clicked Remove&quot;, Toast.LENGTH_SHORT).show();       &#125;       return false;   &#125;\n\n\nIntent用途:启动活动，启动服务，发送广播\n显式IntentIntent intent = new Intent(FirstActivity.this,SecondActivity.class);startActivity(intent);\n\n Intent构造函数接收两个参数，第一个参数是Context上下文，第二个是想要启动的活动目标 然后通过startActivity()方法执行这个intent \n隐式Intent1.在activity下配置intent-filter，指定当前活动能响应的action和category\n&lt;intent-filter&gt;     &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot; /&gt;     &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;&lt;/intent-filter&gt;\n\n2.只有action和category能够同时匹配上intent指定的action和category时，活动才能响应该intent\nIntent intent = new Intent(&quot;com.example.activitytest.ACTION_START&quot;);startActivity(intent);\n\n3.每个intent只能指定一个action却可以指定多个category \n4.可以利用addCategory()方法来添加category，在活动中添加一个category同时也需要在intent-filter下进行一个声明 \n更多隐式intent用法1.通过Intent启动浏览器等:\n\n同时我们还应该在intent-filter中配置一data标签 \n\n除了浏览器也可以是其他的网址: \n\n向下一个活动传递数据1.可以利用putExtra()方法，把我们想要传递的数据存在intent中，启动一个活动后，只需要再把数据取出就可以了。2.putExtra()方法使用需要两个参数，第一个是键用于后面取值，第二个是要传递的数据。\nString data=&quot;Hello SecondAcitivity&quot;;Intent intent=new Intent(FirstActivity.this,SecondActivity.class);intent.putExtra(&quot;extra_data&quot;,data);startActivity(intent);\n\n\n\n3.取值时首先要通过getIntent()方法获取intent，然后调用getStringExtra()方法获取数据\nIntent intent = getIntent();String data=intent.getStringExtra(&quot;extra_data&quot;);Log.d(&quot;SecondAcitivity&quot;,data);\n\n\n\n返回数据给上一个活动1.利用startActivityForResult()方法来启动活动2.调用setResult()方法用于向上一个活动返回数据3.用startActivityForResult()方法启动活动该活动销毁后会调回上一个活动的onActivityResult()方法，所以重写该方法可以得到返回的数据\n例子：\n\n\n\n4.如果通过back键销毁活动则可以通过重写onBackPressed()方法解决\n@Override   public void onBackPressed() &#123;      super.onBackPressed();      Intent intent = new Intent();      intent.putExtra(&quot;data_return&quot;, &quot;Hello FirstActivity&quot;);      setResult(RESULT_OK, intent);      finish();  &#125;\n\n\n活动的生命周期返回栈一个任务就是一组存放在栈里的集合，这个栈也叫返回栈\n活动状态1.运行状态:处于栈顶2.暂停状态:不在栈顶但仍然可见3.停止状态:不在栈顶且不可见4.销毁状态:从返回栈中移除\n生存期1.七种回调方法:①·onCreate():初始化操作②·onStart():活动由不可见变为可见③·onResume():此时活动一定处于栈顶且运行状态④·onPause():在准备启动或恢复另一个活动时调用⑤·onStop():活动完全不可见时用，如果启动的新活动是对话框式的，则会调用onPause(),而onStop()不会执行⑥·onDestroy():销毁之前调用⑦·onRestart():活动由停止变为运行状态前调用完整生存期:①到⑥之间经历的方法可见生存期:②到⑤之间前台生存期:③到④之间\n\n  对话框式的主题需要在AndroidManifest中更改配置如下所示:\nandroid:theme=&quot;@style/Theme.Appcompat.Light.Dialog.Alert&quot;\n\n\n\n\n活动被回收了怎么办1.利用onSaveInstanceState()方法回调，这个方法会携带一个Bundle类型参数，该类型提供了一系列方法保存数据2.例子:\n\n\n\n活动的启动模式在AndroidManifest中用android:launchMode更改模式(1)standard:默认启动模式\n\n(2)singleTop:在启动活动时如果发现栈顶已经是该活动，则可以直接使用他，不再创建新活动\n\n(3)singleTask:每次启动活动时会先检查存不存在该活动，如果存在直接调用此活动，并把该活动上面的活动通通出栈\n\n(4)singleInstance:会启用一个新的返回栈来管理活动\n\n\n知晓当前在哪一个活动1.创建一个新的Java类继承AppCompatActivity并重写onCreate方法在该类中获得当前实例的类名\npublic class BaseActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        Log.d(&quot;BaseActivity&quot;, getClass().getSimpleName());    &#125;&#125;\n\n\n\n2.让其他的活动都继承新建的类3.观察logcat中各界面的打印信息即可得出结论\n\n随时随地的退出程序1.可以创建一个专门的集合对所有活动进行管理就可以了\npublic class ActivityCollector &#123;    public static List&lt;BaseActivity&gt; activities=new ArrayList&lt;&gt;();    public static void addActivity(BaseActivity activity)&#123;        activities.add(activity);    &#125;    public static void removeActivity(BaseActivity activity)&#123;        activities.remove(activity);    &#125;    public static void finishAll()&#123;        for(BaseActivity activity:activities)&#123;            if(!activity.isFinishing())&#123;                activity.finish();            &#125;        &#125;    &#125;&#125;\n\n2.设计好管理类接下来对BaseActivity类进行修改\npublic class BaseActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        Log.d(&quot;BaseActivity&quot;, getClass().getSimpleName());        ActivityCollector.addActivity(this);    &#125;    @Override    protected void onDestroy() &#123;        super.onDestroy();        ActivityCollector.removeActivity(this);    &#125;&#125;\n\n3.这两步操作完，如果以后想直接退出程序直接使用finishAll()方法即可\n\n启动活动的最佳写法利用actionStart()方法\npublic static void actionStart(Context context,String data1,String data2)&#123;   Intent intent = new Intent(context,SecondActivity.class);   intent.putExtra(&quot;param1&quot;,data1);   intent.putExtra(&quot;param2&quot;,data2);   context.startActivity(intent);&#125;\n\nSecondActivity.actionStart(FirstActivity.this,&quot;data1&quot;,&quot;data2&quot;);\n\n用上面这句话直接启动\n","categories":["Android(Java版)"]},{"title":"登陆注册数据备份(手动备份)","url":"/posts/%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD-%E6%89%8B%E5%8A%A8%E5%A4%87%E4%BB%BD/","content":"本博客以firebase服务器为例\n结构图users (Collection)   └── uid1 (Document)        └── messages (Collection)            ├── message1 (Document)            ├── message2 (Document)   └── uid2 (Document)        └── messages (Collection)            ├── message1 (Document)\n\n\n\n注册\n获取auth和firestore对象\n向云端上传用户信息\n利用firestore建立个人档案\n\nauth.createUserWithEmailAndPassword(email,password)    .addOnCompleteListener(this)&#123;task -&gt;        if (task.isSuccessful)&#123;            Toast.makeText(this, &quot;账户创建成功&quot;, Toast.LENGTH_SHORT).show()            val user= auth.currentUser            val uid=user?.uid            val userProfile=hashMapOf(                &quot;uid&quot; to uid,                &quot;email&quot; to email,                &quot;registTime&quot; to System.currentTimeMillis()            )            //建立个人档案，将数据写入数据库中            db.collection(&quot;users&quot;).document(uid!!)                .set(userProfile)                .addOnSuccessListener &#123;                    finish()                &#125;                .addOnSuccessListener &#123;                    Toast.makeText(this,&quot;用户信息储存失败请稍后重试&quot;,Toast.LENGTH_SHORT).show()                &#125;        &#125;else&#123;            Toast.makeText(this,&quot;账户创建失败&quot;,Toast.LENGTH_SHORT).show()        &#125;    &#125;\n\n登录private fun login()&#123;       val email=binding.email.text.toString()       val password=binding.password.text.toString()       if(email.isEmpty()||password.isEmpty())&#123;           Toast.makeText(this,&quot;邮箱或密码不能为空&quot;,Toast.LENGTH_SHORT).show()           return       &#125;       auth.signInWithEmailAndPassword(email, password)           .addOnCompleteListener &#123; task -&gt;               if (task.isSuccessful) &#123;                   //这一步是为了实现用户数据隔离                   lifecycleScope.launch &#123;                       // 先清空数据库                       dao.clearAllMessages()                       dao.clearAllCategories()                       // 再切回主线程做 UI 操作                           restoreFromFirestore(dao)                           Toast.makeText(this@LoginActivity, &quot;用户登陆成功&quot;, Toast.LENGTH_SHORT).show()                           val i = Intent(this@LoginActivity, MainActivity::class.java)                           startActivity(i)                           finish()                   &#125;               &#125; else &#123;                   Toast.makeText(                       this@LoginActivity,                       &quot;登录失败: $&#123;task.exception?.message&#125;&quot;,                       Toast.LENGTH_LONG                   ).show()                   binding.email.setText(&quot;&quot;)                   binding.password.setText(&quot;&quot;)               &#125;           &#125;\n\n数据备份\n实现备份\n实现恢复\n在UI层调用\n\nsuspend fun backupToFirestore(dao: MessageDao) &#123;    //获取当前已登录的用户        val user = FirebaseAuth.getInstance().currentUser ?: return    //获取用户uid值作为唯一标识        val uid = user.uid    //获取数据库实例        val db = FirebaseFirestore.getInstance()//加载所有信息        val messages = dao.loadAllMessage()//在uid文件下创建messages集合作为uid下子集和        val userMessagesRef = db.collection(&quot;users&quot;).document(uid).collection(&quot;messages&quot;)   //创建一个批量处理操作的对象        val batch = db.batch()    //便利本地数据库所有数据        for (msg in messages) &#123;            //以信息的id作为文档id用来获取索引或创建            val docRef = userMessagesRef.document(msg.id)            //将数据转化成键值对形式             val msgMap = mapOf(                 &quot;title&quot; to msg.title,                  &quot;time&quot; to msg.time,               &quot;aimdate&quot; to msg.aimdate,             &quot;isTop&quot; to msg.isTop,             &quot;categoryIcon&quot; to msg.categoryIcon,            &quot;categoryName&quot; to msg.categoryName,             &quot;categoryId&quot; to msg.categoryId            )            //将数据添加到docRef文档下面            batch.set(docRef, msgMap)        &#125;               try &#123; //batch.commit()：提交所有批量写入操作，返回一个 Task。//await()：挂起当前协程，等待 Task 完成，直到异步操作结束。//这样，你就可以确保 所有操作都提交成功，并能在操作完成后继续执行下一步逻辑。            batch.commit().await()            Log.d(&quot;Backup&quot;, &quot;备份成功&quot;)        &#125; catch (e: Exception) &#123;            Log.e(&quot;Backup&quot;, &quot;备份失败: $&#123;e.message&#125;&quot;, e)        &#125;    &#125;\n\nsuspend fun restoreFromFirestore(dao: MessageDao) &#123;        val user = FirebaseAuth.getInstance().currentUser ?: return        val uid = user.uid        val db = FirebaseFirestore.getInstance()//获取集合中的所有文档，get()方法是异步的所以需要awit()方法        val snapshot1 = db.collection(&quot;users&quot;).document(uid).collection(&quot;messages&quot;).get().await()             // 清空本地再导入（防止重复）        dao.clearAllMessages()//遍历所有文档，并把数据添加到本地数据库        for (doc in snapshot1.documents) &#123;            val id = doc.id            val title: String? = doc.getString(&quot;title&quot;)?:&quot;&quot;            val time: Int= doc.getLong(&quot;time&quot;)?.toInt() ?: 0            val aimdate: String?=doc.getString(&quot;aimdate&quot;)            val isTop =doc.getBoolean(&quot;isTop&quot;)?:false            val categoryIcon:Int?= doc.getLong(&quot;categoryIcon&quot;)?.toInt()            val categoryName: String?=doc.getString(&quot;categoryName&quot;)            val categoryId: String= doc.getString(&quot;categoryId&quot;).toString()            val msg = Message(title,time,aimdate,isTop,id,categoryIcon,categoryName,categoryId)            dao.insertMessage(msg)        &#125;     //加载数据        dao.loadAllMessage()    &#125;\n\n","categories":["Android随笔"]},{"title":"碎片(Kotlin)","url":"/posts/%E7%A2%8E%E7%89%87-1/","content":"Fragment使用方式简单用法1.新建碎片布局\n2.新建碎片类继承Fragment并在碎片类中动态加载碎片布局\n3.将碎片引入活动布局\n//左碎片布局&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;Button        android:id=&quot;@+id/button&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;center_horizontal&quot;        android:text=&quot;Button&quot;/&gt;&lt;/LinearLayout&gt;\n\nclass LeftFragment: Fragment() &#123;    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View? &#123;       return inflater.inflate(R.layout.left_fragment,container,false)    &#125;&#125;\n\n//右碎片布局&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;#00ff00&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;center_horizontal&quot;        android:textSize=&quot;24sp&quot;        android:text=&quot;This is right fragment&quot;/&gt;&lt;/LinearLayout&gt;\n\nclass RightFragment:Fragment() &#123;    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View? &#123;        return inflater.inflate(R.layout.right_fragment,container,false)            &#125;&#125;\n\n//主活动布局&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;horizontal&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;fragment        android:id=&quot;@+id/leftFrag&quot;        android:name=&quot;com.example.fragmenttest.LeftFragment&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;match_parent&quot;        android:layout_weight=&quot;1&quot;/&gt;    &lt;fragment        android:id=&quot;@+id/rightFrag&quot;        android:name=&quot;com.example.fragmenttest.RightFragment&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;match_parent&quot;        android:layout_weight=&quot;3&quot;/&gt;&lt;/LinearLayout&gt;\n\n动态添加Fragment\n创建待添加的实例\n获取FragmentManager对象\n开启一个事务使用beginTransaction()方法开启\n向容器内添加或替换fragment\n提交事务，用commit()完成\n\n//新碎片布局&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;#00ff00&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;center_horizontal&quot;        android:textSize=&quot;24sp&quot;        android:text=&quot;This is another right fragment&quot;/&gt;&lt;/LinearLayout&gt;\n\n//加载新碎片布局class AnotherRightFragment:Fragment() &#123;    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View? &#123;        return inflater.inflate(R.layout.another_right_fragment,container,false)    &#125;&#125;\n\n//主活动布局&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;horizontal&quot;    &gt;    &lt;fragment        android:id=&quot;@+id/leftFrag&quot;        android:name=&quot;com.example.fragmenttest.LeftFragment&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;    &lt;FrameLayout        android:id=&quot;@+id/rightLayout&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;match_parent&quot;        android:layout_weight=&quot;1&quot;&gt;            &lt;/FrameLayout&gt;&lt;/LinearLayout&gt;\n\nclass MainActivity : AppCompatActivity() &#123;    private lateinit var binding: ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        binding = ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        val button:Button=findViewById(R.id.button)        button.setOnClickListener &#123;            replaceFragment(AnotherRightFragment())        &#125;        replaceFragment(RightFragment())    &#125;    private fun replaceFragment(fragment: Fragment) &#123;        //获取fragmentManager对象        val fragmentManager = supportFragmentManager        //开启事务        val transaction = fragmentManager.beginTransaction()        //向容器内添加碎片        transaction.replace(R.id.rightLayout,fragment)        //将事务添加到返回栈        transaction.addToBackStack(null)        //提交事务        transaction.commit()    &#125;&#125;\n\nFragment和Activity交互在活动中调用碎片：\nval fragment=supportFragmentManager.findFragmentById(R.id.leftFrag) as LeftFragment\n\n在碎片中调用活动：\nif(activity!=null)&#123;    val mainActivity = activity as MainActivity&#125;\n\n不同的碎片之间通信：\n1.在一个碎片中得到与之关联的活动\n2.然后在这个Activity中去获取另一个Fragment实例\n\nFragment的生命周期fragment的状态（1）运行状态：\n当一个碎片是可见的，并且它所关联的活动正处于运行状态时，该碎片也处于运行状态\n（2）暂停状态：\n当一个活动进入暂停状态时(由于另一个未占满屏幕的活动被添加到了栈顶)，与它相关联的可见碎片就会进入到暂停状态。\n（3）停止状态：\n当一个活动进入到停止状态时，与它相关联的碎片就会进入到停止状态，或者通过调用FragmentTransaction的remove(),replace()方法将碎片从活动中移除，但如果在事务提交之前使用addToBackStack()方法，这时的碎片也会进入到停止状态。总的来说，进入到停止状态的碎片对用户来说完全不可见，有可能被系统回收。\n（4）销毁状态：\n碎片总是依附于活动而存在，因此当活动被销毁时，与它相关联的碎片就会进入到销毁状态。或者通过调用FragmentTransaction的remove(),replace()方法将碎片从活动中移除，但如果在事务提交之前没有使用addToBackStack()方法，这时碎片也会进入到销毁状态。\nfragment的回调方法\nonAttach().当碎片和活动建立起关联的时候调用\n\nonCreateView().为碎片加载布局时调用\n\nonActivityCreated().确保与碎片相关联的活动一定已经创建完毕时使用\n\nonDestroyView().当与碎片相关联的视图被移除的时候调用\n\nonDetach().当碎片和活动解除关联时调用\n\n\n碎片的完整生命周期示意图：\n\n体验生命周期class RightFragment:Fragment() &#123;    companion object&#123;        const val TAG=&quot;RightFragment&quot;    &#125;        override fun onAttach(context: Context) &#123;        super.onAttach(context)        Log.d(TAG, &quot;onAttach: &quot;)    &#125;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        Log.d(TAG, &quot;onCreate: &quot;)    &#125;    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View? &#123;        Log.d(TAG, &quot;onCreateView: &quot;)        return inflater.inflate(R.layout.right_fragment,container,false)            &#125;    override fun onActivityCreated(savedInstanceState: Bundle?) &#123;        super.onActivityCreated(savedInstanceState)        Log.d(TAG, &quot;onActivityCreated: &quot;)    &#125;           override fun onStart() &#123;        super.onStart()        Log.d(TAG, &quot;onStart: &quot;)    &#125;    override fun onResume() &#123;        super.onResume()        Log.d(TAG, &quot;onResume: &quot;)    &#125;       override fun onPause() &#123;        super.onPause()        Log.d(TAG, &quot;onPause: &quot;)    &#125;    override fun onStop() &#123;           super.onStop()        Log.d(TAG, &quot;onStop: &quot;)    &#125;       override fun onDestroyView() &#123;        super.onDestroyView()        Log.d(TAG, &quot;onDestroyView: &quot;)    &#125;    override fun onDestroy() &#123;        super.onDestroy()        Log.d(TAG, &quot;onDestroy: &quot;)    &#125;    override fun onDetach()&#123;        super.onDetach()        Log.d(TAG, &quot;onDetach: &quot;)    &#125;&#125;\n\n\n限定符使用限定符\n使用限定符新建一个layout文件夹(layout-large)\n\n在里面新建一个活动布局\n\n小屏设备加载layout下布局，大屏加载layout-large下布局\n//layou-large下布局&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:orientation=&quot;horizontal&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;fragmentandroid:id=&quot;@+id/leftFrag&quot;android:name=&quot;com.example.fragmenttest.LeftFragment&quot;android:layout_width=&quot;0dp&quot;android:layout_height=&quot;match_parent&quot;android:layout_weight=&quot;1&quot;/&gt;&lt;fragmentandroid:id=&quot;@+id/rightFrag&quot;android:name=&quot;com.example.fragmenttest.RightFragment&quot;android:layout_width=&quot;0dp&quot;android:layout_height=&quot;match_parent&quot;android:layout_weight=&quot;3&quot;/&gt;&lt;/LinearLayout&gt;\n\n//layout下布局&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;horizontal&quot;    &gt;    &lt;fragment        android:id=&quot;@+id/leftFrag&quot;        android:name=&quot;com.example.fragmenttest.LeftFragment&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt;\n\n常见的限定符：\n\n\n最小宽度限定符**实例：**layout-sw600dp\n**作用：**宽度大于等于600的会加载layout-sw600dp中布局，反之加载layout中布局\n\n","categories":["Android(Kotlin版)"]},{"title":"碎片(Java)","url":"/posts/%E7%A2%8E%E7%89%87/","content":"碎片是什么碎片是一种可以嵌入在活动当中的UI片段，它能让程序更加合理充分地利用大屏幕的空间，因而在平板上应用广泛。\n\n碎片的使用方式碎片的简单用法新建一个左侧碎片布局left_fragment.xml:\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;Button        android:id=&quot;@+id/button&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;center_horizontal&quot;        android:text=&quot;Button&quot;/&gt;&lt;/LinearLayout&gt;\n\n新建一个右侧碎片布局right_fragment.xml:\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;#00ff00&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;center_horizontal&quot;        android:textSize=&quot;20sp&quot;        android:text=&quot;This is right fragment&quot;/&gt;&lt;/LinearLayout&gt;\n\n新建一个LeftFragment类继承自Fragment(通过LayoutInflater的inflate()方法将定义的碎片布局动态加载进去):\npublic class LeftFragment extends Fragment &#123;    @Nullable    @Override    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;        View view=inflater.inflate(R.layout.left_fragment,container,false);        return view;    &#125;&#125;\n\n同样的方法新建一个RightFragment类：\npublic class RightFragment extends Fragment &#123;    @Override    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;        View view=inflater.inflate(R.layout.right_fragment,container,false);        return view;    &#125;&#125;\n\n接下来修改activity_main布局中的代码：\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;horizontal&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    &gt;   &lt;fragment       android:id=&quot;@+id/left_fragment&quot;       android:name=&quot;com.example.fragmenttest.LeftFragment&quot;       android:layout_width=&quot;0dp&quot;       android:layout_height=&quot;match_parent&quot;       android:layout_weight=&quot;1&quot;/&gt;   &lt;fragment       android:id=&quot;@+id/right_fragment&quot;       android:name=&quot;com.example.fragmenttest.RightFragment&quot;       android:layout_width=&quot;0dp&quot;       android:layout_height=&quot;match_parent&quot;        android:layout_weight=&quot;1&quot;/&gt;&lt;/LinearLayout&gt;\n\n动态添加碎片(1)创建待添加的碎片实例(another_right_fragment.xml)\n创建布局以及加载实例\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;#ffff00&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;center_horizontal&quot;        android:textSize=&quot;20sp&quot;        android:text=&quot;This is another right fragment&quot;/&gt;&lt;/LinearLayout&gt;\n\npublic class AnotherRightFragment extends Fragment &#123;    @Nullable    @Override    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;        View view=inflater.inflate(R.layout.another_right_fragment,container,false);        return view;    &#125;&#125;\n\n修改主活动布局文件：\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;horizontal&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    &gt;   &lt;fragment       android:id=&quot;@+id/left_fragment&quot;       android:name=&quot;com.example.fragmenttest.LeftFragment&quot;       android:layout_width=&quot;0dp&quot;       android:layout_height=&quot;match_parent&quot;       android:layout_weight=&quot;1&quot;/&gt;   &lt;FrameLayout       android:id=&quot;@+id/right_layout&quot;       android:layout_width=&quot;0dp&quot;       android:layout_height=&quot;match_parent&quot;       android:layout_weight=&quot;1&quot;&gt;     &lt;/FrameLayout&gt;&lt;/LinearLayout&gt;\n\n(2)获取FragmentManager，在活动中可以直接通过调用getSupportFragmentManager()方法得到\n(3)开启一个事务，通过调用beginTransaction()方法开启\n(4)向容器内添加或替换碎片，一般使用replace()方法实现，需要传入容器的id和待添加的碎片实例\n(5)提交事务，调用commit()方法来完成\npublic class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);       Button button=(Button) findViewById(R.id.button);        button.setOnClickListener(new View.OnClickListener() &#123;          @Override            public void onClick(View view) &#123;                if(view.getId()==R.id.button)&#123;                    replaceFragment(new AnotherRightFragment());                &#125;            &#125;        &#125;);      replaceFragment(new RightFragment());    &#125;   private void replaceFragment(Fragment fragement)&#123;        FragmentManager fragmentManager=getSupportFragmentManager();        FragmentTransaction transaction=fragmentManager.beginTransaction();        transaction.replace(R.id.right_layout,fragement);        transaction.commit();    &#125;&#125;\n\n在碎片中模拟返回栈利用addToBackStack()方法可以将一个事务添加到返回栈中\nprivate void replaceFragment(Fragment fragement)&#123;        FragmentManager fragmentManager=getSupportFragmentManager();        FragmentTransaction transaction=fragmentManager.beginTransaction();        transaction.replace(R.id.right_layout,fragement);        transaction.addToBackStack(null);        transaction.commit();&#125;\n\n碎片与活动之间进行通信调用FragmentManager的findFragmentById()方法在活动中得到相应碎片的实例，然后就能轻松调用碎片里的方法\nRightFragment rightFragment=(RightFragment) getFragmentManager().findFragmentById(R.id.right_fragment);\n\n通过getActivity可以在碎片中调用活动中的方法\nManinActivity activity=(ManinActivity) getActivity(); \n\n\n碎片的生命周期碎片的状态（1）运行状态：\n当一个碎片是可见的，并且它所关联的活动正处于运行状态时，该碎片也处于运行状态\n（2）暂停状态：\n当一个活动进入暂停状态时(由于另一个未占满屏幕的活动被添加到了栈顶)，与它相关联的可见碎片就会进入到暂停状态。\n（3）停止状态：\n当一个活动进入到停止状态时，与它相关联的碎片就会进入到停止状态，或者通过调用FragmentTransaction的remove(),replace()方法将碎片从活动中移除，但如果在事务提交之前使用addToBackStack()方法，这时的碎片也会进入到停止状态。总的来说，进入到停止状态的碎片对用户来说完全不可见，有可能被系统回收。\n（4）销毁状态：\n碎片总是依附于活动而存在，因此当活动被销毁时，与它相关联的碎片就会进入到销毁状态。或者通过调用FragmentTransaction的remove(),replace()方法将碎片从活动中移除，但如果在事务提交之前没有使用addToBackStack()方法，这时碎片也会进入到销毁状态。\n碎片的回调方法onAttach().当碎片和活动建立起关联的时候调用\nonCreateView().为碎片加载布局时调用\nonActivityCreated().确保与碎片相关联的活动一定已经创建完毕时使用\nonDestroyView().当与碎片相关联的视图被移除的时候调用\nonDetach().当碎片和活动解除关联时调用\n碎片的完整生命周期示意图：\n\n体验碎片的生命周期public class RightFragment extends Fragment &#123;    public static final String TAG=&quot;RightFragment&quot;;    @Override    public void onAttach(@NonNull Context context) &#123;        super.onAttach(context);        Log.d(TAG, &quot;onAttach&quot;);    &#125;    @Override    public void onCreate(@Nullable Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        Log.d(TAG, &quot;onCreate&quot;);    &#125;    @Nullable    @Override    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;        Log.d(TAG, &quot;onCreateView&quot;);        View view=inflater.inflate(R.layout.right_fragment,container,false);        return view;    &#125;    @Override    public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123;        super.onActivityCreated(savedInstanceState);        Log.d(TAG, &quot;onActivityCreated&quot;);    &#125;    @Override    public void onStart() &#123;        super.onStart();        Log.d(TAG, &quot;onStart&quot;);    &#125;    @Override    public void onResume() &#123;        super.onResume();        Log.d(TAG, &quot;onResume&quot;);    &#125;    @Override    public void onPause() &#123;        super.onPause();        Log.d(TAG, &quot;onPause&quot;);    &#125;    @Override    public void onStop() &#123;        super.onStop();        Log.d(TAG, &quot;onStop&quot;);    &#125;    @Override    public void onDestroyView() &#123;        super.onDestroyView();        Log.d(TAG, &quot;onDestroyView&quot;);    &#125;    @Override    public void onDestroy() &#123;        super.onDestroy();        Log.d(TAG, &quot;onDestroy&quot;);    &#125;    @Override    public void onDetach() &#123;        super.onDetach();        Log.d(TAG, &quot;onDetach&quot;);    &#125;&#125;\n\n\n加载动态布局的技巧使用限定符新建一个layout-large文件夹并在里面添加activity_main布局，layout中布局是单页模式，layout-large中布局是双页模式。其中large便是限定符，那些屏幕大的会自动识别并使用layout-large布局,屏幕小的则使用layout布局\n常见限定符如下图所示\n\n使用最小宽度限定符想更加灵活地为不同设备加载布局，这时就可以用到最小宽度限定符，这允许我们对屏幕宽度指定一个最小值，以这个值为临界，比这个大的加载一个布局，比这个小的加载另一个布局。\n例子：\n在res下新建layout-sw600dp文件夹，宽度大于600dp的加载layout-sw600dp上的布局，宽度小于600dp的加载layout上的布局\n\n","categories":["Android(Java版)"]},{"title":"红黑树","url":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/","content":"红黑树规则\n添加节点的规则\n","categories":["Java"]},{"title":"编写好用的工具","url":"/posts/%E7%BC%96%E5%86%99%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/","content":"求N个数的最大最小值使用泛型实现Comparable接口，可以适用于任意类型数字比较\nfun &lt;T:Comparable&lt;T&gt;&gt; max(vararg nums:T):T&#123;    if(nums.isEmpty()) throw RuntimeException(&quot;Params can not be empty&quot;)    var maxNum=nums[0]    for(num in nums)&#123;        if(num&gt;maxNum)&#123;            maxNum=num        &#125;    &#125;    return maxNum&#125;\n\n\n简化Toast用法//字符串调用fun String.showToast(context: Context,duration: Int=Toast.LENGTH_SHORT)&#123;    Toast.makeText(context,this,duration).show()&#125;//资源id引用时调用fun Int.showToast(context: Context,duration: Int=Toast.LENGTH_SHORT)&#123;    Toast.makeText(context,this,duration).show()&#125;\n\n\n简化Snackbar用法fun View.showSnackbar(text:String,actionText:String?=null,duration:Int=Snackbar.LENGTH_SHORT,block:(()-&gt;Unit)?=null)&#123;  val snackbar=  Snackbar.make(this,text,duration)    if(actionText!=null&amp;&amp;block!=null)&#123;        snackbar.setAction(actionText)&#123;            block()        &#125;    &#125;    snackbar.show()&#125;fun View.showSnackbar(resId:Int,actionResId:Int?=null,duration:Int=Snackbar.LENGTH_SHORT,block:(()-&gt;Unit)?=null)&#123;    val snackbar=  Snackbar.make(this,resId,duration)    if(actionResId!=null&amp;&amp;block!=null)&#123;        snackbar.setAction(actionResId)&#123;            block()        &#125;    &#125;    snackbar.show()&#125;\n\n//调用view.showSnackbar(&quot;this is Snackbar&quot;,&quot;Action&quot;)&#123;    //具体逻辑&#125;\n\n\n","categories":["Kotlin"]},{"title":"网络技术(Kotlin)","url":"/posts/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/","content":"WebView\n使用WebView控件\n\n调用getSettings方法设置浏览器属性\n\n传入WebViewClient实例\n\n传入网址\n\n声明网络权限\n&lt;WebView        android:id=&quot;@+id/webView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;/&gt;\n\nclass MainActivity : AppCompatActivity() &#123;    private lateinit var binding:ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        enableEdgeToEdge()        binding=ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) &#123; v, insets -&gt;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)            insets        &#125;        binding.webView.settings.javaScriptEnabled=true        //当需要从一个网页跳转到另一个网页时，目标网页仍在WebView中展示，而不是打开系统浏览器        binding.webView.webViewClient= WebViewClient()        binding.webView.loadUrl(&quot;https://www.baidu.com&quot;)    &#125;&#125;\n\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;\n\n\n使用HTTP访问网络HttpURLConnection\n获取HttpURLConnection实例\n设置请求方法\n自由定制一些功能\n得到从服务器返回的输入流，并对输入流进行读取\n将HTTP连接关闭\n记得声明权限\n\nclass MainActivity : AppCompatActivity() &#123;    private lateinit var binding: ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        enableEdgeToEdge()        binding= ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) &#123; v, insets -&gt;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)            insets        &#125;        binding.sendRequest.setOnClickListener &#123;            sendRequestWithHttpURLConnection()        &#125;    &#125;       private fun sendRequestWithHttpURLConnection() &#123;        //开启线程发送网络请求        thread &#123;            var connection:HttpURLConnection?=null            try &#123;                val response=StringBuilder()                val url=URL(&quot;https://www.baidu.com&quot;)                connection=url.openConnection() as HttpURLConnection                connection.connectTimeout=8000                connection.readTimeout=8000                val input=connection.inputStream                //下面对获取到的输入流进行读取                val reader=BufferedReader(InputStreamReader(input))                reader.use &#123;                    reader.forEachLine &#123;                        response.append(it)                    &#125;                &#125;                showResponse(response.toString())            &#125;catch (e:Exception)&#123;                e.printStackTrace()            &#125;finally &#123;                //断开连接                connection?.disconnect()            &#125;        &#125;    &#125;private fun showResponse(response: String) &#123;        runOnUiThread &#123;            //在这里进行UI操作，将结果显示到界面上            binding.responseText.text=response        &#125;    &#125;&#125;\n\n使用OkHttp发送GET请求\n\n安装依赖库\n\n创建一个OkHttpClient()实例\n\n创建Request对象，通过连缀丰富对象\n\n通过newCall方法获取Call对象，并调用execute方法发送请求并获取服务器返回的数据\n\n得到返回数据的具体内容\nimplementation(&quot;com.squareup.okhttp3:okhttp:4.11.0&quot;)\n\n\n\nprivate fun sendRequestWithOkHttp() &#123;       //开启线程发送网络请求       thread &#123;           try &#123;               val client=OkHttpClient()               val request=Request.Builder()                   .url(&quot;https://www.baidu.com&quot;)                                   .build()               val response=client.newCall(request).execute()               val responseData=response.body?.string()               if (responseData!=null)&#123;                   showResponse(responseData)               &#125;           &#125;catch (e:Exception)&#123;               e.printStackTrace()           &#125;       &#125;   &#125;\n\n发送POST请求\n\n安装依赖库\n\n创建一个OkHttpClient()实例\n\n创建一个RequestBody对象\n\n创建Request对象，并调用post方法，通过连缀丰富对象\n\n通过newCall方法获取Call对象，并调用execute方法发送请求并获取服务器返回的数据\n\n得到返回数据的具体内容\nimplementation(&quot;com.squareup.okhttp3:okhttp:4.11.0&quot;)\n\nprivate fun sendRequestWithOkHttp() &#123;       //开启线程发送网络请求       thread &#123;           try &#123;               val client=OkHttpClient()               val requestBody=FormBody.Builder()                   .add(&quot;username&quot;,&quot;admin&quot;)               \t.add(&quot;password&quot;,&quot;123456&quot;)               \t.build()               val request=Request.Builder()                   .url(&quot;https://www.baidu.com&quot;)                  \t.post(requestBody)                   .build()               val response=client.newCall(request).execute()               val responseData=response.body?.string()               if (responseData!=null)&#123;                   showResponse(responseData)               &#125;           &#125;catch (e:Exception)&#123;               e.printStackTrace()           &#125;       &#125;   &#125;\n\n\n解析XML数据Pull解析方式\n创建XmlPullParserFactory实例,并得到得到XmlPullParser对象\n\n将服务器返回的XML数据设置进去\n\n开始解析，用geteventType()得到当前解析的事件\n\n在while循环中不断进行解析，调用next获得下一个解析事件\n\n在循环内通过getName获得名字，用nextText获取具体内容\n\n为了让程序可以使用HTTP，还要在xml文件中添加配置\n\n在AndroidManifest中启动配置文件\nprivate fun parseXMLWithPull(xmlData:String)&#123;           try &#123;               //创建XmlPullParserFactory实例               val factory=XmlPullParserFactory.newInstance()               //借助XmlPullParserFactory实例得到XmlPullParser对象               val xmlPullParser=factory.newPullParser()               //将服务器返回的XML数据设置进去               xmlPullParser.setInput(StringReade r(xmlData))               //开始解析               //用geteventType()得到当前解析的事件               var eventType=xmlPullParser.eventType               var id=&quot;&quot;               var name=&quot;&quot;               var version=&quot;&quot;               //当eventType!=XmlPullParser.END_DOCUMENT说明解析工作还未完成               while(eventType!=XmlPullParser.END_DOCUMENT)&#123;                   //通过getName得到当前节点的名字                   val nodeName=xmlPullParser.name                   when (eventType) &#123;                       //开始解析某节点                       XmlPullParser.START_TAG-&gt;&#123;                           when(nodeName)&#123;                                //通过nextText()获取节点具体内容                               &quot;id&quot;-&gt;id=xmlPullParser.nextText()                               &quot;name&quot;-&gt;name=xmlPullParser.nextText()                               &quot;version&quot;-&gt;version=xmlPullParser.nextText()                           &#125;                       &#125;                       //完成解析某个节点                       XmlPullParser.END_TAG-&gt;&#123;                           if(&quot;app&quot;==nodeName)&#123;                               Log.d(&quot;MainActivity&quot;, &quot;id is $id&quot;)                               Log.d(&quot;MainActivity&quot;, &quot;name is $name&quot;)                               Log.d(&quot;MainActivity&quot;, &quot;version is $version&quot;)                           &#125;                       &#125;                   &#125;                   //调用next()方法获取下一个解析事件                   eventType=xmlPullParser.next()                  &#125;           &#125;catch (e:Exception)&#123;               e.printStackTrace()           &#125;   &#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt;    &lt;base-config cleartextTrafficPermitted=&quot;true&quot;&gt;        &lt;trust-anchors&gt;            &lt;certificates src=&quot;system&quot;/&gt;        &lt;/trust-anchors&gt;    &lt;/base-config&gt;&lt;/network-security-config&gt;\n\nandroid:networkSecurityConfig=&quot;@xml/neiwork_config&quot;\n\nSAX解析方式\n新建一个类继承DefaultHandler,并重写五种方法\n创建SAXParserFactory实例\n获取XMLReader对象\n将编写的实例类设置到XMLReader中\n调用parse方法开始执行\n\nclass MyHandle:DefaultHandler() &#123;    private var nodeName=&quot;&quot;    private lateinit var id:StringBuilder    private lateinit var name:StringBuilder    private lateinit var version:StringBuilder    //开始XML解析时调用    override fun startDocument() &#123;        id=StringBuilder()        name=StringBuilder()        version=StringBuilder()    &#125;\t//开始解析某个节点时调用    override fun startElement(        uri: String?,        localName: String?,        qName: String?,        attributes: Attributes?    ) &#123;        // localName记录当前节点名称        nodeName= localName!!        Log.d(&quot;MyHandle&quot;, &quot;uri is $uri&quot;)        Log.d(&quot;MyHandle&quot;, &quot;localName is $localName&quot;)        Log.d(&quot;MyHandle&quot;, &quot;qName is $qName&quot;)        Log.d(&quot;MyHandle&quot;, &quot;attributes is $attributes&quot;)    &#125;\t//获取节点内内容时调用    override fun characters(ch: CharArray?, start: Int, length: Int) &#123;        //根据当前节点名判断加到哪个StringBuilder对象中        when(nodeName)&#123;            &quot;id&quot;-&gt;id.append(ch,start,length)            &quot;name&quot;-&gt;name.append(ch,start,length)            &quot;version&quot;-&gt;version.append(ch,start,length)        &#125;    &#125;//完成解析某个节点时调用    override fun endElement(uri: String?, localName: String?, qName: String?) &#123;        if (&quot;app&quot;==localName)&#123;            //trim()方法是用于去除字符串两端的空白字符            Log.d(&quot;MyHandle&quot;, &quot;id is $&#123;id.toString().trim()&#125; &quot;)            Log.d(&quot;MyHandle&quot;, &quot;name is $&#123;name.toString().trim()&#125; &quot;)            Log.d(&quot;MyHandle&quot;, &quot;version is $&#123;version.toString().trim()&#125; &quot;)            //最后将StringBuilder内容清空            id.setLength(0)            name.setLength(0)            version.setLength(0)        &#125;    &#125;   //完成xml解析时调用    override fun endDocument() &#123;        super.endDocument()    &#125;&#125;\n\n private fun parseXMLWithSAX(xmlData: String) = try &#123;        val factory=SAXParserFactory.newInstance()        val xmlReader=factory.newSAXParser().xmlReader        val handler= MyHandle()        //将MyHandle的实例设置到XMLReader中        xmlReader.contentHandler=handler        //开始执行解析        xmlReader.parse(InputSource(StringReader(xmlData)))    &#125;catch (e:Exception)&#123;        e.printStackTrace()    &#125;&#125;\n\n\n\n\n解析JSON格式数据使用JSONObject\n定义一个数组，将返回的数据传入到JSONArray对象中\n循环遍历数组，取出各个元素\n\nprivate fun parseJSONWithJSONObject(jsonData: String) &#123;        try &#123;            //定义一个JSON数组            val jsonArray=JSONArray(jsonData)            //循环遍历            for (i in 0 until jsonArray.length())&#123;                //取出元素，每个取出的元素都是一个jsonObject对象                val jsonObject=jsonArray.getJSONObject(i)                val id=jsonObject.getString(&quot;id&quot;)                val name=jsonObject.getString(&quot;name&quot;)                val version=jsonObject.getString(&quot;version&quot;)                Log.d(&quot;MainActivity&quot;, &quot;id is $id&quot;)                Log.d(&quot;MainActivity&quot;, &quot;name is $name&quot;)                Log.d(&quot;MainActivity&quot;, &quot;version is $version&quot;)            &#125;        &#125;catch (e:Exception)&#123;            e.printStackTrace()        &#125;    &#125;\n\n\n\n使用GSON优点：可以将一段JSON格式的字符串自动映射成一个对象，不需要再手动编写代码解析\n\n添加依赖库\n获取Gson对象\n如果是一个JSON数据，可以调用fromJson方法，如果是一段Json数组需要借助TypeToken将期望解析成的数据类型传入fromJson方法\n\nimplementation (&quot;com.google.code.gson:gson:2.10.1&quot;)\n\nprivate fun parseJSONWithGSON(jsonData: String) &#123;       val gson=Gson()       val typeOf=object :TypeToken&lt;List&lt;App&gt;&gt;() &#123;&#125;.type       val appList=gson.fromJson&lt;List&lt;App&gt;&gt;(jsonData,typeOf)       for(app in appList)&#123;           Log.d(&quot;MainActivity&quot;, &quot;id is $&#123;app.id&#125;&quot;)           Log.d(&quot;MainActivity&quot;, &quot;name is $&#123;app.name&#125;&quot;)           Log.d(&quot;MainActivity&quot;, &quot;version is $&#123;app.version&#125;&quot;)       &#125;   &#125;\n\n\n网络请求回调的实现方式采用回调的原因：所有耗时逻辑在子线程中进行，sendHttpRequest()方法在服务器还没来得及响应的时候就执行结束\nHttpURLConnection方法\n将请求方法放入到单例类中\n\n定义一个接口，并定义方法\n\n给方法添加一个接口参数，并开启一个子线程\n\n在线程中回调接口方法\n\n调用sendRequestWithHttpURLConnection()方法，调用时还需将接口实例传入\ninterface HttpCallbackListener &#123;    fun onFinish(response:String)    fun onError(e: Exception)&#125;\n\nobject HttpUtil &#123;     fun sendRequestWithHttpURLConnection(adress: String, listener: HttpCallbackListener) &#123;        //开启线程发送网络请求        thread &#123;            var connection: HttpURLConnection? = null            try &#123;                val response = StringBuilder()                val url = URL(adress)                connection = url.openConnection() as HttpURLConnection                connection.connectTimeout = 8000                connection.readTimeout = 8000                val input = connection.inputStream                //下面对获取到的输入流进行读取                val reader = BufferedReader(InputStreamReader(input))                reader.use &#123;                    reader.forEachLine &#123;                        response.append(it)                    &#125;                &#125;                //回调onFinish()方法                listener.onFinish(response.toString())            &#125; catch (e: Exception) &#123;                e.printStackTrace()                //回调onError方法                listener.onError(e)            &#125; finally &#123;                connection?.disconnect()            &#125;        &#125;    &#125;&#125;\n\nHttpUtil.sendRequestWithHttpURLConnection(adress,object:HttpCallbackListener&#123;    override fun onFinish(response:String)&#123;        //得到服务器返回的具体内容    &#125;     override fun onError(e:Exception)&#123;        //在这里对异常情况进行处理    &#125;&#125;)\n\nOkHttp方法\n将请求方法放入到单例类中\n传入okhttp3.Callback参数，这是oKHttp库自带的回调接口\n在newCall后调用enqueue方法，并传入接口参数\n调用sendRequestWithOkHttp()方法\n\nfun sendRequestWithOkHttp(adress: String, callback: okhttp3.Callback) &#123;       val client = OkHttpClient()       val request = Request.Builder()           .url(adress)           .build()       //enqueue()内部帮我们开好了子线程，然后子线程中执行Http请求    client.newCall(request).enqueue(callback)   &#125;\n\nHttpUtil.sendRequestWithOkHttp(adress,object:Callback&#123;    override fun onResponse(call:Call,response:Response)&#123;        //得到服务器返回的具体内容        val responseData=response.body?.string()    &#125;    override fun onFailure(call:Call,e:IOException)&#123;         //在这里对异常情况进行处理    &#125;&#125;)\n\n\n最好用的网络库：Retrofit基本用法\n添加依赖库\n\n定义接口，使用@GET注解表示调用方法时Retrofit会发起一条GET请求，请求地址就是注解中传入的具体参数\n\n构建Retrofit对象,baseUrl用于指定所以Retrofit请求的根路径,addConverterFactory用于指定Retrofit在解析数据时所使用的转换库，这俩方法必须调用\n\n创建接口的动态代理对象\n\n调用接口方法返回一个Call&lt;List&gt;对象，再调用它enqueue方法（发送请求时Retrofit会自动在内部开启线程，整个操作无需考虑线程切换问题）\n\n调用response.body()方法获取Retrofit解析后的对象，也就是List类型数据，最后遍历List\n\n记得声明权限\n\n如果服务器接口是HTTP，则需要进行网络安全配置，并启动配置\n// Retrofit 核心库    implementation (&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)    // Gson 转换器    implementation (&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)\n\nbinding.getAppDataBtn.setOnClickListener &#123;          val retrofit=Retrofit.Builder()              .baseUrl(&quot;http://10.0.2.2/&quot;)              .addConverterFactory(GsonConverterFactory.create())              .build()          val appService=retrofit.create(AppService::class.java)          appService.getAppData().enqueue( object :retrofit2.Callback&lt;List&lt;App&gt;&gt; &#123;              override fun onResponse(                  call: retrofit2.Call&lt;List&lt;App&gt;&gt;,                  response: retrofit2.Response&lt;List&lt;App&gt;&gt;              ) &#123;                  val list=response.body()                  if(list!=null)&#123;                      for (app in list)&#123;                          Log.d(&quot;MainActivity&quot;, &quot;id is $&#123;app.id&#125;&quot;)                          Log.d(&quot;MainActivity&quot;, &quot;name is $&#123;app.name&#125;&quot;)                          Log.d(&quot;MainActivity&quot;, &quot;version is $&#123;app.version&#125;&quot;)                      &#125;                  &#125;              &#125;              override fun onFailure(call: retrofit2.Call&lt;List&lt;App&gt;&gt;, t: Throwable) &#123;                  t.printStackTrace()              &#125;          &#125;)      &#125;\n\n处理复杂的接口地址类型class Data(val id:String,val content:String)\n\n接口地址是静态\nGET http://example.com/get_data.jsoninterface ExampleService&#123;    @GET(&quot;get_data.json&quot;)    fun getData():Call&lt;Data&gt;&#125;\n\n接口地址是动态变化的\npage部分代表页数，传入不同页数，返回数据也不同。\nGET http://example.com/&lt;page&gt;/get_data.jsoninterface ExampleService&#123;    @GET(&quot;&#123;page&#125;/get_data.json&quot;)    fun getData(@Path(&quot;page&quot;) page:Int):Call&lt;Data&gt;&#125;\n\n接口要求传入一系列参数\n这是一个标准的带参数的GET请求格式，接口地址的最后使用问号连接参数，每个参数都是使用等号连接符连接的键值对，多个参数之间用&amp;分隔\nGET http://example.com/get_data.json?u=&lt;user&gt;&amp;t=&lt;token&gt;interface ExampleService&#123;    @GET(&quot;get_data.json&quot;)    fun getData(@Query(&quot;u&quot;) user:String,@Query(&quot;t&quot;) token:String):Call&lt;Data&gt;&#125;\n\n多种请求类型\nGET请求用于从服务器获取数据，POST请求用于从服务器提交数据，PUT和PATCH请求用于修改服务器上的数据，DELETE请求用于删除服务器上的数据\n\nDELETE请求\n使用ResponseBody的原因：POST,PUT,PATCH和DELETE与GET不同，它们更多用于对数据进行操作，而不是获取数据，所以对服务器响应的数据并不关心，ResponseBody表示能接收任意类型的响应数据，但不对数据进行解析。\nDELETE http://example.com/data/&lt;id&gt;interface ExampleService&#123;    @DELETE(&quot;data/&#123;id&#125;&quot;)    fun deleteData(@Path(&quot;id&quot;) id:String):Call&lt;ResponseBody&gt;&#125;\n\nPOST请求\nPOST http://example.com/data/create&#123;&quot;id&quot;:1,&quot;content&quot;:&quot;The description for this data.&quot;&#125;interface ExampleService&#123;    @POST(&quot;data/create&quot;)    fun createData(@Body data:Data):Call&lt;ResponseBody&gt;&#125;\n\n@Body注解作用：当发出请求时，会自动将Data对象中的数据转化成JSON格式文本，并放到HTTP请求的body部分，服务器收到请求后只需从body中将这一部分数据解析出来即可，这种写法也可用来给PUT,PATCH和DELETE请求提交数据\n\n在HTTP请求的header中指定参数\nGET http://example.com/get_data.jsonUser-Agent:okhttpCache-Control:max-age=0\n\n这些header参数其实就是一个个键值对\n静态header声明：\ninterface ExampleService&#123;    @Headers(&quot;User-Agent:okhttp&quot;,&quot;Cache-Control:max-age=0&quot;)    @GET(&quot;get_data.json&quot;)    fun getData():Call&lt;Data&gt;&#125;\n\n动态header声明：\ninterface ExampleService&#123;    @GET(&quot;get_data.json&quot;)    fun getData(@Header(&quot;User-Agent&quot;) userAgent:String,@Header(&quot;Cache-Control&quot;) cacheControl:String):Call&lt;Data&gt;&#125;\n\nRetrofit构建器的最佳写法\n新建一个单例类\n\n将构建Retrofit写法放入\n\n使用泛型实化\n\n调用\nobject ServiceCreator&#123;    private const val BASE_URL=&quot;http://10.0.2.2/&quot;    private val retrofit=Retrofit.Builder()                .baseUrl(BASE_URL)                .addConverterFactory(GsonConverterFactory.create())                .build()    fun &lt;T&gt; create(serviceClass: Class&lt;T&gt;): T = retrofit.create(serviceClass)    inline fun &lt;reified T&gt; create(): T = create(T::class.java)&#125;\n\nval appService=ServiceCreator.create&lt;AppService&gt;()\n\n\n","categories":["Android(Kotlin版)"]},{"title":"自定义View(二)","url":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89View-%E4%BA%8C/","content":"目的自定义View显示一张图片，下面包含图片的文本介绍\n实现\n自定义属性\n\n&lt;resources&gt;    &lt;attr name=&quot;titleText&quot; format=&quot;string&quot; /&gt;    &lt;attr name=&quot;titleTextColor&quot; format=&quot;color&quot; /&gt;    &lt;attr name=&quot;titleTextSize&quot; format=&quot;dimension&quot; /&gt;    &lt;attr name=&quot;image&quot; format=&quot;reference&quot;/&gt;    &lt;attr name=&quot;imageScaleType&quot;&gt;        &lt;enum name=&quot;fillXY&quot; value=&quot;0&quot; /&gt;        &lt;enum name=&quot;center&quot; value=&quot;1&quot; /&gt;    &lt;/attr&gt;    &lt;declare-styleable name=&quot;MyView&quot;&gt;        &lt;attr name=&quot;titleText&quot; /&gt;        &lt;attr name=&quot;titleTextColor&quot; /&gt;        &lt;attr name=&quot;titleTextSize&quot; /&gt;        &lt;attr name=&quot;image&quot;/&gt;        &lt;attr name=&quot;imageScaleType&quot;/&gt;    &lt;/declare-styleable&gt;&lt;/resources&gt;\n\n\n获取自定义属性\n\n// 自定义View类，继承自Viewclass MyView @JvmOverloads constructor(    context: Context, // 上下文对象    attrs: AttributeSet? = null, // XML属性集，可为空    defStyleAttr: Int = 0  // 默认样式属性，支持style属性) : View(context, attrs, defStyleAttr) &#123;    // 声明位图变量，用于存储图片    private var mImage: Bitmap? = null    // 声明图片缩放类型变量    private var mImageScale: Int = 0    // 声明标题文本变量    private var mTitle: String = &quot;&quot;    // 声明文本颜色变量，默认为黑色    private var mTextColor: Int = Color.BLACK    // 声明文本大小变量    private var mTextSize: Int = 0    // 声明View宽度变量    private var mWidth=0    // 声明View高度变量    private var mHeight=0    // 声明矩形对象，用于定义绘制区域    private val rect = Rect()    // 声明画笔对象，用于绘制图形    private val mPaint = Paint()    // 声明文本边界矩形，用于计算文本尺寸    private val mTextBound = Rect()    // 初始化代码块    init &#123;        // 获取主题中的样式属性        val a = context.theme.obtainStyledAttributes(            attrs, // 属性集            R.styleable.MyView, // 自定义属性数组            defStyleAttr, // 默认样式            0 // 默认值        )        // 遍历所有属性        for (i in 0 until a.indexCount) &#123;            // 根据属性类型进行不同处理            when (val attr = a.getIndex(i)) &#123;                // 处理图片属性                R.styleable.MyView_image -&gt; &#123;                    // 获取资源ID                    val resId = a.getResourceId(attr, 0)                    // 如果资源ID有效，则解码位图                    if (resId != 0) &#123;                        mImage = BitmapFactory.decodeResource(resources, resId)                    &#125;                &#125;                // 处理图片缩放类型属性                R.styleable.MyView_imageScaleType -&gt; &#123;                    mImageScale = a.getInt(attr, 0)                &#125;                // 处理标题文本属性                R.styleable.MyView_titleText -&gt; &#123;                    mTitle = a.getString(attr) ?: &quot;&quot;                &#125;                // 处理标题文本颜色属性                R.styleable.MyView_titleTextColor -&gt; &#123;                    mTextColor = a.getColor(attr, Color.BLACK)                &#125;                // 处理标题文本大小属性                R.styleable.MyView_titleTextSize -&gt; &#123;                    mTextSize = a.getDimensionPixelSize(                        attr, // 属性索引                        // 默认值：16sp转换为像素                        TypedValue.applyDimension(                            TypedValue.COMPLEX_UNIT_SP, // 单位类型：sp                            16f, // 默认大小：16                            resources.displayMetrics // 显示指标                        ).toInt() // 转换为整数                    )                &#125;            &#125;        &#125;        // 回收属性对象，释放资源        a.recycle()        // 设置画笔的文本大小        mPaint.textSize = mTextSize.toFloat()        // 计算文本边界，获取文本的宽高信息        mPaint.getTextBounds(mTitle, 0, mTitle.length, mTextBound)    &#125;&#125;\n\n\n重写onMeasure方法\n\n// 重写测量方法，计算View的尺寸    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123;        // 处理宽度测量        var specMode = MeasureSpec.getMode(widthMeasureSpec) // 获取宽度测量模式        var specSize = MeasureSpec.getSize(widthMeasureSpec) // 获取宽度测量大小        // 根据测量模式计算宽度        mWidth = when (specMode) &#123;            // 精确模式：直接使用指定的大小            MeasureSpec.EXACTLY -&gt; &#123;                Log.e(&quot;xxx&quot;, &quot;EXACTLY&quot;) // 输出日志                specSize            &#125;            // 最大模式：不能超过指定大小            MeasureSpec.AT_MOST -&gt; &#123;                // 根据图片计算期望宽度                val desireByImg = paddingLeft + paddingRight + (mImage?.width ?: 0)                // 根据文本计算期望宽度                val desireByTitle = paddingLeft + paddingRight + mTextBound.width()                // 取两者中的最大值                val desire = maxOf(desireByImg, desireByTitle)                Log.e(&quot;xxx&quot;, &quot;AT_MOST&quot;) // 输出日志                // 返回期望值和指定值中的较小值                minOf(desire, specSize)            &#125;            // 未指定模式：使用期望的大小            else -&gt; &#123; // MeasureSpec.UNSPECIFIED                // 根据图片计算期望宽度                val desireByImg = paddingLeft + paddingRight + (mImage?.width ?: 0)                // 根据文本计算期望宽度                val desireByTitle = paddingLeft + paddingRight + mTextBound.width()                // 返回两者中的最大值                maxOf(desireByImg, desireByTitle)            &#125;        &#125;        // 处理高度测量        specMode = MeasureSpec.getMode(heightMeasureSpec) // 获取高度测量模式        specSize = MeasureSpec.getSize(heightMeasureSpec) // 获取高度测量大小        // 根据测量模式计算高度        mHeight = when (specMode) &#123;            // 精确模式：直接使用指定的大小            MeasureSpec.EXACTLY -&gt; specSize            // 最大模式：不能超过指定大小            MeasureSpec.AT_MOST -&gt; &#123;                // 计算期望高度：内边距 + 图片高度 + 文本高度                val desire = paddingTop + paddingBottom + (mImage?.height ?: 0) + mTextBound.height()                // 返回期望值和指定值中的较小值                minOf(desire, specSize)            &#125;            // 未指定模式：使用期望的大小            else -&gt; &#123;                // 计算期望高度：内边距 + 图片高度 + 文本高度                paddingTop + paddingBottom + (mImage?.height ?: 0) + mTextBound.height()            &#125;        &#125;        // 设置测量结果，告诉父View我们的尺寸        setMeasuredDimension(mWidth, mHeight)    &#125;\n\n\n重写onDraw方法\n\n// 重写绘制方法，在画布上绘制内容    override fun onDraw(canvas: Canvas) &#123;        // 绘制边框        mPaint.strokeWidth = 4f // 设置边框宽度为4像素        mPaint.style = Paint.Style.STROKE // 设置画笔样式为描边        mPaint.color = Color.CYAN // 设置边框颜色为青色        // 绘制矩形边框，覆盖整个View区域        canvas.drawRect(0f, 0f, measuredWidth.toFloat(), measuredHeight.toFloat(), mPaint)        // 初始化绘图区域，考虑内边距        rect.left = paddingLeft // 左边界        rect.right = mWidth - paddingRight // 右边界        rect.top = paddingTop // 上边界        rect.bottom = mHeight - paddingBottom // 下边界        // 设置文字画笔样式        mPaint.color = mTextColor // 设置文本颜色        mPaint.style = Paint.Style.FILL // 设置画笔样式为填充        // 判断文字是否需要省略显示        val displayText = if (mTextBound.width() &gt; mWidth) &#123;            // 如果文本宽度超过View宽度，需要省略            val textPaint = TextPaint(mPaint) // 创建文本画笔            // 使用省略号处理文本            TextUtils.ellipsize(                mTitle, // 原始文本                textPaint, // 文本画笔                (mWidth - paddingLeft - paddingRight).toFloat(), // 可用宽度                TextUtils.TruncateAt.END // 在末尾添加省略号            ).toString()        &#125; else &#123;            // 如果文本宽度不超过View宽度，直接使用原文本            mTitle        &#125;        // 计算文字位置并绘制        val textX = if (displayText == mTitle) &#123;            // 如果是原文本，居中显示            mWidth / 2f - mTextBound.width() / 2f        &#125; else &#123;            // 如果是省略文本，左对齐显示            paddingLeft.toFloat()        &#125;        val textY = (mHeight - paddingBottom).toFloat() // 文本Y坐标，考虑下内边距        canvas.drawText(displayText, textX, textY, mPaint) // 绘制文本        // 图片绘制区域去掉文字高度部分        rect.bottom -= mTextBound.height() // 减去文本高度，为图片留出空间        // 绘制图片        mImage?.let &#123; bitmap -&gt;            if (mImageScale == 0) &#123;                // 缩放模式：图片填充整个可用区域                canvas.drawBitmap(bitmap, null, rect, mPaint)            &#125; else &#123;                // 居中模式：图片居中显示，保持原始大小                // 计算图片的居中绘制区域                rect.left = mWidth / 2 - bitmap.width / 2 // 左边界居中                rect.right = mWidth / 2 + bitmap.width / 2 // 右边界居中                rect.top = (mHeight - mTextBound.height()) / 2 - bitmap.height / 2 // 上边界居中                rect.bottom = (mHeight - mTextBound.height()) / 2 + bitmap.height / 2 // 下边界居中                canvas.drawBitmap(bitmap, null, rect, mPaint) // 绘制位图            &#125;        &#125;    &#125;\n\n\n引入布局\n\n&lt;LinearLayout  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    xmlns:example=&quot;http://schemas.android.com/apk/res-auto&quot;    android:layout_height=&quot;match_parent&quot;    android:layout_width=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    tools:ignore=&quot;ResAuto&quot;&gt;    &lt;com.example.viewtest.MyView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;10dp&quot;        android:padding=&quot;10dp&quot;        example:image=&quot;@drawable/custom_img&quot;        example:imageScaleType=&quot;center&quot;        example:titleText=&quot;hello andorid ! &quot;        example:titleTextColor=&quot;#ff0000&quot;        example:titleTextSize=&quot;30sp&quot; /&gt;    &lt;com.example.viewtest.MyView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;10dp&quot;        android:padding=&quot;10dp&quot;        example:image=&quot;@drawable/vol_01&quot;        example:imageScaleType=&quot;center&quot;        example:titleText=&quot;helloworld&quot;        example:titleTextColor=&quot;#00ff00&quot;        example:titleTextSize=&quot;20sp&quot; /&gt;    &lt;com.example.viewtest.MyView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;10dp&quot;        android:padding=&quot;10dp&quot;        example:image=&quot;@drawable/vol_02&quot;        example:imageScaleType=&quot;fillXY&quot;        example:titleText=&quot;妹子~&quot;        example:titleTextColor=&quot;#ff0000&quot;        example:titleTextSize=&quot;12sp&quot; /&gt;&lt;/LinearLayout&gt;\n\n\n","categories":["自定义View"]},{"title":"自定义ViewGroup","url":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup/","content":"作用类似于自定义布局\n职责ViewGroup相当于一个放置View的容器，并且我们在写布局xml的时候，会告诉容器（凡是以layout为开头的属性，都是为用于告诉容器的），我们的宽度（layout_width）、高度（layout_height）、对齐方式（layout_gravity）等；当然还有margin等；于是乎，ViewGroup的职能为：给childView计算出建议的宽和高和测量模式 ；决定childView的位置；为什么只是建议的宽和高，而不是直接确定呢，别忘了childView宽和高可以设置为wrap_content，这样只有childView才能计算出自己的宽和高。\n步骤\n决定该ViewGroup的LayoutParams\n重写onMeasure方法\n重写onLayout方法\n使用该布局\n\n完整代码实例class ViewLayout(context: Context, attrs: AttributeSet?):ViewGroup(context,attrs) &#123;    override fun generateLayoutParams(attrs: AttributeSet?): ViewGroup.LayoutParams &#123;        return MarginLayoutParams(context,attrs)    &#125;    /**     * 计算所有ChildView的宽度和高度 然后根据ChildView的计算结果，设置自己的宽和高     */    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123;        /**         * 获得此ViewGroup上级容器为其推荐的宽和高，以及计算模式         */        val widthMode = MeasureSpec.getMode(widthMeasureSpec)        val heightMode = MeasureSpec.getMode(heightMeasureSpec)        val sizeWidth = MeasureSpec.getSize(widthMeasureSpec)        val sizeHeight = MeasureSpec.getSize(heightMeasureSpec)        // 计算出所有的childView的宽和高        measureChildren(widthMeasureSpec, heightMeasureSpec)        /**         * 记录如果是wrap_content是设置的宽和高         */        var width = 0        var height = 0        val cCount = childCount        var cWidth = 0        var cHeight = 0        var cParams: MarginLayoutParams? = null        // 用于计算左边两个childView的高度        var lHeight = 0        // 用于计算右边两个childView的高度，最终高度取二者之间大值        var rHeight = 0        // 用于计算上边两个childView的宽度        var tWidth = 0        // 用于计算下面两个childiew的宽度，最终宽度取二者之间大值        var bWidth = 0        /**         * 根据childView计算的出的宽和高，以及设置的margin计算容器的宽和高，主要用于容器是warp_content时         */        for (i in 0..&lt;cCount) &#123;            val childView = getChildAt(i)            cWidth = childView.measuredWidth            cHeight = childView.measuredHeight            cParams = childView.layoutParams as MarginLayoutParams            // 上面两个childView            if (i == 0 || i == 1) &#123;                tWidth += cWidth + cParams!!.leftMargin + cParams!!.rightMargin            &#125;            if (i == 2 || i == 3) &#123;                bWidth += cWidth + cParams!!.leftMargin + cParams!!.rightMargin            &#125;            if (i == 0 || i == 2) &#123;                lHeight += cHeight + cParams!!.topMargin + cParams!!.bottomMargin            &#125;            if (i == 1 || i == 3) &#123;                rHeight += cHeight + cParams!!.topMargin + cParams!!.bottomMargin            &#125;        &#125;        width = max(tWidth.toDouble(), bWidth.toDouble()).toInt()        height = max(lHeight.toDouble(), rHeight.toDouble()).toInt()        /**         * 如果是wrap_content设置为我们计算的值         * 否则：直接设置为父容器计算的值         */        setMeasuredDimension(            if (widthMode == MeasureSpec.EXACTLY)                sizeWidth            else                width, if (heightMode == MeasureSpec.EXACTLY)                sizeHeight            else                height        )    &#125;    // abstract method in viewgroup    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) &#123;        val cCount = childCount        var cWidth = 0        var cHeight = 0        var cParams: MarginLayoutParams? = null        /**         * 遍历所有childView根据其宽和高，以及margin进行布局         */        for (i in 0..&lt;cCount) &#123;            val childView = getChildAt(i)            cWidth = childView.measuredWidth            cHeight = childView.measuredHeight            cParams = childView.layoutParams as MarginLayoutParams            var cl = 0            var ct = 0            var cr = 0            var cb = 0            when (i) &#123;                0 -&gt; &#123;                    cl = cParams!!.leftMargin                    ct = cParams!!.topMargin                &#125;                1 -&gt; &#123;                    cl = (width - cWidth - cParams!!.rightMargin)                    ct = cParams!!.topMargin                &#125;                2 -&gt; &#123;                    cl = cParams!!.leftMargin                    ct = height - cHeight - cParams!!.bottomMargin                &#125;                3 -&gt; &#123;                    cl = (width - cWidth - cParams!!.rightMargin)                    ct = height - cHeight - cParams!!.bottomMargin                &#125;            &#125;            cr = cl + cWidth            cb = cHeight + ct            childView.layout(cl, ct, cr, cb)        &#125;    &#125;&#125;\n\n&lt;com.example.studyviewgrope.ViewLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:background=&quot;#AA333333&quot; &gt;    &lt;TextView        android:layout_width=&quot;150dp&quot;        android:layout_height=&quot;150dp&quot;        android:background=&quot;#E5ED05&quot;        android:gravity=&quot;center&quot;        android:text=&quot;0&quot;        android:textColor=&quot;#FFFFFF&quot;        android:textSize=&quot;22sp&quot;        android:textStyle=&quot;bold&quot; /&gt;    &lt;TextView        android:layout_width=&quot;50dp&quot;        android:layout_height=&quot;50dp&quot;        android:background=&quot;#00ff00&quot;        android:gravity=&quot;center&quot;        android:text=&quot;1&quot;        android:textColor=&quot;#FFFFFF&quot;        android:textSize=&quot;22sp&quot;        android:textStyle=&quot;bold&quot; /&gt;    &lt;TextView        android:layout_width=&quot;50dp&quot;        android:layout_height=&quot;50dp&quot;        android:background=&quot;#ff0000&quot;        android:gravity=&quot;center&quot;        android:text=&quot;2&quot;        android:textColor=&quot;#FFFFFF&quot;        android:textSize=&quot;22sp&quot;        android:textStyle=&quot;bold&quot; /&gt;    &lt;TextView        android:layout_width=&quot;150dp&quot;        android:layout_height=&quot;150dp&quot;        android:background=&quot;#0000ff&quot;        android:gravity=&quot;center&quot;        android:text=&quot;3&quot;        android:textColor=&quot;#FFFFFF&quot;        android:textSize=&quot;22sp&quot;        android:textStyle=&quot;bold&quot; /&gt;&lt;/com.example.studyviewgrope.ViewLayout&gt;\n\n","categories":["自定义View"]},{"title":"自定义View(一)","url":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89View(%E4%B8%80)/","content":"基本步骤自定义View的属性\nformat取值类型：\n\n\n\n格式类型\n含义说明\n\n\n\nreference\n资源引用，例如 @string/app_name、@drawable/icon\n\n\nstring\n字符串文本，例如 &quot;Hello&quot;\n\n\ninteger\n整数，例如 42\n\n\nboolean\n布尔值，例如 true、false\n\n\ncolor\n颜色值，例如 #FF0000 或 @color/primary\n\n\ndimension\n尺寸值，例如 16dp、12sp\n\n\nfloat\n浮点数，例如 3.14\n\n\nenum\n枚举值（需配合 &lt;enum&gt; 使用）\n\n\nflag\n位标志（可多选，需配合 &lt;flag&gt; 使用）\n\n\n\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt;    &lt;attr name=&quot;titleText&quot; format=&quot;string&quot; /&gt;    &lt;attr name=&quot;titleTextColor&quot; format=&quot;color&quot; /&gt;    &lt;attr name=&quot;titleTextSize&quot; format=&quot;dimension&quot; /&gt;    &lt;declare-styleable name=&quot;MyView&quot;&gt;        &lt;attr name=&quot;titleText&quot; /&gt;        &lt;attr name=&quot;titleTextColor&quot; /&gt;        &lt;attr name=&quot;titleTextSize&quot; /&gt;    &lt;/declare-styleable&gt;&lt;/resources&gt;\n\n在View的构造方法中获得我们自定义的属性// 自定义 View，支持自定义属性class MyView @JvmOverloads constructor(    context: Context,    attrs: AttributeSet? = null,    defStyleAttr: Int = 0  // 支持 style 属性) : View(context, attrs, defStyleAttr) &#123;    // 显示的文本    private var mTitleText: String = &quot;&quot;    // 文本颜色    private var mTitleTextColor: Int = Color.BLACK    // 文本大小（像素）    private var mTitleTextSize: Int = 0    // 用于记录文本的边界矩形    //用于 存储当前文字的实际宽高，以便在 onMeasure() 和 onDraw() 中正确地布局和绘制文字。    private val mBound: Rect = Rect()    // 画笔对象,用于绘制文本、图形、颜色等    private val mPaint: Paint = Paint()    init &#123;        // 读取自定义属性        attrs?.let &#123;            //从 XML 中获取自定义属性值（包括默认值、主题值）并赋给你的 View 成员变量            val typedArray = context.theme.obtainStyledAttributes(                it,                R.styleable.MyView, // 需要在 attrs.xml 中声明                defStyleAttr,                0            )            try &#123;                // 获取 titleText 属性                mTitleText = typedArray.getString(R.styleable.MyView_titleText) ?: &quot;&quot;                // 获取 titleTextColor 属性，默认为黑色                mTitleTextColor = typedArray.getColor(                    R.styleable.MyView_titleTextColor,                    Color.BLACK                )                // 获取 titleTextSize 属性，默认为 16sp                mTitleTextSize = typedArray.getDimensionPixelSize(                    R.styleable.MyView_titleTextSize,                    TypedValue.applyDimension(                        TypedValue.COMPLEX_UNIT_SP, 16f, resources.displayMetrics                    ).toInt()                )            &#125; finally &#123;                typedArray.recycle() // 回收 TypedArray，防止内存泄漏            &#125;        &#125;        // 初始化画笔        mPaint.textSize = mTitleTextSize.toFloat()        mPaint.color = mTitleTextColor        // 计算文本的边界        /**         * | 参数                  | 含义                         |         * | ------------------- | -------------------------- |         * | `mTitleText`        | 你要测量的文字内容                  |         * | `0`                 | 起始字符索引                     |         * | `mTitleText.length` | 结束字符索引（不包含）                |         * | `mBound`            | 用来存储文字所占矩形区域的对象，类型是 `Rect` |         *         */        mPaint.getTextBounds(mTitleText, 0, mTitleText.length, mBound)    &#125;&#125;\n\n\n\n[重写onMeasure()方法]（并非必要）// 测量 View 的宽高    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123;        val widthMode = MeasureSpec.getMode(widthMeasureSpec)        val widthSize = MeasureSpec.getSize(widthMeasureSpec)        val heightMode = MeasureSpec.getMode(heightMeasureSpec)        val heightSize = MeasureSpec.getSize(heightMeasureSpec)        var width: Int        var height: Int        mPaint.textSize = mTitleTextSize.toFloat()        if (mTitleText.isNotEmpty()) &#123;            mPaint.getTextBounds(mTitleText, 0, mTitleText.length, mBound)        &#125;        val textWidth = mBound.width()        val textHeight = mBound.height()        // 根据测量模式决定最终宽度        width = when (widthMode) &#123;            MeasureSpec.EXACTLY -&gt; widthSize            MeasureSpec.AT_MOST -&gt; minOf(widthSize, paddingLeft + textWidth + paddingRight)            MeasureSpec.UNSPECIFIED -&gt; paddingLeft + textWidth + paddingRight            else -&gt; paddingLeft + textWidth + paddingRight        &#125;        // 根据测量模式决定最终高度        height = when (heightMode) &#123;            MeasureSpec.EXACTLY -&gt; heightSize            MeasureSpec.AT_MOST -&gt; minOf(heightSize, paddingTop + textHeight + paddingBottom)            MeasureSpec.UNSPECIFIED -&gt; paddingTop + textHeight + paddingBottom            else -&gt; paddingTop + textHeight + paddingBottom        &#125;    //提交尺寸        setMeasuredDimension(width, height)    &#125;\n\n\n\n重写onDraw()方法// 绘制内容   override fun onDraw(canvas: Canvas) &#123;       // 绘制黄色背景       mPaint.color = Color.YELLOW       /**        * | 参数       | 值                          | 含义                 |        * | -------- | -------------------------- | ------------------ |        * | `left`   | `0f`                       | 矩形左边缘坐标            |        * | `top`    | `0f`                       | 矩形上边缘坐标            |        * | `right`  | `measuredWidth.toFloat()`  | 矩形右边缘（整个 View 的宽度） |        * | `bottom` | `measuredHeight.toFloat()` | 矩形下边缘（整个 View 的高度） |        * | `mPaint` | 一个 `Paint` 对象              | 描述画笔颜色、样式、粗细等      |        *        */       canvas.drawRect(0f, 0f, measuredWidth.toFloat(), measuredHeight.toFloat(), mPaint)       // 绘制文本       mPaint.color = mTitleTextColor       /**        * | 参数           | 含义                            |        * | ------------ | ----------------------------- |        * | `mTitleText` | 要绘制的文字内容                      |        * | `x`          | 水平位置，**文字的起点 x 坐标**           |        * | `y`          | 垂直位置，**文字的 baseline（基线）y 坐标** |        * | `mPaint`     | 用于绘制的画笔，包括颜色、字体、大小等           |        *        */       canvas.drawText(           mTitleText,           (width / 2 - mBound.width() / 2).toFloat(), // 水平居中           (height / 2 + mBound.height() / 2).toFloat(), // 垂直居中           mPaint       )   &#125;\n\n如果还需要点击事件，可以在init{}里面加上注册监听器语句\nthis.setOnClickListener &#123;           //写出具体逻辑           postInvalidate() // 重新绘制       &#125;\n\n引入布局&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:custom=&quot;http://schemas.android.com/apk/res-auto&quot;//必须自定义命名空间    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:ignore=&quot;ResAuto&quot;&gt;    &lt;com.example.studyview.MyView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        custom:titleText=&quot;3712&quot;        android:padding=&quot;10dp&quot;        custom:titleTextColor=&quot;#ff0000&quot;        android:layout_centerInParent=&quot;true&quot;        custom:titleTextSize=&quot;40sp&quot;         /&gt;&lt;/RelativeLayout&gt;\n\n\n","categories":["自定义View"]},{"title":"计算机中的数据存储","url":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","content":"\n计算机主要以二进制存储数据\n二进制以0b开头\n八进制以0开头\n十六进制以0x开头\n十进制转任意进制使用除基取余法：数据除以基数记录余数直到商为0再将余数逆序排列\n任意进制转十进制：系数*基数的权次幂 相加\n\n","categories":["计算机底层"]},{"title":"运算符","url":"/posts/%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"运算符与表达式\n算术运算符+（加），-（减），*（乘），&#x2F;（除），%（取模&#x2F;取余）\n如果有小数参与运算，结果有可能不准确\n类型转换\n隐式转换（自动类型提升）\n定义：把取值范围小的数据转成取值范围大的数据\n提升规则：\n\n取值范围小的和取值范围大的进行运算，小的会先转成大的再进行运算\nbyte，short，char三种类型数据进行运算会优先转成int类型再进行运算\n\n\n强制转换\n定义：把取值范围大的数据赋值给取值范围小的变量\n格式：目标数据类型 变量&#x3D;（目标数据类型）被强制转化的数据\n\n\n字符串的”＋“操作\n\n字符相加（字符与字符，字符与数字）字符相加时会先将字符转换成ASCII码表对应的int类型数值再进行计算\n赋值运算符\n扩展的赋值运算符隐含了强制类型转换\n关系运算符\n关系运算符的结果都是boolean类型\n逻辑运算符\n短路逻辑运算符\n三元运算符格式关系表达式？表达式1：表达式2；\n计算规则：\n\n首先计算关系表达式的值\n为true返回表达式1\n为false返回表达式2\n\n运算符的优先级\n","categories":["Java"]},{"title":"高级技巧Kotlin","url":"/posts/%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7-Kotlin/","content":"全局获取Context的技巧class MyApplication : Application() &#123;    companion object &#123;        @SuppressLint(&quot;StaticFieldLeak&quot;)        lateinit var context: Context    &#125;    override fun onCreate() &#123;        super.onCreate()        context = applicationContext    &#125;&#125;\n\n&lt;application         android:name=&quot;.MyApplication&quot; /&gt;\n\nToast.makeText(MyApplication.context, &quot;onCreate&quot;, Toast.LENGTH_SHORT).show()\n\n\nIntent传递对象Serializable方式\n特点：Serializable 是 Java 提供的一个接口，它标志着一个类可以被序列化\n\n用法：\n// 定义一个可以序列化的对象data class User(val name: String, val age: Int) : Serializable// 在第一个Activity中传递对象val user = User(&quot;John&quot;, 30)val intent = Intent(this, SecondActivity::class.java)intent.putExtra(&quot;user_data&quot;, user)startActivity(intent)// 在第二个Activity中接收对象val user = intent.getSerializableExtra(&quot;user_data&quot;) as User\n\nParcelable方式\n特点：Parcelable 是 Android 提供的一种对象序列化机制，它与 Serializable 类似，目的是将对象转换为可以通过 Intent 或 Bundle 等传递的字节流，但它的实现更加高效。与 Java 标准的 Serializable 相比，Parcelable 更加高效，因为它不会依赖于反射，使用了特定的内存块和优化的序列化方式。\n\n用法：\n// 定义一个实现 Parcelable 的对象data class User() : Parcelable &#123;    val name=&quot;&quot;    val age=0    override fun writeToParcel(parcel: Parcel, flags: Int) &#123;        parcel.writeString(name)//写出name        parcel.writeInt(age)//写出age    &#125;    override fun describeContents(): Int = 0    companion object  CREATOR: Parcelable.Creator&lt;User&gt;&#123;            override fun createFromParcel(parcel: Parcel): User &#123;                val user = User()               user.name=parcel.readString()?:&quot;&quot;//读取name                user.age=parcel.readInt()//读取age                return user            &#125;            override fun newArray(size: Int): Array&lt;User?&gt; &#123;                return arrayOfNulls(size)            &#125;        &#125;    &#125;// 在第一个Activity中传递对象val user = User()user.name=&quot;John&quot;user.age=18val intent = Intent(this, SecondActivity::class.java)intent.putExtra(&quot;user_data&quot;, user)startActivity(intent)// 在第二个Activity中接收对象val user = intent.getParcelableExtra(&quot;user_data&quot;) as User\n\n注意：这里的读取顺序和写出的顺序一定要完全相同\n更简单的方法：\n@Parcelableclass Person(var name:String,var age:Int):Parcelable\n\n\n定制自己的日志工具\n开发阶段将level指定成VERBOSE，正式上线时将其指定成ERROR\n\nobject LogUtil &#123;    private const val VERBOSE = 1    private const val DEBUG = 2    private const val INFO = 3    private const val WARN = 4    private const val ERROR = 5    private var level = VERBOSE    fun v(tag: String, msg: String) &#123;        if (level &lt;= VERBOSE) &#123;            Log.v(tag, msg)        &#125;    &#125;    fun d(tag: String, msg: String) &#123;        if (level &lt;= DEBUG) &#123;            Log.d(tag, msg)        &#125;    &#125;    fun i(tag: String, msg: String) &#123;        if (level &lt;= INFO) &#123;            Log.i(tag, msg)        &#125;    &#125;    fun w(tag: String, msg: String) &#123;        if (level &lt;= WARN) &#123;            Log.w(tag, msg)        &#125;    &#125;    fun e(tag: String, msg: String) &#123;        if (level &lt;= ERROR) &#123;            Log.e(tag, msg)        &#125;    &#125;&#125;\n\nLogUtil.d(&quot;TAG&quot;, &quot;debug log&quot;)\n\n\n深色主题fun toggleTheme() &#123;    val currentMode = AppCompatDelegate.getDefaultNightMode()    if (currentMode == AppCompatDelegate.MODE_NIGHT_YES) &#123;        // 当前是深色主题，切换到浅色主题        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO)    &#125; else &#123;        // 当前是浅色主题，切换到深色主题        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES)    &#125;    // 你可以在这里保存用户的选择，以便下次启动时保持一致    val sharedPreferences = getSharedPreferences(&quot;settings&quot;, MODE_PRIVATE)    val editor = sharedPreferences.edit()    editor.putBoolean(&quot;dark_mode&quot;, currentMode == AppCompatDelegate.MODE_NIGHT_YES)    editor.apply()&#125;\n\n\n","categories":["Android(Kotlin版)"]},{"title":"高级技巧(Java)","url":"/posts/%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/","content":"全局获取Context1.定制自己的Application类\n2.在Manifest.xml中进行初始化\n3.如果有LitePal则在Application中调用LitePal初始化方法就行\npublic class MyApplication extends Application &#123;    private static Context context;    @SuppressLint(&quot;MissingSuperCall&quot;)    @Override    public void onCreate() &#123;        context = getApplicationContext();        LitePalApplication.initialize(context);    &#125;    public static Context getContext()&#123;        return context;    &#125;&#125;\n\n&lt;application       android:name=&quot;com.example.application.MyApplication&quot;&gt;&lt;/application&gt;\n\n\nIntent传递数据Serializable(序列化)1.让一个类去实现Serializable接口\n2.Intent传值\n3.调用getSerializableExtra方法接收值\npublic class Person implements Serializable &#123;    private String name;    private int age;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;\n\nPerson person=new Person();       person.setName(&quot;zx&quot;);       person.setAge(18);       Intent intent=new Intent(FirstActivity.this, SecondActivity.class);       intent.putExtra(&quot;person_data&quot;,person);       startActivity(intent);\n\nPerson person=(Person) getIntent().getSerializableExtra(&quot;person_data&quot;);\n\nParcelable1.让一个类去实现Parcelable接口\n2.重写writeToParcel方法写入数据\n3.创建一个常量CREATOR，创建Parcelable.Creator接口的一个实现\n4.重写createFromParcel方法对数据进行读取，读取顺序和写出顺序一致\n5.同上一个Intent用法基本一致\npublic class Person implements Parcelable &#123;    private String name;    private int age;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public int describeContents() &#123;        return 0;    &#125;    @Override    public void writeToParcel(@NonNull Parcel parcel, int i) &#123; parcel.writeString(name);//写出Name parcel.writeInt(age);//写出Age    &#125;    public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;() &#123;        @Override        public Person createFromParcel(Parcel in) &#123;            Person person=new Person();            person.name=in.readString();//读取name            person.age=in.readInt();//读取age            return person;        &#125;        @Override        public Person[] newArray(int size) &#123;            return new Person[size];        &#125;    &#125;;&#125;\n\nPerson person=new Person();       person.setName(&quot;zx&quot;);       person.setAge(18);       Intent intent=new Intent(FirstActivity.this, SecondActivity.class);       intent.putExtra(&quot;person_data&quot;,person);       startActivity(intent);\n\nPerson person=(Person) getIntent().getParcelableExtra(&quot;person_data&quot;);\n\n\n定制自己的日志工具1.新建一个日志类\n2.项目上线前将level定义为VERBOSE，上线后将其定义为NOTHING\npublic class LogUtil &#123;    public static final int VERBOSE=1;    public static final int DEBUG=2;    public static final int INFO=3;    public static final int WARN=4;    public static final int ERROR=5;    public static final int NOTHING=6;    public static int level=VERBOSE;    public static void v(String tag,String msg)&#123;if(level&lt;=VERBOSE)&#123;    Log.v(tag,msg);&#125;    &#125;    public static void d(String tag,String msg)&#123;if(level&lt;=DEBUG)&#123;    Log.d(tag, msg);&#125;    &#125;    public static void i(String tag,String msg)&#123;        if(level&lt;=INFO)&#123;            Log.i(tag, msg);        &#125;    &#125;    public static void w(String tag,String msg)&#123;        if(level&lt;=WARN)&#123;            Log.w(tag, msg);        &#125;    &#125;    public static void e(String tag,String msg)&#123;        if(level&lt;=ERROR)&#123;            Log.e(tag, msg);        &#125;    &#125;&#125;\n\n\n调试Android程序逐行的执行代码，查找bug\nDeBug按钮调试1.在需要调试的部分设置断点\n2.点击Debug调试按钮\nAttach debugger to Android process按钮调试1.设置断点\n2.直接运行程序\n3.点击工具栏中的Attach debugger to Android process进入Debug窗口\n\n创建定时任务Alarm机制1.建立一个新的服务\n2.在onStartCommand中开启一个新的线程\n3.利用AlarmManager进行设定(用setExact替代set，基本可以保证任务可以准时进行)\n4.启动定时服务\n@Override    public int onStartCommand(Intent intent, int flags, int startId) &#123;        //开启一个子线程        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                //在这里执行具体的逻辑操作            &#125;        &#125;).start();        //获取实例        AlarmManager manager=(AlarmManager) getSystemService(ALARM_SERVICE);        int anHour=60*60*1000;        long triggerAtTime= SystemClock.elapsedRealtime()+anHour;        //指定定时任务的服务为LongRunningService        Intent intent1=new Intent(this, LongRunningService.class);        @SuppressLint(&quot;UnspecifiedImmutableFlag&quot;) PendingIntent pi=PendingIntent.getService(this,0,intent1,0);        //调用set方法完成设定        manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,triggerAtTime,pi);        return super.onStartCommand(intent,flags,startId);    &#125;\n\n//启动定时服务Intent intent=new Intent(this, LongRunningService.class);context.startService(intent);\n\nDoze模式该模式下受限的功能：\n1.网络访问被禁止\n2.系统忽略唤醒CPU或者屏幕操作\n3.系统不再执行WIFI扫描\n4.系统不再执行同步服务\n5.Alarm服务将会在下次退出Doze模式时执行(该情况下定时任务会有误差，可以用setAndAllowWhileIdle()或setExactAndAllowWhileIdle()方法解决，这俩方法的区别和set(),setExact()之间的区别一样)\n\n多窗口模式编程一：改变进入多窗口模式活动会被重建这一默认设置：\n在Manifest.xml进行配置：\nandroid:configChanges=&quot;orientation|keyboardHidden|screenSize|screenLayout&quot;\n\n二：禁用多窗口模式：1.在或中加入如下属性：(targetSdkVersion&gt;&#x3D;24时有用)\nandroid:resizeableActivity=&quot;false&quot;//false为不支持，true为支持，默认为true\n\n2.targetSdkVersion&lt;24时，android规定活动不允许横竖屏切换时，则其也不支持多窗口模式\n只需在标签中加入以下配置：\nandroid:screenOrientation=&quot;portrait&quot;//portrait只支持竖屏，landscape只支持横屏\n\n\nLambda表达式条件：只有一个待实现方法的接口可以使用这样的写法\n实例：\nRunnable runnable=new Runnable()&#123;    @Override    public void run()&#123;        //添加具体的实现    &#125;&#125;//用Lambda改写Runnable runnable=()-&gt;&#123;   //代码逻辑&#125;;\n\n//创建接口public interface MyListener&#123;    String doSomething(String a,int b);&#125;//Lambda写法MyListener listener=(a,b)-&gt;&#123;    String result=a+b;    return result;&#125;//参数类型可以省略，如果只有一个参数还可以把括号去掉\n\n\n","categories":["Android(Java版)"]}]